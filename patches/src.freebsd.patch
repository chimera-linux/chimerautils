--- src.orig/apply/apply.c
+++ src.freebsd/apply/apply.c
@@ -40,7 +40,6 @@
 
 #include <sys/cdefs.h>
 #include <sys/types.h>
-#include <sys/sbuf.h>
 #include <sys/wait.h>
 
 #include <ctype.h>
@@ -59,6 +58,82 @@
 static int	exec_shell(const char *, const char *, const char *);
 static void	usage(void);
 
+struct sbuf {
+	char *buf;
+	size_t len;
+	size_t cap;
+};
+
+static struct sbuf *
+sbuf_new(int len)
+{
+	struct sbuf *ret = malloc(sizeof(struct sbuf));
+	if (!ret) return NULL;
+	ret->cap = len;
+	ret->len = 0;
+	ret->buf = malloc(len);
+	if (!ret->buf) {
+		free(ret);
+		return NULL;
+	}
+	return ret;
+}
+
+static void
+sbuf_clear(struct sbuf *sb)
+{
+	sb->len = 0;
+}
+
+static int
+sbuf_cat(struct sbuf *s, const char *str)
+{
+	size_t sl = strlen(str);
+	size_t nc = s->cap;
+	while ((nc - s->len) <= sl) nc *= 2;
+	if (nc > s->cap) {
+		void *np = realloc(s->buf, nc);
+		if (!np) return -1;
+		s->buf = np;
+	}
+	memcpy(&s->buf[s->len], str, sl);
+	s->len += sl;
+	return 0;
+}
+
+static int
+sbuf_putc(struct sbuf *s, int c)
+{
+	char cs[2] = {c, '\0'};
+	return sbuf_cat(s, cs);
+}
+
+static int
+sbuf_finish(struct sbuf *s)
+{
+	s->buf[s->len] = '\0';
+	return 0;
+}
+
+static void
+sbuf_delete(struct sbuf *s)
+{
+	free(s->buf);
+	free(s);
+}
+
+static ssize_t
+sbuf_len(struct sbuf *s)
+{
+	return s->len;
+}
+
+static char *
+sbuf_data(struct sbuf *s)
+{
+	return s->buf;
+}
+
 int
 main(int argc, char *argv[])
 {
@@ -66,7 +141,7 @@
 	long arg_max;
 	int ch, debug, i, magic, n, nargs, rval;
 	size_t cmdsize;
-	char buf[4];
+	char buf[16];
 	char *cmd, *name, *p, *shell, *slashp, *tmpshell;
 
 	debug = 0;
@@ -88,7 +163,7 @@
 			if (nargs != -1)
 				errx(1,
 				    "only one -# argument may be specified");
-			nargs = optopt - '0';
+			nargs = ch - '0';
 			break;
 		default:
 			usage();
@@ -161,7 +236,7 @@
 		nargs = n;
 	}
 
-	cmdbuf = sbuf_new(NULL, NULL, 1024, SBUF_AUTOEXTEND);
+	cmdbuf = sbuf_new(1024);
 	if (cmdbuf == NULL)
 		err(1, NULL);
 
@@ -186,7 +261,7 @@
 					err(1, "sbuf");
 			}
 			if (sbuf_len(cmdbuf) > arg_max)
-				errc(1, E2BIG, NULL);
+				errx(1, "argument too big");
 		}
 
 		/* Terminate the command string. */
@@ -219,18 +294,22 @@
 exec_shell(const char *command, const char *use_shell, const char *use_name)
 {
 	pid_t pid;
-	int omask, pstat;
+	int pstat;
 	sig_t intsave, quitsave;
+	sigset_t nset, oldset;
 
 	if (!command)		/* just checking... */
 		return(1);
 
-	omask = sigblock(sigmask(SIGCHLD));
+	sigemptyset(&nset);
+	sigemptyset(&oldset);
+	sigaddset(&nset, SIGCHLD);
+	sigprocmask(SIG_BLOCK, &nset, &oldset);
 	switch(pid = vfork()) {
 	case -1:			/* error */
 		err(1, "vfork");
 	case 0:				/* child */
-		(void)sigsetmask(omask);
+		sigprocmask(SIG_SETMASK, &oldset, NULL);
 		execl(use_shell, use_name, "-c", command, (char *)NULL);
 		warn("%s", use_shell);
 		_exit(1);
@@ -238,7 +317,7 @@
 	intsave = signal(SIGINT, SIG_IGN);
 	quitsave = signal(SIGQUIT, SIG_IGN);
 	pid = waitpid(pid, &pstat, 0);
-	(void)sigsetmask(omask);
+	sigprocmask(SIG_SETMASK, &oldset, NULL);
 	(void)signal(SIGINT, intsave);
 	(void)signal(SIGQUIT, quitsave);
 	return(pid == -1 ? -1 : pstat);
--- src.orig/awk/b.c
+++ src.freebsd/awk/b.c
@@ -645,7 +645,7 @@
 		f->gototab[state].entries[0].state = val;
 		f->gototab[state].inuse++;
 		return val;
-	} else if (ch > f->gototab[state].entries[f->gototab[state].inuse-1].ch) {
+	} else if (ch > (int)f->gototab[state].entries[f->gototab[state].inuse-1].ch) {
 		// not seen yet, insert and return
 		gtt *tab = & f->gototab[state];
 		if (tab->inuse + 1 >= tab->allocated)
@@ -869,7 +869,7 @@
 		 * Call u8_rune with at least awk_mb_cur_max ahead in
 		 * the buffer until EOF interferes.
 		 */
-		if (k - j < awk_mb_cur_max) {
+		if ((k - j) < 0 || (size_t)(k - j) < awk_mb_cur_max) {
 			if (k + awk_mb_cur_max > buf + bufsize) {
 				char *obuf = buf;
 				adjbuf((char **) &buf, &bufsize,
@@ -1023,6 +1023,7 @@
 		}
 		else
 			FATAL("syntax error in regular expression %s at %s", lastre, prestr);
+		break;
 	default:
 		FATAL("illegal primary in regular expression %s at %s", lastre, prestr);
 	}
--- src.orig/awk/run.c
+++ src.freebsd/awk/run.c
@@ -1982,7 +1982,6 @@
 	size_t n       = 0;
 	wchar_t wc;
 	const size_t sz = awk_mb_cur_max;
-	int unused;
 
 	if (sz == 1) {
 		buf = tostring(s);
@@ -1996,14 +1995,8 @@
 		buf = tostringN(s, strlen(s) * sz + 1);
 
 		(void) mbtowc(NULL, NULL, 0);	/* reset internal state */
-		/*
-		 * Reset internal state here too.
-		 * Assign result to avoid a compiler warning. (Casting to void
-		 * doesn't work.)
-		 * Increment said variable to avoid a different warning.
-		 */
-		unused = wctomb(NULL, L'\0');
-		unused++;
+		/* Reset internal state here too. */
+		(void) wctomb(NULL, L'\0');
 
 		ps   = s;
 		pbuf = buf;
@@ -2061,7 +2054,7 @@
 Cell *bltin(Node **a, int n)	/* builtin functions. a[0] is type, a[1] is arg list */
 {
 	Cell *x, *y;
-	Awkfloat u;
+	Awkfloat u = 0;
 	int t, sz;
 	Awkfloat tmp;
 	char *buf, *fmt;
--- src.orig/bc/dc/bcode.c
+++ src.freebsd/bc/dc/bcode.c
@@ -70,7 +70,7 @@
 static void		 pop_print(void);
 static void		 pop_printn(void);
 static __inline void	 print_stack(void);
-static __inline void	 dup(void);
+static __inline void	 dcdup(void);
 static void		 swap(void);
 static void		 drop(void);
 
@@ -195,7 +195,7 @@
 	{ '_',	parse_number	},
 	{ 'a',	to_ascii	},
 	{ 'c',	clear_stack	},
-	{ 'd',	dup		},
+	{ 'd',	dcdup		},
 	{ 'e',	print_err	},
 	{ 'f',	print_stack	},
 	{ 'i',	set_ibase	},
@@ -242,8 +242,8 @@
 		stack_init(&bmachine.reg[i]);
 
 	bmachine.readstack_sz = READSTACK_SIZE;
-	bmachine.readstack = calloc(sizeof(struct source),
-	    bmachine.readstack_sz);
+	bmachine.readstack = calloc(bmachine.readstack_sz,
+	    sizeof(struct source));
 	if (bmachine.readstack == NULL)
 		err(1, NULL);
 	bmachine.obase = bmachine.ibase = 10;
@@ -549,7 +549,7 @@
 }
 
 static __inline void
-dup(void)
+dcdup(void)
 {
 
 	stack_dup(&bmachine.stack);
--- src.orig/bintrans/uudecode.c
+++ src.freebsd/bintrans/uudecode.c
@@ -58,6 +58,7 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <libgen.h>
+#include <libutil.h>
 #include <pwd.h>
 #include <resolv.h>
 #include <stdbool.h>
@@ -476,7 +477,7 @@
 		strcpy(leftover, inbuf + count4 + 1);
 		inbuf[count4 + 1] = 0;
 
-		n = b64_pton(inbuf, outbuf, sizeof(outbuf));
+		n = compat_b64_pton(inbuf, outbuf, sizeof(outbuf));
 
 		if (n < 0)
 			break;
--- src.orig/bintrans/uuencode.c
+++ src.freebsd/bintrans/uuencode.c
@@ -55,6 +55,7 @@
 #include <err.h>
 #include <errno.h>
 #include <libgen.h>
+#include <libutil.h>
 #include <resolv.h>
 #include <stdio.h>
 #include <stdbool.h>
@@ -184,7 +185,7 @@
 	if (!raw)
 		fprintf(output, "begin-base64 %o %s\n", mode, *av);
 	while ((n = fread(buf, 1, sizeof(buf), stdin))) {
-		rv = b64_ntop(buf, n, buf2, nitems(buf2));
+		rv = compat_b64_ntop(buf, n, buf2, nitems(buf2));
 		if (rv == -1)
 			errx(1, "b64_ntop: error encoding base64");
 		if (columns == 0) {
--- src.orig/compat/merge.c
+++ src.freebsd/compat/merge.c
@@ -49,11 +49,16 @@
  * (The default is pairwise merging.)
  */
 
+#include <sys/cdefs.h>
+#include <sys/types.h>
 #include <sys/param.h>
 
+#define __is_aligned(x, align) (((uintptr_t)x & ((align) - 1)) == 0)
+
 #include <errno.h>
 #include <stdlib.h>
 #include <string.h>
+#include <stdint.h>
 
 #ifdef I_AM_MERGESORT_B
 #include "block_abi.h"
--- src.orig/compat/mktemp.c
+++ src.freebsd/compat/mktemp.c
@@ -32,99 +32,60 @@
 #if defined(LIBC_SCCS) && !defined(lint)
 static char sccsid[] = "@(#)mktemp.c	8.1 (Berkeley) 6/4/93";
 #endif /* LIBC_SCCS and not lint */
-#include "namespace.h"
+#include <sys/cdefs.h>
 #include <sys/param.h>
+#include <sys/random.h>
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <errno.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <stdint.h>
 #include <ctype.h>
 #include <unistd.h>
-#include "un-namespace.h"
+#include <time.h>
 
 char *_mktemp(char *);
 
-static int _gettemp(int, char *, int *, int, int, int);
+static int _gettemp(int, char *, int *, int, int);
 
 static const unsigned char padchar[] =
 "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
 
 int
-mkostempsat(int dfd, char *path, int slen, int oflags)
+compat_mkostemp(char *path, int oflags)
 {
 	int fd;
 
-	return (_gettemp(dfd, path, &fd, 0, slen, oflags) ? fd : -1);
+	return (_gettemp(AT_FDCWD, path, &fd, 0, oflags) ? fd : -1);
 }
 
 int
-mkostemps(char *path, int slen, int oflags)
+compat_mkstemp(char *path)
 {
 	int fd;
 
-	return (_gettemp(AT_FDCWD, path, &fd, 0, slen, oflags) ? fd : -1);
+	return (_gettemp(AT_FDCWD, path, &fd, 0, 0) ? fd : -1);
 }
 
-int
-mkstemps(char *path, int slen)
-{
-	int fd;
-
-	return (_gettemp(AT_FDCWD, path, &fd, 0, slen, 0) ? fd : -1);
-}
-
-int
-mkostemp(char *path, int oflags)
-{
-	int fd;
-
-	return (_gettemp(AT_FDCWD, path, &fd, 0, 0, oflags) ? fd : -1);
-}
-
-int
-mkstemp(char *path)
-{
-	int fd;
-
-	return (_gettemp(AT_FDCWD, path, &fd, 0, 0, 0) ? fd : -1);
-}
-
 char *
-mkdtemp(char *path)
+compat_mkdtemp(char *path)
 {
-	return (_gettemp(AT_FDCWD, path, (int *)NULL, 1, 0, 0) ? path : (char *)NULL);
+	return (_gettemp(AT_FDCWD, path, (int *)NULL, 1, 0) ? path : (char *)NULL);
 }
 
-char *
-_mktemp(char *path)
-{
-	return (_gettemp(AT_FDCWD, path, (int *)NULL, 0, 0, 0) ? path : (char *)NULL);
-}
-
-__warn_references(mktemp,
-    "warning: mktemp() possibly used unsafely; consider using mkstemp()");
-
-char *
-mktemp(char *path)
-{
-	return (_mktemp(path));
-}
-
 static int
-_gettemp(int dfd, char *path, int *doopen, int domkdir, int slen, int oflags)
+_gettemp(int dfd, char *path, int *doopen, int domkdir, int oflags)
 {
 	char *start, *trv, *suffp, *carryp;
 	char *pad;
 	struct stat sbuf;
-	uint32_t rand;
 	char carrybuf[MAXPATHLEN];
 	int saved;
 
-	if ((doopen != NULL && domkdir) || slen < 0 ||
-	    (oflags & ~(O_APPEND | O_DIRECT | O_SHLOCK | O_EXLOCK | O_SYNC |
-	    O_CLOEXEC)) != 0) {
+	if ((doopen != NULL && domkdir) ||
+	    (oflags & ~(O_APPEND | O_DIRECT | O_SYNC | O_CLOEXEC)) != 0) {
 		errno = EINVAL;
 		return (0);
 	}
@@ -134,26 +95,45 @@
 		errno = ENAMETOOLONG;
 		return (0);
 	}
-	trv -= slen;
 	suffp = trv;
 	--trv;
-	if (trv < path || NULL != strchr(suffp, '/')) {
+	if (trv < path) {
 		errno = EINVAL;
 		return (0);
 	}
 
 	/* Fill space with random characters */
-	while (trv >= path && *trv == 'X') {
-		rand = arc4random_uniform(sizeof(padchar) - 1);
-		*trv-- = padchar[rand];
-	}
-	start = trv + 1;
+	if (*trv == 'X') {
+		char *bx = trv;
+		while (bx > path && *(bx - 1) == 'X') --bx;
+		if ((suffp - bx) > 256) {
+			errno = EINVAL;
+			return (0);
+		}
+		if (getrandom(bx, suffp - bx, GRND_NONBLOCK) < 0) {
+			/* fall back to crappy randomness */
+			struct timespec ts;
+			uint64_t seed;
+			clock_gettime(CLOCK_REALTIME, &ts);
+			seed = ts.tv_sec + ts.tv_nsec + gettid() * 65537UL - 1;
+			for (char *buf = bx; buf < suffp; buf += sizeof(seed)) {
+				size_t left = (suffp - buf);
+				seed = 6364136223846793005ULL * seed + 1;
+				memcpy(buf, &seed, (left > sizeof(seed)) ? sizeof(seed) : left);
+			}
+		}
+		start = bx;
+		while (bx < suffp) {
+			*bx = padchar[*bx % sizeof(padchar)];
+			++bx;
+		}
+	} else start = trv + 1;
 
 	saved = 0;
 	oflags |= O_CREAT | O_EXCL | O_RDWR;
 	for (;;) {
 		if (doopen) {
-			*doopen = _openat(dfd, path, oflags, 0600);
+			*doopen = openat(dfd, path, oflags, 0600);
 			if (*doopen >= 0)
 				return (1);
 			if (errno != EEXIST)
@@ -177,7 +157,7 @@
 			/* have we tried all possible permutations? */
 			if (trv == suffp)
 				return (0); /* yes - exit with EEXIST */
-			pad = strchr(padchar, *trv);
+			pad = strchr((char *)padchar, *trv);
 			if (pad == NULL) {
 				/* this should never happen */
 				errno = EIO;
--- src.orig/compat/setmode.c
+++ src.freebsd/compat/setmode.c
@@ -34,10 +34,8 @@
 
 #include <sys/cdefs.h>
 __SCCSID("@(#)setmode.c	8.2 (Berkeley) 3/25/94");
-#include "namespace.h"
 #include <sys/types.h>
 #include <sys/stat.h>
-#include <sys/sysctl.h>
 
 #include <ctype.h>
 #include <errno.h>
@@ -50,8 +48,6 @@
 #ifdef SETMODE_DEBUG
 #include <stdio.h>
 #endif
-#include "un-namespace.h"
-#include "libc_private.h"
 
 #define	SET_LEN	6		/* initial # of bitcmd struct to malloc */
 #define	SET_LEN_INCR 4		/* # of bitcmd structs to add as needed */
@@ -152,11 +148,12 @@
 #define	ADDCMD(a, b, c, d)						\
 	if (set >= endset) {						\
 		BITCMD *newset;						\
+		ptrdiff_t setdiff = set - saveset; \
 		setlen += SET_LEN_INCR;					\
 		newset = reallocarray(saveset, setlen, sizeof(BITCMD));	\
 		if (newset == NULL)					\
 			goto out;					\
-		set = newset + (set - saveset);				\
+		set = newset + setdiff;				\
 		saveset = newset;					\
 		endset = newset + (setlen - 2);				\
 	}								\
@@ -344,9 +341,7 @@
 get_current_umask(void)
 {
 	sigset_t sigset, sigoset;
-	size_t len;
 	mode_t mask;
-	u_short smask;
 
 #ifdef KERN_PROC_UMASK
 	/*
@@ -364,9 +359,9 @@
 	 * handler, protect them as best we can.
 	 */
 	sigfillset(&sigset);
-	(void)__libc_sigprocmask(SIG_BLOCK, &sigset, &sigoset);
+	(void)sigprocmask(SIG_BLOCK, &sigset, &sigoset);
 	(void)umask(mask = umask(0));
-	(void)__libc_sigprocmask(SIG_SETMASK, &sigoset, NULL);
+	(void)sigprocmask(SIG_SETMASK, &sigoset, NULL);
 	return (mask);
 }
 
--- src.orig/compat/strftime.c
+++ src.freebsd/compat/strftime.c
@@ -30,24 +30,33 @@
 #endif /* !defined NOID */
 #endif /* !defined lint */
 
-#include "namespace.h"
-#include "private.h"
-
 #if defined(LIBC_SCCS) && !defined(lint)
 static const char	sccsid[] = "@(#)strftime.c	5.4 (Berkeley) 3/14/89";
 #endif /* LIBC_SCCS and not lint */
-#include "tzfile.h"
 #include <fcntl.h>
 #include <sys/stat.h>
 #include <stdio.h>
-#include "un-namespace.h"
-#include "timelocal.h"
+#include <time.h>
+#include <langinfo.h>
 
+#define DAYSPERWEEK 7
+#define MONSPERYEAR 12
+#define HOURSPERDAY 24
+#define SECSPERMIN 60
+#define MINSPERHOUR 60
+#define DAYSPERNYEAR 365
+#define DAYSPERLYEAR 366
+#define TM_YEAR_BASE 1900
+#define TM_GMTOFF tm_gmtoff
+#define TM_ZONE tm_zone
+
+#define isleap(y) (((y) % 4) == 0 && (((y) % 100) != 0 || ((y) % 400) == 0))
+#define isleap_sum(a, b) isleap((a) % 400 + (b) % 400)
+
 static char *	_add(const char *, char *, const char *);
-static char *	_conv(int, const char *, char *, const char *, locale_t);
-static char *	_fmt(const char *, const struct tm *, char *, const char *,
-			int *, locale_t);
-static char *	_yconv(int, int, int, int, char *, const char *, locale_t);
+static char *	_conv(int, const char *, char *, const char *);
+static char *	_fmt(const char *, const struct tm *, char *, const char *);
+static char *	_yconv(int, int, int, int, char *, const char *);
 
 extern char *	tzname[];
 
@@ -85,51 +94,23 @@
 };
 
 size_t
-strftime_l(char * __restrict s, size_t maxsize, const char * __restrict format,
-    const struct tm * __restrict t, locale_t loc)
+strftime_bsd(char * __restrict s, size_t maxsize, const char * __restrict format,
+    const struct tm * __restrict t)
 {
 	char *	p;
-	int	warn;
-	FIX_LOCALE(loc);
-
 	tzset();
-	warn = IN_NONE;
-	p = _fmt(((format == NULL) ? "%c" : format), t, s, s + maxsize, &warn, loc);
-#ifndef NO_RUN_TIME_WARNINGS_ABOUT_YEAR_2000_PROBLEMS_THANK_YOU
-	if (warn != IN_NONE && getenv(YEAR_2000_NAME) != NULL) {
-		(void) fprintf_l(stderr, loc, "\n");
-		if (format == NULL)
-			(void) fputs("NULL strftime format ", stderr);
-		else	(void) fprintf_l(stderr, loc, "strftime format \"%s\" ",
-				format);
-		(void) fputs("yields only two digits of years in ", stderr);
-		if (warn == IN_SOME)
-			(void) fputs("some locales", stderr);
-		else if (warn == IN_THIS)
-			(void) fputs("the current locale", stderr);
-		else	(void) fputs("all locales", stderr);
-		(void) fputs("\n", stderr);
-	}
-#endif /* !defined NO_RUN_TIME_WARNINGS_ABOUT_YEAR_2000_PROBLEMS_THANK_YOU */
+	p = _fmt(((format == NULL) ? "%c" : format), t, s, s + maxsize);
 	if (p == s + maxsize)
 		return (0);
 	*p = '\0';
 	return p - s;
 }
 
-size_t
-strftime(char * __restrict s, size_t maxsize, const char * __restrict format,
-    const struct tm * __restrict t)
-{
-	return strftime_l(s, maxsize, format, t, __get_locale());
-}
-
 static char *
 _fmt(const char *format, const struct tm * const t, char *pt,
-    const char * const ptlim, int *warnp, locale_t loc)
+    const char * const ptlim)
 {
 	int Ealternative, Oalternative, PadIndex;
-	struct lc_time_T *tptr = __get_current_time_locale(loc);
 
 	for ( ; *format; ++format) {
 		if (*format == '%') {
@@ -144,27 +125,26 @@
 			case 'A':
 				pt = _add((t->tm_wday < 0 ||
 					t->tm_wday >= DAYSPERWEEK) ?
-					"?" : tptr->weekday[t->tm_wday],
+					"?" : nl_langinfo(DAY_1 + t->tm_wday),
 					pt, ptlim);
 				continue;
 			case 'a':
 				pt = _add((t->tm_wday < 0 ||
 					t->tm_wday >= DAYSPERWEEK) ?
-					"?" : tptr->wday[t->tm_wday],
+					"?" : nl_langinfo(ABDAY_1 + t->tm_wday),
 					pt, ptlim);
 				continue;
 			case 'B':
 				pt = _add((t->tm_mon < 0 ||
 					t->tm_mon >= MONSPERYEAR) ?
-					"?" : (Oalternative ? tptr->alt_month :
-					tptr->month)[t->tm_mon],
+					"?" : nl_langinfo(MON_1 + t->tm_mon),
 					pt, ptlim);
 				continue;
 			case 'b':
 			case 'h':
 				pt = _add((t->tm_mon < 0 ||
 					t->tm_mon >= MONSPERYEAR) ?
-					"?" : tptr->mon[t->tm_mon],
+					"?" : nl_langinfo(ABMON_1 + t->tm_mon),
 					pt, ptlim);
 				continue;
 			case 'C':
@@ -176,26 +156,18 @@
 				 * (ado, 1993-05-24)
 				 */
 				pt = _yconv(t->tm_year, TM_YEAR_BASE, 1, 0,
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 			case 'c':
-				{
-				int warn2 = IN_SOME;
-
-				pt = _fmt(tptr->c_fmt, t, pt, ptlim, &warn2, loc);
-				if (warn2 == IN_ALL)
-					warn2 = IN_THIS;
-				if (warn2 > *warnp)
-					*warnp = warn2;
-				}
+				pt = _fmt(nl_langinfo(D_T_FMT), t, pt, ptlim);
 				continue;
 			case 'D':
-				pt = _fmt("%m/%d/%y", t, pt, ptlim, warnp, loc);
+				pt = _fmt("%m/%d/%y", t, pt, ptlim);
 				continue;
 			case 'd':
 				pt = _conv(t->tm_mday,
 					fmt_padding[PAD_FMT_DAYOFMONTH][PadIndex],
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 			case 'E':
 				if (Ealternative || Oalternative)
@@ -222,25 +194,25 @@
 			case 'e':
 				pt = _conv(t->tm_mday,
 					fmt_padding[PAD_FMT_SDAYOFMONTH][PadIndex],
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 			case 'F':
-				pt = _fmt("%Y-%m-%d", t, pt, ptlim, warnp, loc);
+				pt = _fmt("%Y-%m-%d", t, pt, ptlim);
 				continue;
 			case 'H':
 				pt = _conv(t->tm_hour, fmt_padding[PAD_FMT_HMS][PadIndex],
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 			case 'I':
 				pt = _conv((t->tm_hour % 12) ?
 					(t->tm_hour % 12) : 12,
 					fmt_padding[PAD_FMT_HMS][PadIndex],
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 			case 'j':
 				pt = _conv(t->tm_yday + 1,
 					fmt_padding[PAD_FMT_DAYOFYEAR][PadIndex],
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 			case 'k':
 				/*
@@ -254,7 +226,7 @@
 				 * (ado, 1993-05-24)
 				 */
 				pt = _conv(t->tm_hour, fmt_padding[PAD_FMT_SHMS][PadIndex],
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 #ifdef KITCHEN_SINK
 			case 'K':
@@ -277,55 +249,49 @@
 				pt = _conv((t->tm_hour % 12) ?
 					(t->tm_hour % 12) : 12,
 					fmt_padding[PAD_FMT_SHMS][PadIndex],
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 			case 'M':
 				pt = _conv(t->tm_min, fmt_padding[PAD_FMT_HMS][PadIndex],
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 			case 'm':
 				pt = _conv(t->tm_mon + 1,
 					fmt_padding[PAD_FMT_MONTH][PadIndex],
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 			case 'n':
 				pt = _add("\n", pt, ptlim);
 				continue;
 			case 'p':
-				pt = _add((t->tm_hour >= (HOURSPERDAY / 2)) ?
-					tptr->pm : tptr->am,
+				pt = _add(nl_langinfo((t->tm_hour >= (HOURSPERDAY / 2)) ?
+					PM_STR : AM_STR),
 					pt, ptlim);
 				continue;
 			case 'R':
-				pt = _fmt("%H:%M", t, pt, ptlim, warnp, loc);
+				pt = _fmt("%H:%M", t, pt, ptlim);
 				continue;
 			case 'r':
-				pt = _fmt(tptr->ampm_fmt, t, pt, ptlim,
-					warnp, loc);
+				pt = _fmt(nl_langinfo(T_FMT_AMPM), t, pt, ptlim);
 				continue;
 			case 'S':
 				pt = _conv(t->tm_sec, fmt_padding[PAD_FMT_HMS][PadIndex],
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 			case 's':
 				{
 					struct tm	tm;
-					char		buf[INT_STRLEN_MAXIMUM(
-								time_t) + 1];
+					char		buf[32];
 					time_t		mkt;
 
 					tm = *t;
-					mkt = timeoff(&tm, t->tm_gmtoff);
-					if (TYPE_SIGNED(time_t))
-						(void) sprintf_l(buf, loc, "%ld",
-							(long) mkt);
-					else	(void) sprintf_l(buf, loc, "%lu",
-							(unsigned long) mkt);
+					mkt = mktime(&tm);
+					(void) sprintf(buf, "%lld", (long long) mkt);
 					pt = _add(buf, pt, ptlim);
 				}
 				continue;
 			case 'T':
-				pt = _fmt("%H:%M:%S", t, pt, ptlim, warnp, loc);
+				pt = _fmt("%H:%M:%S", t, pt, ptlim);
 				continue;
 			case 't':
 				pt = _add("\t", pt, ptlim);
@@ -334,7 +300,7 @@
 				pt = _conv((t->tm_yday + DAYSPERWEEK -
 					t->tm_wday) / DAYSPERWEEK,
 					fmt_padding[PAD_FMT_WEEKOFYEAR][PadIndex],
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 			case 'u':
 				/*
@@ -345,7 +311,7 @@
 				 */
 				pt = _conv((t->tm_wday == 0) ?
 					DAYSPERWEEK : t->tm_wday,
-					"%d", pt, ptlim, loc);
+					"%d", pt, ptlim);
 				continue;
 			case 'V':	/* ISO 8601 week number */
 			case 'G':	/* ISO 8601 year (four digits) */
@@ -426,13 +392,12 @@
 #endif /* defined XPG4_1994_04_09 */
 					if (*format == 'V')
 						pt = _conv(w, fmt_padding[PAD_FMT_WEEKOFYEAR][PadIndex],
-							pt, ptlim, loc);
+							pt, ptlim);
 					else if (*format == 'g') {
-						*warnp = IN_ALL;
 						pt = _yconv(year, base, 0, 1,
-							pt, ptlim, loc);
+							pt, ptlim);
 					} else	pt = _yconv(year, base, 1, 1,
-							pt, ptlim, loc);
+							pt, ptlim);
 				}
 				continue;
 			case 'v':
@@ -441,7 +406,7 @@
 				 * "date as dd-bbb-YYYY"
 				 * (ado, 1993-05-24)
 				 */
-				pt = _fmt("%e-%b-%Y", t, pt, ptlim, warnp, loc);
+				pt = _fmt("%e-%b-%Y", t, pt, ptlim);
 				continue;
 			case 'W':
 				pt = _conv((t->tm_yday + DAYSPERWEEK -
@@ -449,33 +414,24 @@
 					(t->tm_wday - 1) :
 					(DAYSPERWEEK - 1))) / DAYSPERWEEK,
 					fmt_padding[PAD_FMT_WEEKOFYEAR][PadIndex],
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 			case 'w':
-				pt = _conv(t->tm_wday, "%d", pt, ptlim, loc);
+				pt = _conv(t->tm_wday, "%d", pt, ptlim);
 				continue;
 			case 'X':
-				pt = _fmt(tptr->X_fmt, t, pt, ptlim, warnp, loc);
+				pt = _fmt(nl_langinfo(T_FMT), t, pt, ptlim);
 				continue;
 			case 'x':
-				{
-				int	warn2 = IN_SOME;
-
-				pt = _fmt(tptr->x_fmt, t, pt, ptlim, &warn2, loc);
-				if (warn2 == IN_ALL)
-					warn2 = IN_THIS;
-				if (warn2 > *warnp)
-					*warnp = warn2;
-				}
+				pt = _fmt(nl_langinfo(D_FMT), t, pt, ptlim);
 				continue;
 			case 'y':
-				*warnp = IN_ALL;
 				pt = _yconv(t->tm_year, TM_YEAR_BASE, 0, 1,
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 			case 'Y':
 				pt = _yconv(t->tm_year, TM_YEAR_BASE, 1, 1,
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 			case 'Z':
 #ifdef TM_ZONE
@@ -545,12 +501,15 @@
 					(diff % MINSPERHOUR);
 				pt = _conv(diff,
 					fmt_padding[PAD_FMT_YEAR][PadIndex],
-					pt, ptlim, loc);
+					pt, ptlim);
 				}
 				continue;
 			case '+':
-				pt = _fmt(tptr->date_fmt, t, pt, ptlim,
-					warnp, loc);
+#ifdef _DATE_FMT
+				pt = _fmt(nl_langinfo(_DATE_FMT), t, pt, ptlim);
+#else
+				pt = _fmt("%a %b %e %H:%M:%S %Z %Y", t, pt, ptlim);
+#endif
 				continue;
 			case '-':
 				if (PadIndex != PAD_DEFAULT)
@@ -586,11 +545,11 @@
 
 static char *
 _conv(const int n, const char * const format, char * const pt,
-    const char * const ptlim, locale_t  loc)
+    const char * const ptlim)
 {
-	char	buf[INT_STRLEN_MAXIMUM(int) + 1];
+	char	buf[16];
 
-	(void) sprintf_l(buf, loc, format, n);
+	(void) sprintf(buf, format, n);
 	return _add(buf, pt, ptlim);
 }
 
@@ -612,7 +571,7 @@
 
 static char *
 _yconv(const int a, const int b, const int convert_top, const int convert_yy,
-    char *pt, const char * const ptlim, locale_t  loc)
+    char *pt, const char * const ptlim)
 {
 	register int	lead;
 	register int	trail;
@@ -631,10 +590,10 @@
 	if (convert_top) {
 		if (lead == 0 && trail < 0)
 			pt = _add("-0", pt, ptlim);
-		else	pt = _conv(lead, "%02d", pt, ptlim, loc);
+		else	pt = _conv(lead, "%02d", pt, ptlim);
 	}
 	if (convert_yy)
 		pt = _conv(((trail < 0) ? -trail : trail), "%02d", pt,
-		     ptlim, loc);
+		     ptlim);
 	return (pt);
 }
--- src.orig/compat/stringlist.c
+++ src.freebsd/compat/stringlist.c
@@ -28,13 +28,11 @@
 
 #include <sys/cdefs.h>
 __RCSID("$NetBSD: stringlist.c,v 1.2 1997/01/17 07:26:20 lukem Exp $");
-#include "namespace.h"
 #include <stdio.h>
 #include <string.h>
 #include <err.h>
 #include <stdlib.h>
 #include <stringlist.h>
-#include "un-namespace.h"
 
 #define _SL_CHUNKSIZE	20
 
@@ -48,13 +46,13 @@
 
 	sl = malloc(sizeof(StringList));
 	if (sl == NULL)
-		_err(1, "stringlist: %m");
+		err(1, "stringlist: %m");
 
 	sl->sl_cur = 0;
 	sl->sl_max = _SL_CHUNKSIZE;
 	sl->sl_str = malloc(sl->sl_max * sizeof(char *));
 	if (sl->sl_str == NULL)
-		_err(1, "stringlist: %m");
+		err(1, "stringlist: %m");
 	return sl;
 }
 
--- src.orig/compat/strptime.c
+++ src.freebsd/compat/strptime.c
@@ -45,21 +45,24 @@
 static char sccsid[] __unused = "@(#)strptime.c	0.1 (Powerdog) 94/03/27";
 #endif /* !defined NOID */
 #endif /* not lint */
-#include "namespace.h"
 #include <time.h>
 #include <ctype.h>
 #include <errno.h>
 #include <stdlib.h>
 #include <string.h>
 #include <pthread.h>
-#include "private.h"
-#include "un-namespace.h"
-#include "libc_private.h"
-#include "timelocal.h"
-#include "tzfile.h"
+#include <langinfo.h>
 
-static char * _strptime(const char *, const char *, struct tm *, int *, locale_t);
+#define DAYSPERWEEK 7
+#define MONSPERYEAR 12
+#define	TM_SUNDAY 0
+#define TM_MONDAY 1
+#define TM_YEAR_BASE 1900
 
+#define isleap(y) (((y) % 4) == 0 && (((y) % 100) != 0 || ((y) % 400) == 0))
+
+static char * _strptime(const char *, const char *, struct tm *, int *);
+
 #define	asizeof(a)	(sizeof(a) / sizeof((a)[0]))
 
 #define	FLAG_NONE	(1 << 0)
@@ -84,18 +87,16 @@
 }
 
 static char *
-_strptime(const char *buf, const char *fmt, struct tm *tm, int *GMTp,
-		locale_t locale)
+_strptime(const char *buf, const char *fmt, struct tm *tm, int *GMTp)
 {
 	char	c;
-	const char *ptr;
+	const char *ptr, *ex;
 	int	day_offset = -1, wday_offset;
 	int week_offset;
 	int	i, len;
 	int flags;
 	int Ealternative, Oalternative;
 	int century, year;
-	const struct lc_time_T *tptr = __get_current_time_locale(locale);
 	static int start_of_month[2][13] = {
 		{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},
 		{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}
@@ -110,9 +111,9 @@
 		c = *ptr++;
 
 		if (c != '%') {
-			if (isspace_l((unsigned char)c, locale))
+			if (isspace((unsigned char)c))
 				while (*buf != 0 && 
-				       isspace_l((unsigned char)*buf, locale))
+				       isspace((unsigned char)*buf))
 					buf++;
 			else if (c != *buf++)
 				return (NULL);
@@ -130,20 +131,24 @@
 			break;
 
 		case '+':
-			buf = _strptime(buf, tptr->date_fmt, tm, GMTp, locale);
+#ifdef _DATE_FMT
+			buf = _strptime(buf, nl_langinfo(_DATE_FMT), tm, GMTp);
+#else
+			buf = _strptime(buf, "%a %b %e %H:%M:%S %Z %Y", tm, GMTp);
+#endif
 			if (buf == NULL)
 				return (NULL);
 			flags |= FLAG_WDAY | FLAG_MONTH | FLAG_MDAY | FLAG_YEAR;
 			break;
 
 		case 'C':
-			if (!isdigit_l((unsigned char)*buf, locale))
+			if (!isdigit((unsigned char)*buf))
 				return (NULL);
 
 			/* XXX This will break for 3-digit centuries. */
 			len = 2;
 			for (i = 0; len && *buf != 0 &&
-			     isdigit_l((unsigned char)*buf, locale); buf++) {
+			     isdigit((unsigned char)*buf); buf++) {
 				i *= 10;
 				i += *buf - '0';
 				len--;
@@ -155,14 +160,14 @@
 			break;
 
 		case 'c':
-			buf = _strptime(buf, tptr->c_fmt, tm, GMTp, locale);
+			buf = _strptime(buf, nl_langinfo(D_T_FMT), tm, GMTp);
 			if (buf == NULL)
 				return (NULL);
 			flags |= FLAG_WDAY | FLAG_MONTH | FLAG_MDAY | FLAG_YEAR;
 			break;
 
 		case 'D':
-			buf = _strptime(buf, "%m/%d/%y", tm, GMTp, locale);
+			buf = _strptime(buf, "%m/%d/%y", tm, GMTp);
 			if (buf == NULL)
 				return (NULL);
 			flags |= FLAG_MONTH | FLAG_MDAY | FLAG_YEAR;
@@ -181,50 +186,50 @@
 			goto label;
 
 		case 'F':
-			buf = _strptime(buf, "%Y-%m-%d", tm, GMTp, locale);
+			buf = _strptime(buf, "%Y-%m-%d", tm, GMTp);
 			if (buf == NULL)
 				return (NULL);
 			flags |= FLAG_MONTH | FLAG_MDAY | FLAG_YEAR;
 			break;
 
 		case 'R':
-			buf = _strptime(buf, "%H:%M", tm, GMTp, locale);
+			buf = _strptime(buf, "%H:%M", tm, GMTp);
 			if (buf == NULL)
 				return (NULL);
 			break;
 
 		case 'r':
-			buf = _strptime(buf, tptr->ampm_fmt, tm, GMTp, locale);
+			buf = _strptime(buf, nl_langinfo(T_FMT_AMPM), tm, GMTp);
 			if (buf == NULL)
 				return (NULL);
 			break;
 
 		case 'T':
-			buf = _strptime(buf, "%H:%M:%S", tm, GMTp, locale);
+			buf = _strptime(buf, "%H:%M:%S", tm, GMTp);
 			if (buf == NULL)
 				return (NULL);
 			break;
 
 		case 'X':
-			buf = _strptime(buf, tptr->X_fmt, tm, GMTp, locale);
+			buf = _strptime(buf, nl_langinfo(T_FMT), tm, GMTp);
 			if (buf == NULL)
 				return (NULL);
 			break;
 
 		case 'x':
-			buf = _strptime(buf, tptr->x_fmt, tm, GMTp, locale);
+			buf = _strptime(buf, nl_langinfo(D_FMT), tm, GMTp);
 			if (buf == NULL)
 				return (NULL);
 			flags |= FLAG_MONTH | FLAG_MDAY | FLAG_YEAR;
 			break;
 
 		case 'j':
-			if (!isdigit_l((unsigned char)*buf, locale))
+			if (!isdigit((unsigned char)*buf))
 				return (NULL);
 
 			len = 3;
 			for (i = 0; len && *buf != 0 &&
-			     isdigit_l((unsigned char)*buf, locale); buf++){
+			     isdigit((unsigned char)*buf); buf++){
 				i *= 10;
 				i += *buf - '0';
 				len--;
@@ -240,15 +245,15 @@
 		case 'M':
 		case 'S':
 			if (*buf == 0 ||
-				isspace_l((unsigned char)*buf, locale))
+				isspace((unsigned char)*buf))
 				break;
 
-			if (!isdigit_l((unsigned char)*buf, locale))
+			if (!isdigit((unsigned char)*buf))
 				return (NULL);
 
 			len = 2;
 			for (i = 0; len && *buf != 0 &&
-				isdigit_l((unsigned char)*buf, locale); buf++){
+				isdigit((unsigned char)*buf); buf++){
 				i *= 10;
 				i += *buf - '0';
 				len--;
@@ -281,16 +286,16 @@
 
 			len = 2;
 			if ((c == 'k' || c == 'l') &&
-			    isblank_l((unsigned char)*buf, locale)) {
+			    isblank((unsigned char)*buf)) {
 				buf++;
 				len = 1;
 			}
 
-			if (!isdigit_l((unsigned char)*buf, locale))
+			if (!isdigit((unsigned char)*buf))
 				return (NULL);
 
 			for (i = 0; len && *buf != 0 &&
-			     isdigit_l((unsigned char)*buf, locale); buf++) {
+			     isdigit((unsigned char)*buf); buf++) {
 				i *= 10;
 				i += *buf - '0';
 				len--;
@@ -313,16 +318,18 @@
 			if (tm->tm_hour > 12)
 				return (NULL);
 
-			len = strlen(tptr->am);
-			if (strncasecmp_l(buf, tptr->am, len, locale) == 0) {
+			ex = nl_langinfo(AM_STR);
+			len = strlen(ex);
+			if (strncasecmp(buf, ex, len) == 0) {
 				if (tm->tm_hour == 12)
 					tm->tm_hour = 0;
 				buf += len;
 				break;
 			}
 
-			len = strlen(tptr->pm);
-			if (strncasecmp_l(buf, tptr->pm, len, locale) == 0) {
+			ex = nl_langinfo(PM_STR);
+			len = strlen(ex);
+			if (strncasecmp(buf, ex, len) == 0) {
 				if (tm->tm_hour != 12)
 					tm->tm_hour += 12;
 				buf += len;
@@ -333,17 +340,17 @@
 
 		case 'A':
 		case 'a':
-			for (i = 0; i < asizeof(tptr->weekday); i++) {
-				len = strlen(tptr->weekday[i]);
-				if (strncasecmp_l(buf, tptr->weekday[i],
-						len, locale) == 0)
+			for (i = 0; i < DAYSPERWEEK; i++) {
+				ex = nl_langinfo(DAY_1 + i);
+				len = strlen(ex);
+				if (strncasecmp(buf, ex, len) == 0)
 					break;
-				len = strlen(tptr->wday[i]);
-				if (strncasecmp_l(buf, tptr->wday[i],
-						len, locale) == 0)
+				ex = nl_langinfo(ABDAY_1 + i);
+				len = strlen(ex);
+				if (strncasecmp(buf, ex, len) == 0)
 					break;
 			}
-			if (i == asizeof(tptr->weekday))
+			if (i == DAYSPERWEEK)
 				return (NULL);
 
 			buf += len;
@@ -359,12 +366,12 @@
 			 * point to calculate a real value, so just check the
 			 * range for now.
 			 */
-			if (!isdigit_l((unsigned char)*buf, locale))
+			if (!isdigit((unsigned char)*buf))
 				return (NULL);
 
 			len = 2;
 			for (i = 0; len && *buf != 0 &&
-			     isdigit_l((unsigned char)*buf, locale); buf++) {
+			     isdigit((unsigned char)*buf); buf++) {
 				i *= 10;
 				i += *buf - '0';
 				len--;
@@ -384,7 +391,7 @@
 
 		case 'u':
 		case 'w':
-			if (!isdigit_l((unsigned char)*buf, locale))
+			if (!isdigit((unsigned char)*buf))
 				return (NULL);
 
 			i = *buf++ - '0';
@@ -403,7 +410,7 @@
 			 * before single digits.
 			 */
 			if (*buf != 0 &&
-			    isspace_l((unsigned char)*buf, locale))
+			    isspace((unsigned char)*buf))
 			       buf++;
 			/* FALLTHROUGH */
 		case 'd':
@@ -416,12 +423,12 @@
 			 * XXX The %e specifier may gobble one too many
 			 * digits if used incorrectly.
 			 */
-			if (!isdigit_l((unsigned char)*buf, locale))
+			if (!isdigit((unsigned char)*buf))
 				return (NULL);
 
 			len = 2;
 			for (i = 0; len && *buf != 0 &&
-			     isdigit_l((unsigned char)*buf, locale); buf++) {
+			     isdigit((unsigned char)*buf); buf++) {
 				i *= 10;
 				i += *buf - '0';
 				len--;
@@ -437,19 +444,18 @@
 		case 'B':
 		case 'b':
 		case 'h':
-			for (i = 0; i < asizeof(tptr->month); i++) {
+			for (i = 0; i < MONSPERYEAR; i++) {
 				if (Oalternative) {
 					if (c == 'B') {
-						len = strlen(tptr->alt_month[i]);
-						if (strncasecmp_l(buf,
-								tptr->alt_month[i],
-								len, locale) == 0)
+						ex = nl_langinfo(MON_1 + i);
+						len = strlen(ex);
+						if (strncasecmp(buf, ex, len) == 0)
 							break;
 					}
 				} else {
-					len = strlen(tptr->month[i]);
-					if (strncasecmp_l(buf, tptr->month[i],
-							len, locale) == 0)
+					ex = nl_langinfo(MON_1 + i);
+					len = strlen(ex);
+					if (strncasecmp(buf, ex, len) == 0)
 						break;
 				}
 			}
@@ -457,15 +463,15 @@
 			 * Try the abbreviated month name if the full name
 			 * wasn't found and Oalternative was not requested.
 			 */
-			if (i == asizeof(tptr->month) && !Oalternative) {
-				for (i = 0; i < asizeof(tptr->month); i++) {
-					len = strlen(tptr->mon[i]);
-					if (strncasecmp_l(buf, tptr->mon[i],
-							len, locale) == 0)
+			if (i == MONSPERYEAR && !Oalternative) {
+				for (i = 0; i < MONSPERYEAR; i++) {
+					ex = nl_langinfo(ABMON_1 + i);
+					len = strlen(ex);
+					if (strncasecmp(buf, ex, len) == 0)
 						break;
 				}
 			}
-			if (i == asizeof(tptr->month))
+			if (i == MONSPERYEAR)
 				return (NULL);
 
 			tm->tm_mon = i;
@@ -475,12 +481,12 @@
 			break;
 
 		case 'm':
-			if (!isdigit_l((unsigned char)*buf, locale))
+			if (!isdigit((unsigned char)*buf))
 				return (NULL);
 
 			len = 2;
 			for (i = 0; len && *buf != 0 &&
-			     isdigit_l((unsigned char)*buf, locale); buf++) {
+			     isdigit((unsigned char)*buf); buf++) {
 				i *= 10;
 				i += *buf - '0';
 				len--;
@@ -502,7 +508,7 @@
 
 			sverrno = errno;
 			errno = 0;
-			n = strtol_l(buf, &cp, 10, locale);
+			n = strtol(buf, &cp, 10);
 			if (errno == ERANGE || (long)(t = n) != n) {
 				errno = sverrno;
 				return (NULL);
@@ -520,15 +526,15 @@
 		case 'Y':
 		case 'y':
 			if (*buf == 0 ||
-			    isspace_l((unsigned char)*buf, locale))
+			    isspace((unsigned char)*buf))
 				break;
 
-			if (!isdigit_l((unsigned char)*buf, locale))
+			if (!isdigit((unsigned char)*buf))
 				return (NULL);
 
 			len = (c == 'Y') ? 4 : 2;
 			for (i = 0; len && *buf != 0 &&
-			     isdigit_l((unsigned char)*buf, locale); buf++) {
+			     isdigit((unsigned char)*buf); buf++) {
 				i *= 10;
 				i += *buf - '0';
 				len--;
@@ -547,7 +553,7 @@
 			char *zonestr;
 
 			for (cp = buf; *cp &&
-			     isupper_l((unsigned char)*cp, locale); ++cp) {
+			     isupper((unsigned char)*cp); ++cp) {
 				/*empty*/}
 			if (cp - buf) {
 				zonestr = alloca(cp - buf + 1);
@@ -583,7 +589,7 @@
 			buf++;
 			i = 0;
 			for (len = 4; len > 0; len--) {
-				if (isdigit_l((unsigned char)*buf, locale)) {
+				if (isdigit((unsigned char)*buf)) {
 					i *= 10;
 					i += *buf - '0';
 					buf++;
@@ -605,7 +611,7 @@
 
 		case 'n':
 		case 't':
-			while (isspace_l((unsigned char)*buf, locale))
+			while (isspace((unsigned char)*buf))
 				buf++;
 			break;
 
@@ -697,15 +703,14 @@
 }
 
 char *
-strptime_l(const char * __restrict buf, const char * __restrict fmt,
-    struct tm * __restrict tm, locale_t loc)
+strptime_bsd(const char * __restrict buf, const char * __restrict fmt,
+    struct tm * __restrict tm)
 {
 	char *ret;
 	int gmt;
-	FIX_LOCALE(loc);
 
 	gmt = 0;
-	ret = _strptime(buf, fmt, tm, &gmt, loc);
+	ret = _strptime(buf, fmt, tm, &gmt);
 	if (ret && gmt) {
 		time_t t = timegm(tm);
 
@@ -713,11 +718,4 @@
 	}
 
 	return (ret);
-}
-
-char *
-strptime(const char * __restrict buf, const char * __restrict fmt,
-    struct tm * __restrict tm)
-{
-	return strptime_l(buf, fmt, tm, __get_locale());
 }
--- src.orig/compat/unvis.c
+++ src.freebsd/compat/unvis.c
@@ -38,7 +38,6 @@
 #endif
 #endif /* LIBC_SCCS and not lint */
 
-#include "namespace.h"
 #include <sys/types.h>
 
 #include <assert.h>
--- src.orig/compat/vis.c
+++ src.freebsd/compat/vis.c
@@ -60,7 +60,6 @@
 __RCSID("$NetBSD: vis.c,v 1.83 2023/08/12 12:48:52 riastradh Exp $");
 #endif /* LIBC_SCCS and not lint */
 
-#include "namespace.h"
 #include <sys/types.h>
 #include <sys/param.h>
 
@@ -69,8 +68,10 @@
 #include <errno.h>
 #include <stdint.h>
 #include <stdlib.h>
+#include <stdint.h>
 #include <wchar.h>
 #include <wctype.h>
+#include <limits.h>
 
 #ifdef __weak_alias
 __weak_alias(strvisx,_strvisx)
@@ -78,7 +79,6 @@
 
 #if !HAVE_VIS || !HAVE_SVIS
 #include <ctype.h>
-#include <limits.h>
 #include <stdio.h>
 #include <string.h>
 
--- src.orig/compress/compress.c
+++ src.freebsd/compress/compress.c
@@ -43,6 +43,7 @@
 
 #include <sys/cdefs.h>
 #include <sys/param.h>
+#include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/time.h>
 
@@ -236,6 +237,7 @@
 
 	if (fclose(ofp)) {
 		cwarn("%s", out);
+		ofp = NULL;
 		goto err;
 	}
 	ofp = NULL;
@@ -339,6 +341,7 @@
 	ifp = NULL;
 
 	if (fclose(ofp)) {
+		ofp = NULL;
 		cwarn("%s", out);
 		goto err;
 	}
@@ -385,9 +388,6 @@
 	}
 	if (chmod(name, fs->st_mode) && errno != EOPNOTSUPP)
 		cwarn("chmod: %s", name);
-
-	if (chflags(name, fs->st_flags) && errno != EOPNOTSUPP)
-		cwarn("chflags: %s", name);
 }
 
 static int
--- src.orig/compress/zopen.c
+++ src.freebsd/compress/zopen.c
@@ -61,6 +61,7 @@
  */
 
 #include <sys/param.h>
+#include <sys/types.h>
 #include <sys/stat.h>
 
 #include <ctype.h>
@@ -72,6 +73,10 @@
 #include <unistd.h>
 #include "zopen.h"
 
+#ifndef EFTYPE
+#define EFTYPE EINVAL
+#endif
+
 #define	BITS		16		/* Default bits. */
 #define	HSIZE		69001		/* 95% occupancy */
 
@@ -202,8 +207,8 @@
 static code_int	getcode(struct s_zstate *);
 static int	output(struct s_zstate *, code_int);
 static int	zclose(void *);
-static int	zread(void *, char *, int);
-static int	zwrite(void *, const char *, int);
+static ssize_t	zread(void *, char *, size_t);
+static ssize_t	zwrite(void *, const char *, size_t);
 
 /*-
  * Algorithm from "A Technique for High Performance Data Compression",
@@ -231,8 +236,8 @@
  * file size for noticeable speed improvement on small files.  Please direct
  * questions about this implementation to ames!jaw.
  */
-static int
-zwrite(void *cookie, const char *wbp, int num)
+static ssize_t
+zwrite(void *cookie, const char *wbp, size_t num)
 {
 	code_int i;
 	int c, disp;
@@ -452,8 +457,8 @@
  * compressed file.  The tables used herein are shared with those of the
  * compress() routine.  See the definitions above.
  */
-static int
-zread(void *cookie, char *rbp, int num)
+static ssize_t
+zread(void *cookie, char *rbp, size_t num)
 {
 	u_int count;
 	struct s_zstate *zs;
@@ -694,6 +699,7 @@
 zopen(const char *fname, const char *mode, int bits)
 {
 	struct s_zstate *zs;
+	cookie_io_functions_t zfuncs;
 
 	if ((mode[0] != 'r' && mode[0] != 'w') || mode[1] != '\0' ||
 	    bits < 0 || bits > BITS) {
@@ -729,10 +735,18 @@
 	switch (*mode) {
 	case 'r':
 		zmode = 'r';
-		return (funopen(zs, zread, NULL, NULL, zclose));
+		zfuncs.read = zread;
+		zfuncs.write = NULL;
+		zfuncs.seek = NULL;
+		zfuncs.close = zclose;
+		return fopencookie(zs, "r", zfuncs);
 	case 'w':
 		zmode = 'w';
-		return (funopen(zs, NULL, zwrite, NULL, zclose));
+		zfuncs.read = NULL;
+		zfuncs.write = zwrite;
+		zfuncs.seek = NULL;
+		zfuncs.close = zclose;
+		return fopencookie(zs, "w", zfuncs);
 	}
 	/* NOTREACHED */
 	return (NULL);
--- src.orig/coreutils/cat/cat.c
+++ src.freebsd/coreutils/cat/cat.c
@@ -68,6 +68,10 @@
 #include <wchar.h>
 #include <wctype.h>
 
+#ifndef BOOTSTRAP_CAT
+#include <sys/sendfile.h>
+#endif
+
 #include <libcasper.h>
 #include <casper/cap_fileargs.h>
 #include <casper/cap_net.h>
@@ -100,6 +104,9 @@
 /* Maximum buffer size in bytes - do not allow it to grow larger than this. */
 #define	BUFSIZE_MAX (2 * 1024 * 1024)
 
+/* Maximum length to send when using sendfile */
+#define SPLICEBUF_MAX (16 * 1024)
+
 /*
  * Small (default) buffer size in bytes. It's inefficient for this to be
  * smaller than MAXPHYS.
@@ -282,7 +289,8 @@
 #ifndef BOOTSTRAP_CAT
 			if (in_kernel_copy(fd) != 0) {
 				if (errno == EINVAL || errno == EBADF ||
-				    errno == EISDIR)
+				    errno == EISDIR || errno == EXDEV ||
+				    errno == ESPIPE || errno == ENOSYS)
 					raw_cat(fd);
 				else
 					err(1, "stdout");
@@ -304,7 +312,7 @@
 cook_cat(FILE *fp)
 {
 	int ch, gobble, line, prev;
-	wint_t wch;
+	wchar_t wch;
 
 	/* Reset EOF condition on stdin. */
 	if (fp == stdin && feof(stdin))
@@ -342,24 +350,32 @@
 					break;
 				continue;
 			}
-		} else if (vflag) {
-			(void)ungetc(ch, fp);
-			/*
-			 * Our getwc(3) doesn't change file position
-			 * on error.
-			 */
-			if ((wch = getwc(fp)) == WEOF) {
-				if (ferror(fp) && errno == EILSEQ) {
-					clearerr(fp);
-					/* Resync attempt. */
-					memset(&fp->_mbstate, 0, sizeof(mbstate_t));
-					if ((ch = getc(fp)) == EOF)
-						break;
+		} else if (vflag && !isprint(ch)) {
+			mbstate_t st = {0};
+			unsigned char b;
+			size_t l;
+			b = ch;
+			l = mbrtowc(&wch, (void *)&b, 1, &st);
+			if (l == (size_t)-1) {
+				wch = ch;
+				goto ilseq;
+			}
+			while (l == (size_t)-2) {
+				int nch = getc(fp);
+				if (nch == EOF) {
 					wch = ch;
 					goto ilseq;
-				} else
-					break;
+				}
+				b = nch;
+				l = mbrtowc(&wch, (void *)&b, 1, &st);
+				if (l == (size_t)-1) {
+					/* go back by the failed char */
+					ungetc(nch, fp);
+					wch = ch;
+					goto ilseq;
+				}
 			}
+			/* wch should be a valid multibyte char now */
 			if (!iswascii(wch) && !iswprint(wch)) {
 ilseq:
 				if (putchar('M') == EOF || putchar('-') == EOF)
@@ -391,6 +407,18 @@
 }
 
 static ssize_t
+spliced_copy(int rfd, int wfd)
+{
+	ssize_t ret = 1;
+	off_t off = 0;
+
+	while (ret > 0)
+		ret = sendfile(wfd, rfd, &off, SPLICEBUF_MAX);
+
+	return (ret);
+}
+
+static ssize_t
 in_kernel_copy(int rfd)
 {
 	int wfd;
@@ -401,6 +429,9 @@
 
 	while (ret > 0)
 		ret = copy_file_range(rfd, NULL, wfd, NULL, SSIZE_MAX, 0);
+
+	if (ret < 0)
+		ret = spliced_copy(rfd, wfd);
 
 	return (ret);
 }
--- src.orig/coreutils/chmod/chmod.1
+++ src.freebsd/coreutils/chmod/chmod.1
@@ -39,8 +39,8 @@
 .Nd change file modes
 .Sh SYNOPSIS
 .Nm
-.Op Fl fhv
-.Op Fl R Op Fl H | L | P
+.Op Fl fv
+.Op Fl R Op Fl L | P
 .Ar mode
 .Ar
 .Sh DESCRIPTION
@@ -59,15 +59,6 @@
 could not modify the mode for
 .Va file ,
 nor modify the exit status to reflect such failures.
-.It Fl H
-If the
-.Fl R
-option is specified, symbolic links on the command line are followed
-and hence unaffected by the command.
-(Symbolic links encountered during tree traversal are not followed.)
-.It Fl h
-If the file is a symbolic link, change the mode of the link itself
-rather than the file that the link points to.
 .It Fl L
 If the
 .Fl R
@@ -95,7 +86,6 @@
 .El
 .Pp
 The
-.Fl H ,
 .Fl L
 and
 .Fl P
@@ -104,11 +94,13 @@
 option is specified.
 In addition, these options override each other and the
 command's actions are determined by the last one specified.
+Symbolic links specified on the command line are always
+followed, regardless of the option.
 .Pp
 If
 .Nm
 receives a
-.Dv SIGINFO
+.Dv SIGUSR1
 signal (see the
 .Cm status
 argument for
@@ -332,7 +324,6 @@
 .Sh SEE ALSO
 .Xr chflags 1 ,
 .Xr install 1 ,
-.Xr setfacl 1 ,
 .Xr chmod 2 ,
 .Xr stat 2 ,
 .Xr umask 2 ,
--- src.orig/coreutils/chmod/chmod.c
+++ src.freebsd/coreutils/chmod/chmod.c
@@ -80,7 +80,7 @@
 
 	set = NULL;
 	Hflag = Lflag = Rflag = fflag = hflag = vflag = 0;
-	while ((ch = getopt(argc, argv, "HLPRXfghorstuvwx")) != -1)
+	while ((ch = getopt(argc, argv, "LPRXfgorstuvwx")) != -1)
 		switch (ch) {
 		case 'H':
 			Hflag = 1;
@@ -144,7 +144,7 @@
 		if (Lflag) {
 			fts_options = FTS_LOGICAL;
 		} else {
-			fts_options = FTS_PHYSICAL;
+			fts_options = FTS_PHYSICAL | FTS_COMFOLLOW;
 
 			if (Hflag) {
 				fts_options |= FTS_COMFOLLOW;
@@ -200,16 +200,24 @@
 		if (may_have_nfs4acl(p, hflag) == 0 &&
 		    (newmode & ALLPERMS) == (p->fts_statp->st_mode & ALLPERMS))
 				continue;
+		/* on linux we need to skip symlinks */
+		errno = 0;
 		if (fchmodat(AT_FDCWD, p->fts_accpath, newmode, atflag) == -1
-		    && !fflag) {
+		    && !fflag && (errno != ENOTSUP)) {
 			warn("%s", p->fts_path);
 			rval = 1;
 		} else if (vflag || siginfo) {
+			int olderr = errno;
+
 			(void)printf("%s", p->fts_path);
 
 			if (vflag > 1 || siginfo) {
 				char m1[12], m2[12];
 
+				/* do not give misleading information for linux symlinks */
+				if (olderr == ENOTSUP)
+					newmode = p->fts_statp->st_mode;
+
 				strmode(p->fts_statp->st_mode, m1);
 				strmode((p->fts_statp->st_mode &
 				    S_IFMT) | newmode, m2);
@@ -238,6 +246,7 @@
 static int
 may_have_nfs4acl(const FTSENT *ent, int hflag)
 {
+#ifndef __linux__
 	int ret;
 	static dev_t previous_dev = NODEV;
 	static int supports_acls = -1;
@@ -257,4 +266,10 @@
 	}
 
 	return (supports_acls);
+#else
+	/* Linux does not support NFSv4 ACLs */
+	(void)ent;
+	(void)hflag;
+	return 0;
+#endif
 }
--- src.orig/coreutils/chown/chgrp.1
+++ src.freebsd/coreutils/chown/chgrp.1
@@ -123,7 +123,7 @@
 If
 .Nm
 receives a
-.Dv SIGINFO
+.Dv SIGUSR1
 signal (see the
 .Cm status
 argument for
--- src.orig/coreutils/chown/chown.8
+++ src.freebsd/coreutils/chown/chown.8
@@ -138,7 +138,7 @@
 If
 .Nm
 receives a
-.Dv SIGINFO
+.Dv SIGUSR1
 signal (see the
 .Cm status
 argument for
--- src.orig/coreutils/chroot/chroot.8
+++ src.freebsd/coreutils/chroot/chroot.8
@@ -63,14 +63,10 @@
 .Ar user .
 .It Fl n
 Use the
-.Dv PROC_NO_NEW_PRIVS_CTL
-.Xr procctl 2
-command before chrooting, effectively disabling SUID/SGID bits
-for the calling process and its descendants.
-If
-.Dv security.bsd.unprivileged_chroot
-sysctl is set to 1, it will make it possible to chroot without
-superuser privileges.
+.Dv CLONE_NEWUSER
+.Xr unshare 2
+parameter before chrooting, effectively unsharing the user namespace.
+This makes it possible to chroot without superuser privileges.
 .El
 .Sh ENVIRONMENT
 The following environment variable is referenced by
--- src.orig/coreutils/chroot/chroot.c
+++ src.freebsd/coreutils/chroot/chroot.c
@@ -42,7 +42,6 @@
 #endif
 #include <sys/cdefs.h>
 #include <sys/types.h>
-#include <sys/procctl.h>
 
 #include <ctype.h>
 #include <err.h>
@@ -55,6 +54,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <sched.h>
 
 static void usage(void) __dead2;
 
@@ -67,7 +67,7 @@
 	const char	*shell;
 	gid_t		gid, *gidlist;
 	uid_t		uid;
-	int		arg, ch, error, gids;
+	int		ch, error, gids;
 	long		ngroups_max;
 	bool		nonprivileged;
 
@@ -159,10 +159,9 @@
 	}
 
 	if (nonprivileged) {
-		arg = PROC_NO_NEW_PRIVS_ENABLE;
-		error = procctl(P_PID, getpid(), PROC_NO_NEW_PRIVS_CTL, &arg);
+		error = unshare(CLONE_NEWUSER);
 		if (error != 0)
-			err(1, "procctl");
+			err(1, "unshare");
 	}
 
 	if (chdir(argv[0]) == -1 || chroot(".") == -1)
--- src.orig/coreutils/cp/cp.1
+++ src.freebsd/coreutils/cp/cp.1
@@ -44,7 +44,7 @@
 .Op Fl H | Fl L | Fl P
 .Oc
 .Op Fl f | i | n
-.Op Fl alNpsvx
+.Op Fl alpsvxT
 .Ar source_file target_file
 .Nm
 .Oo
@@ -52,16 +52,30 @@
 .Op Fl H | Fl L | Fl P
 .Oc
 .Op Fl f | i | n
-.Op Fl alNpsvx
+.Op Fl alpsvx
 .Ar source_file ... target_directory
 .Nm
+.Oo
+.Fl R
+.Op Fl H | Fl L | Fl P
+.Oc
 .Op Fl f | i | n
-.Op Fl alNPpsvx
+.Op Fl alpsvx
+.Fl t Ar target_directory
+.Ar source_file ...
+.Nm
+.Op Fl f | i | n
+.Op Fl alPpsvxT
 .Ar source_file target_file
 .Nm
 .Op Fl f | i | n
-.Op Fl alNPpsvx
+.Op Fl alPpsvx
 .Ar source_file ... target_directory
+.Nm
+.Op Fl f | i | n
+.Op Fl alPpsvx
+.Fl t Ar target_directory
+.Ar source_file ...
 .Sh DESCRIPTION
 In the first synopsis form, the
 .Nm
@@ -123,10 +137,15 @@
 or
 .Xr pax 1
 instead.
+.It Fl T
+In modes where the target may be a file, error if the target is a directory
+instead of copying into the directory. May not be used with
+.Fl t .
 .It Fl a
 Archive mode.
-Same as
-.Fl RpP .
+Similar to
+.Fl RpP
+but additionally tries to preserve xattrs (but ignores any failure to do so).
 .It Fl f
 For each existing destination pathname, remove it and
 create a new file, without prompting for confirmation
@@ -157,10 +176,6 @@
 options.)
 .It Fl l
 Create hard links to regular files in a hierarchy instead of copying.
-.It Fl N
-When used with
-.Fl p ,
-suppress copying file flags.
 .It Fl n
 Do not overwrite an existing file.
 (The
@@ -175,7 +190,8 @@
 .Nm
 to preserve the following attributes of each source
 file in the copy: modification time, access time,
-file flags, file mode, ACL, user ID, and group ID, as allowed by permissions.
+file mode, ACL, user ID, and group ID, as allowed by permissions.
+Extended attributes are not preserved, except in archive mode.
 .Pp
 If the user ID and group ID cannot be preserved, no error message
 is displayed and the exit value is not altered.
@@ -192,6 +208,9 @@
 permissions.
 .It Fl s
 Create symbolic links to regular files in a hierarchy instead of copying.
+.It Fl t Ar target_directory
+Specify the target directory as an optional argument. In this mode, it
+must be a directory, and all the positional arguments are copied into it.
 .It Fl v
 Cause
 .Nm
@@ -255,7 +274,7 @@
 If
 .Nm
 receives a
-.Dv SIGINFO
+.Dv SIGUSR1
 (see the
 .Cm status
 argument for
--- src.orig/coreutils/cp/cp.c
+++ src.freebsd/coreutils/cp/cp.c
@@ -84,8 +84,8 @@
 
 PATH_T to = { to.p_path, emptystring, "" };
 
-int Nflag, fflag, iflag, lflag, nflag, pflag, sflag, vflag;
-static int Hflag, Lflag, Pflag, Rflag, rflag;
+int fflag, iflag, lflag, nflag, pflag, sflag, vflag, aflag;
+static int Hflag, Lflag, Pflag, Rflag, rflag, Tflag;
 volatile sig_atomic_t info;
 
 enum op { FILE_TO_FILE, FILE_TO_DIR, DIR_TO_DNE };
@@ -99,10 +99,10 @@
 	struct stat to_stat, tmp_stat;
 	enum op type;
 	int ch, fts_options, r, have_trailing_slash;
-	char *target;
+	char *target, *targdir = NULL;
 
 	fts_options = FTS_NOCHDIR | FTS_PHYSICAL;
-	while ((ch = getopt(argc, argv, "HLPRafilNnprsvx")) != -1)
+	while ((ch = getopt(argc, argv, "HLPRTafilnprst:vx")) != -1)
 		switch (ch) {
 		case 'H':
 			Hflag = 1;
@@ -120,6 +120,7 @@
 			Rflag = 1;
 			break;
 		case 'a':
+			aflag = 1;
 			pflag = 1;
 			Rflag = 1;
 			Pflag = 1;
@@ -136,9 +137,6 @@
 		case 'l':
 			lflag = 1;
 			break;
-		case 'N':
-			Nflag = 1;
-			break;
 		case 'n':
 			nflag = 1;
 			fflag = iflag = 0;
@@ -153,6 +151,12 @@
 		case 's':
 			sflag = 1;
 			break;
+		case 't':
+			targdir = optarg;
+			break;
+		case 'T':
+			Tflag = 1;
+			break;
 		case 'v':
 			vflag = 1;
 			break;
@@ -166,9 +170,11 @@
 	argc -= optind;
 	argv += optind;
 
-	if (argc < 2)
+	if (argc < (!targdir + 1))
 		usage();
 
+	if (Tflag && targdir)
+		errx(1, "the -T and -t options may not be specified together");
 	if (Rflag && rflag)
 		errx(1, "the -R and -r options may not be specified together");
 	if (lflag && sflag)
@@ -189,7 +195,7 @@
 	(void)signal(SIGINFO, siginfo);
 
 	/* Save the target base in "to". */
-	target = argv[--argc];
+	target = targdir ? targdir : argv[--argc];
 	if (strlcpy(to.p_path, target, sizeof(to.p_path)) >= sizeof(to.p_path))
 		errx(1, "%s: name too long", target);
 	to.p_end = to.p_path + strlen(to.p_path);
@@ -226,8 +232,10 @@
 		/*
 		 * Case (1).  Target is not a directory.
 		 */
-		if (argc > 1)
+		if (argc > 1 || targdir) {
+			if (Tflag) errx(1, "extra operand '%s'", to.p_path);
 			errx(1, "%s is not a directory", to.p_path);
+		}
 
 		/*
 		 * Need to detect the case:
@@ -256,11 +264,16 @@
 			} else
 				errx(1, "%s is not a directory", to.p_path);
 		}
-	} else
+	} else {
 		/*
 		 * Case (2).  Target is a directory.
 		 */
+		if (Tflag) {
+			if (argc > 1) errx(1, "extra operand '%s'", to.p_path);
+			errx(1, "cannot overwrite directory '%s' with non-directory", to.p_path);
+		}
 		type = FILE_TO_DIR;
+	}
 
 	/*
 	 * For DIR_TO_DNE, we could provide copy() with the to_stat we've
@@ -451,6 +464,7 @@
 				if (preserve_dir_acls(curr->fts_statp,
 				    curr->fts_accpath, to.p_path) != 0)
 					rval = 1;
+				if (aflag) preserve_dir_xattrs(curr->fts_accpath, to.p_path);
 			} else {
 				mode = curr->fts_statp->st_mode;
 				if ((mode & (S_ISUID | S_ISGID | S_ISTXT)) ||
--- src.orig/coreutils/cp/extern.h
+++ src.freebsd/coreutils/cp/extern.h
@@ -38,7 +38,7 @@
 } PATH_T;
 
 extern PATH_T to;
-extern int Nflag, fflag, iflag, lflag, nflag, pflag, sflag, vflag;
+extern int fflag, iflag, lflag, nflag, pflag, sflag, vflag, aflag;
 extern volatile sig_atomic_t info;
 
 __BEGIN_DECLS
@@ -49,5 +49,7 @@
 int	setfile(struct stat *, int);
 int	preserve_dir_acls(struct stat *, char *, char *);
 int	preserve_fd_acls(int, int);
+int	preserve_fd_xattrs(int, int);
+int	preserve_dir_xattrs(const char *, const char *);
 void	usage(void) __dead2;
 __END_DECLS
--- src.orig/coreutils/cp/utils.c
+++ src.freebsd/coreutils/cp/utils.c
@@ -38,6 +38,8 @@
 #include <sys/param.h>
 #include <sys/acl.h>
 #include <sys/stat.h>
+#include <sys/xattr.h>
+#include <acl/libacl.h>
 
 #include <err.h>
 #include <errno.h>
@@ -46,6 +48,8 @@
 #include <limits.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
+#include <signal.h>
 #include <sysexits.h>
 #include <unistd.h>
 
@@ -205,9 +209,14 @@
 		if (use_copy_file_range) {
 			wcount = copy_file_range(from_fd, NULL,
 			    to_fd, NULL, SSIZE_MAX, 0);
-			if (wcount < 0 && errno == EINVAL) {
-				/* probably a non-seekable descriptor */
+			if (wcount < 0) switch (errno) {
+			case EINVAL: /* Prob a non-seekable FD */
+			case EXDEV: /* Cross-FS link */
+			case ENOSYS: /* Syscall not supported */
 				use_copy_file_range = 0;
+				break;
+			default:
+				break;
 			}
 		}
 		if (!use_copy_file_range) {
@@ -237,6 +246,7 @@
 		rval = 1;
 	if (pflag && preserve_fd_acls(from_fd, to_fd) != 0)
 		rval = 1;
+	if (aflag) preserve_fd_xattrs(from_fd, to_fd);
 	if (close(to_fd)) {
 		warn("%s", to.p_path);
 		rval = 1;
@@ -362,12 +372,13 @@
 
 	if (!gotstat || fs->st_mode != ts.st_mode)
 		if (fdval ? fchmod(fd, fs->st_mode) :
-		    (islink ? lchmod(to.p_path, fs->st_mode) :
+		    (islink ? 0 :
 		    chmod(to.p_path, fs->st_mode))) {
 			warn("chmod: %s", to.p_path);
 			rval = 1;
 		}
 
+#if 0
 	if (!Nflag && (!gotstat || fs->st_flags != ts.st_flags))
 		if (fdval ?
 		    fchflags(fd, fs->st_flags) :
@@ -385,6 +396,7 @@
 				rval = 1;
 			}
 		}
+#endif
 
 	return (rval);
 }
@@ -393,9 +405,9 @@
 preserve_fd_acls(int source_fd, int dest_fd)
 {
 	acl_t acl;
-	acl_type_t acl_type;
-	int acl_supported = 0, ret, trivial;
+	int acl_supported = 0, ret;
 
+#if 0
 	ret = fpathconf(source_fd, _PC_ACL_NFS4);
 	if (ret > 0 ) {
 		acl_supported = 1;
@@ -404,13 +416,13 @@
 		warn("fpathconf(..., _PC_ACL_NFS4) failed for %s", to.p_path);
 		return (1);
 	}
+#endif
 	if (acl_supported == 0) {
-		ret = fpathconf(source_fd, _PC_ACL_EXTENDED);
+		ret = acl_extended_fd(source_fd);
 		if (ret > 0 ) {
 			acl_supported = 1;
-			acl_type = ACL_TYPE_ACCESS;
-		} else if (ret < 0 && errno != EINVAL) {
-			warn("fpathconf(..., _PC_ACL_EXTENDED) failed for %s",
+		} else if (ret < 0 && errno != ENOTSUP) {
+			warn("acl_extended_fd() failed for %s",
 			    to.p_path);
 			return (1);
 		}
@@ -418,21 +430,12 @@
 	if (acl_supported == 0)
 		return (0);
 
-	acl = acl_get_fd_np(source_fd, acl_type);
+	acl = acl_get_fd(source_fd);
 	if (acl == NULL) {
 		warn("failed to get acl entries while setting %s", to.p_path);
 		return (1);
 	}
-	if (acl_is_trivial_np(acl, &trivial)) {
-		warn("acl_is_trivial() failed for %s", to.p_path);
-		acl_free(acl);
-		return (1);
-	}
-	if (trivial) {
-		acl_free(acl);
-		return (0);
-	}
-	if (acl_set_fd_np(dest_fd, acl, acl_type) < 0) {
+	if (acl_set_fd(dest_fd, acl) < 0) {
 		warn("failed to set acl entries for %s", to.p_path);
 		acl_free(acl);
 		return (1);
@@ -446,11 +449,11 @@
 {
 	acl_t (*aclgetf)(const char *, acl_type_t);
 	int (*aclsetf)(const char *, acl_type_t, acl_t);
-	struct acl *aclp;
 	acl_t acl;
 	acl_type_t acl_type;
-	int acl_supported = 0, ret, trivial;
+	int acl_supported = 0, ret;
 
+#if 0
 	ret = pathconf(source_dir, _PC_ACL_NFS4);
 	if (ret > 0) {
 		acl_supported = 1;
@@ -459,13 +462,14 @@
 		warn("fpathconf(..., _PC_ACL_NFS4) failed for %s", source_dir);
 		return (1);
 	}
-	if (acl_supported == 0) {
-		ret = pathconf(source_dir, _PC_ACL_EXTENDED);
+#endif
+	if (!S_ISLNK(fs->st_mode) && acl_supported == 0) {
+		ret = acl_extended_file(source_dir);
 		if (ret > 0) {
 			acl_supported = 1;
 			acl_type = ACL_TYPE_ACCESS;
-		} else if (ret < 0 && errno != EINVAL) {
-			warn("fpathconf(..., _PC_ACL_EXTENDED) failed for %s",
+		} else if (ret < 0 && errno != ENOTSUP) {
+			warn("acl_extended_file() failed for %s",
 			    source_dir);
 			return (1);
 		}
@@ -473,30 +477,22 @@
 	if (acl_supported == 0)
 		return (0);
 
-	/*
-	 * If the file is a link we will not follow it.
-	 */
-	if (S_ISLNK(fs->st_mode)) {
-		aclgetf = acl_get_link_np;
-		aclsetf = acl_set_link_np;
-	} else {
-		aclgetf = acl_get_file;
-		aclsetf = acl_set_file;
-	}
+	aclgetf = acl_get_file;
+	aclsetf = acl_set_file;
+
 	if (acl_type == ACL_TYPE_ACCESS) {
 		/*
 		 * Even if there is no ACL_TYPE_DEFAULT entry here, a zero
 		 * size ACL will be returned. So it is not safe to simply
 		 * check the pointer to see if the default ACL is present.
 		 */
-		acl = aclgetf(source_dir, ACL_TYPE_DEFAULT);
+		acl = acl_get_file(source_dir, ACL_TYPE_DEFAULT);
 		if (acl == NULL) {
 			warn("failed to get default acl entries on %s",
 			    source_dir);
 			return (1);
 		}
-		aclp = &acl->ats_acl;
-		if (aclp->acl_cnt != 0 && aclsetf(dest_dir,
+		if (acl_entries(acl) > 0 && aclsetf(dest_dir,
 		    ACL_TYPE_DEFAULT, acl) < 0) {
 			warn("failed to set default acl entries on %s",
 			    dest_dir);
@@ -510,15 +506,6 @@
 		warn("failed to get acl entries on %s", source_dir);
 		return (1);
 	}
-	if (acl_is_trivial_np(acl, &trivial)) {
-		warn("acl_is_trivial() failed on %s", source_dir);
-		acl_free(acl);
-		return (1);
-	}
-	if (trivial) {
-		acl_free(acl);
-		return (0);
-	}
 	if (aclsetf(dest_dir, acl_type, acl) < 0) {
 		warn("failed to set acl entries on %s", dest_dir);
 		acl_free(acl);
@@ -528,15 +515,150 @@
 	return (0);
 }
 
+/* for now we don't really care about warnings or result,
+ * we only support the quiet case for archive mode
+ */
+int
+preserve_fd_xattrs(int source_fd, int dest_fd)
+{
+    ssize_t size;
+    char buf[256], vbuf[128];
+    char *names, *name, *nend;
+    char *value = vbuf;
+    int retval = 0, rerrno = 0;
+    size_t vbufs = sizeof(vbuf);
+
+    size = flistxattr(source_fd, NULL, 0);
+    if (size < 0) {
+        return 1;
+    }
+
+    if (size < (ssize_t)sizeof(buf)) {
+        names = buf;
+    } else {
+        names = malloc(size + 1);
+        if (!names) err(1, "Not enough memory");
+    }
+
+    size = flistxattr(source_fd, names, size);
+    if (size < 0) {
+        if (names != buf) free(names);
+        return 1;
+    }
+    names[size] = '\0';
+    nend = names + size;
+
+    for (name = names; name != nend; name = strchr(name, '\0') + 1) {
+        size = fgetxattr(source_fd, name, NULL, 0);
+        if (size < 0) {
+            retval = 1;
+            rerrno = errno;
+            continue;
+        }
+        if (size > (ssize_t)vbufs) {
+            if (value == vbuf) value = NULL;
+            value = realloc(value, size);
+            if (!value) {
+                err(1, "Not enough memory");
+            }
+            vbufs = size;
+        }
+        size = fgetxattr(source_fd, name, value, size);
+        if (size < 0) {
+            retval = 1;
+            rerrno = errno;
+            continue;
+        }
+        if (fsetxattr(dest_fd, name, value, size, 0)) {
+            retval = 1;
+            rerrno = errno;
+        }
+    }
+
+    if (names != buf) free(names);
+    if (value != vbuf) free(value);
+    if (retval) {
+        errno = rerrno;
+    }
+    return retval;
+}
+
+int
+preserve_dir_xattrs(const char *source_dir, const char *dest_dir) {
+    ssize_t size;
+    char buf[256], vbuf[128];
+    char *names, *name, *nend;
+    char *value = vbuf;
+    int retval = 0, rerrno = 0;
+    size_t vbufs = sizeof(vbuf);
+
+    size = llistxattr(source_dir, NULL, 0);
+    if (size < 0) {
+        return 1;
+    }
+
+    if (size < (ssize_t)sizeof(buf)) {
+        names = buf;
+    } else {
+        names = malloc(size + 1);
+        if (!names) err(1, "Not enough memory");
+    }
+
+    size = llistxattr(source_dir, names, size);
+    if (size < 0) {
+        if (names != buf) free(names);
+        return 1;
+    }
+    names[size] = '\0';
+    nend = names + size;
+
+    for (name = names; name != nend; name = strchr(name, '\0') + 1) {
+        size = lgetxattr(source_dir, name, NULL, 0);
+        if (size < 0) {
+            retval = 1;
+            rerrno = errno;
+            continue;
+        }
+        if (size > (ssize_t)vbufs) {
+            if (value == vbuf) value = NULL;
+            value = realloc(value, size);
+            if (!value) {
+                err(1, "Not enough memory");
+            }
+            vbufs = size;
+        }
+        size = lgetxattr(source_dir, name, value, size);
+        if (size < 0) {
+            retval = 1;
+            rerrno = errno;
+            continue;
+        }
+        if (lsetxattr(dest_dir, name, value, size, 0)) {
+            retval = 1;
+            rerrno = errno;
+        }
+    }
+
+    if (names != buf) free(names);
+    if (value != vbuf) free(value);
+    if (retval) {
+        errno = rerrno;
+    }
+    return retval;
+}
+
 void
 usage(void)
 {
 
-	(void)fprintf(stderr, "%s\n%s\n",
-	    "usage: cp [-R [-H | -L | -P]] [-f | -i | -n] [-alpsvx] "
+	(void)fprintf(stderr, "%s\n%s\n%s\n",
+	    "usage: cp [-R [-H | -L | -P]] [-f | -i | -n] [-alpsvxT] "
 	    "source_file target_file",
 	    "       cp [-R [-H | -L | -P]] [-f | -i | -n] [-alpsvx] "
 	    "source_file ... "
-	    "target_directory");
+	    "target_directory",
+	    "       cp [-R [-H | -L | -P]] [-f | -i | -n] [-alpsvx] "
+	    "-t target_directory "
+	    "source_file ... ");
 	exit(EX_USAGE);
 }
--- src.orig/coreutils/cut/cut.c
+++ src.freebsd/coreutils/cut/cut.c
@@ -275,14 +275,15 @@
 static int
 b_n_cut(FILE *fp, const char *fname)
 {
-	size_t col, i, lbuflen;
-	char *lbuf;
+	size_t col, i, bufsize = 0;
+	ssize_t lbuflen;
+	char *lbuf = NULL;
 	int canwrite, clen, warned;
 	mbstate_t mbs;
 
 	memset(&mbs, 0, sizeof(mbs));
 	warned = 0;
-	while ((lbuf = fgetln(fp, &lbuflen)) != NULL) {
+	while ((lbuflen = getline(&lbuf, &bufsize, fp)) >= 0) {
 		for (col = 0; lbuflen > 0; col += clen) {
 			if ((clen = mbrlen(lbuf, lbuflen, &mbs)) < 0) {
 				if (!warned) {
@@ -331,6 +332,7 @@
 		if (lbuflen > 0)
 			putchar('\n');
 	}
+	free(lbuf);
 	return (warned);
 }
 
@@ -389,21 +391,22 @@
 	int field, i, isdelim;
 	char *pos, *p;
 	int output;
-	char *lbuf, *mlbuf;
-	size_t clen, lbuflen, reallen;
+	char *lbuf = NULL;
+	size_t clen, bufsize = 0, reallen;
+	ssize_t lbuflen;
 
-	mlbuf = NULL;
-	while ((lbuf = fgetln(fp, &lbuflen)) != NULL) {
+	while ((lbuflen = getline(&lbuf, &bufsize, fp)) >= 0) {
 		reallen = lbuflen;
 		/* Assert EOL has a newline. */
-		if (*(lbuf + lbuflen - 1) != '\n') {
+		if (lbuflen > 0 && *(lbuf + lbuflen - 1) != '\n') {
 			/* Can't have > 1 line with no trailing newline. */
-			mlbuf = malloc(lbuflen + 1);
-			if (mlbuf == NULL)
-				err(1, "malloc");
-			memcpy(mlbuf, lbuf, lbuflen);
-			*(mlbuf + lbuflen) = '\n';
-			lbuf = mlbuf;
+			if ((ssize_t)bufsize < (lbuflen + 1)) {
+				bufsize = lbuflen + 1;
+				lbuf = realloc(lbuf, bufsize);
+			}
+			if (lbuf == NULL)
+				err(1, "realloc");
+			lbuf[lbuflen] = '\n';
 			reallen++;
 		}
 		output = 0;
@@ -411,7 +414,7 @@
 			clen = mbrtowc(&ch, p, lbuf + reallen - p, NULL);
 			if (clen == (size_t)-1 || clen == (size_t)-2) {
 				warnc(EILSEQ, "%s", fname);
-				free(mlbuf);
+				free(lbuf);
 				return (1);
 			}
 			if (clen == 0)
@@ -438,7 +441,7 @@
 				    NULL);
 				if (clen == (size_t)-1 || clen == (size_t)-2) {
 					warnc(EILSEQ, "%s", fname);
-					free(mlbuf);
+					free(lbuf);
 					return (1);
 				}
 				if (clen == 0)
@@ -470,7 +473,7 @@
 		}
 		(void)putchar('\n');
 	}
-	free(mlbuf);
+	free(lbuf);
 	return (0);
 }
 
--- src.orig/coreutils/date/date.1
+++ src.freebsd/coreutils/date/date.1
@@ -126,7 +126,7 @@
 .Oc Ar MM Op Cm \&. Ar SS
 .Sm on
 format.
-Parsing is done using
+Parsing is done using FreeBSD
 .Xr strptime 3 .
 .It Fl I Ns Op Ar FMT
 Use
@@ -327,7 +327,7 @@
 The format string may contain any of the conversion specifications
 described in the
 .Xr strftime 3
-manual page and
+FreeBSD manual page and
 .Ql %N
 for nanoseconds, as well as any arbitrary text.
 A newline
--- src.orig/coreutils/date/date.c
+++ src.freebsd/coreutils/date/date.c
@@ -57,6 +57,8 @@
 #include <syslog.h>
 #include <unistd.h>
 #include <utmpx.h>
+#include <time_bsd.h>
+#include <langinfo.h>
 
 #include "vary.h"
 
@@ -264,6 +266,7 @@
 	struct utmpx utx;
 	struct tm *lt;
 	const char *dot, *t;
+	struct timeval tv;
 	int century;
 
 	lt = localtime(&ts->tv_sec);
@@ -272,7 +275,7 @@
 	lt->tm_isdst = -1;		/* divine correct DST */
 
 	if (fmt != NULL) {
-		t = strptime(p, fmt, lt);
+		t = strptime_bsd(p, fmt, lt);
 		if (t == NULL) {
 			fprintf(stderr, "Failed conversion of ``%s''"
 				" using format ``%s''\n", p, fmt);
@@ -356,12 +359,16 @@
 	if (!jflag) {
 		utx.ut_type = OLD_TIME;
 		memset(utx.ut_id, 0, sizeof(utx.ut_id));
-		(void)gettimeofday(&utx.ut_tv, NULL);
+		(void)gettimeofday(&tv, NULL);
+		utx.ut_tv.tv_sec = tv.tv_sec;
+		utx.ut_tv.tv_usec = tv.tv_usec;
 		pututxline(&utx);
 		if (clock_settime(CLOCK_REALTIME, ts) != 0)
 			err(1, "clock_settime");
 		utx.ut_type = NEW_TIME;
-		(void)gettimeofday(&utx.ut_tv, NULL);
+		(void)gettimeofday(&tv, NULL);
+		utx.ut_tv.tv_sec = tv.tv_sec;
+		utx.ut_tv.tv_usec = tv.tv_usec;
 		pututxline(&utx);
 
 		if ((p = getlogin()) == NULL)
@@ -441,7 +448,7 @@
 		}
 	}
 
-	ret = strftime(s, maxsize, newformat, t);
+	ret = strftime_bsd(s, maxsize, newformat, t);
 	free(newformat);
 	return (ret);
 }
--- src.orig/coreutils/dd/dd.1
+++ src.freebsd/coreutils/dd/dd.1
@@ -416,7 +416,7 @@
 If
 .Nm
 receives a
-.Dv SIGINFO
+.Dv SIGUSR1
 (see the
 .Cm status
 argument for
--- src.orig/coreutils/dd/dd.c
+++ src.freebsd/coreutils/dd/dd.c
@@ -48,9 +48,6 @@
 #include <sys/param.h>
 #include <sys/stat.h>
 #include <sys/capsicum.h>
-#include <sys/conf.h>
-#include <sys/disklabel.h>
-#include <sys/filio.h>
 #include <sys/mtio.h>
 #include <sys/time.h>
 
@@ -146,7 +143,7 @@
 	u_int cnt;
 	int iflags, oflags;
 	cap_rights_t rights;
-	unsigned long cmds[] = { FIODTYPE, MTIOCTOP };
+	unsigned long cmds[] = { 0 };
 
 	if (in.name == NULL) {
 		in.name = "stdin";
@@ -182,7 +179,7 @@
 			oflags = fcntl(out.fd, F_GETFL);
 			if (oflags == -1)
 				err(1, "unable to get fd flags for stdout");
-			oflags |= O_FSYNC;
+			oflags |= O_SYNC;
 			if (fcntl(out.fd, F_SETFL, oflags) == -1)
 				err(1, "unable to set fd flags for stdout");
 		}
@@ -191,7 +188,7 @@
 		if (!(ddflags & (C_SEEK | C_NOTRUNC)))
 			oflags |= O_TRUNC;
 		if (ddflags & C_OFSYNC)
-			oflags |= O_FSYNC;
+			oflags |= O_SYNC;
 		if (ddflags & C_ODIRECT)
 			oflags |= O_DIRECT;
 		before_io();
@@ -323,23 +320,16 @@
 getfdtype(IO *io)
 {
 	struct stat sb;
-	int type;
 
 	if (fstat(io->fd, &sb) == -1)
 		err(1, "%s", io->name);
 	if (S_ISREG(sb.st_mode))
 		io->flags |= ISTRUNC;
-	if (S_ISCHR(sb.st_mode) || S_ISBLK(sb.st_mode)) { 
-		if (ioctl(io->fd, FIODTYPE, &type) == -1) {
-			err(1, "%s", io->name);
-		} else {
-			if (type & D_TAPE)
-				io->flags |= ISTAPE;
-			else if (type & (D_DISK | D_MEM))
-				io->flags |= ISSEEK;
-			if (S_ISCHR(sb.st_mode) && (type & D_TAPE) == 0)
-				io->flags |= ISCHR;
-		}
+	if (S_ISCHR(sb.st_mode) || S_ISBLK(sb.st_mode)) {
+		if (S_ISCHR(sb.st_mode))
+			io->flags |= ISCHR;
+		if (S_ISBLK(sb.st_mode))
+			io->flags |= ISSEEK;
 		return;
 	}
 	errno = 0;
--- src.orig/coreutils/dd/dd.h
+++ src.freebsd/coreutils/dd/dd.h
@@ -35,6 +35,8 @@
  *	@(#)dd.h	8.3 (Berkeley) 4/2/94
  */
 
+#include <sys/types.h>
+
 /* Input/output stream state. */
 typedef struct {
 	u_char		*db;		/* buffer address */
--- src.orig/coreutils/dd/extern.h
+++ src.freebsd/coreutils/dd/extern.h
@@ -35,6 +35,8 @@
  *	@(#)extern.h	8.3 (Berkeley) 4/2/94
  */
 
+#include <signal.h>
+
 void block(void);
 void block_close(void);
 void dd_out(int);
--- src.orig/coreutils/dd/position.c
+++ src.freebsd/coreutils/dd/position.c
@@ -70,9 +70,9 @@
 	 *
 	 * Bail out if the calculation of a file offset would overflow.
 	 */
-	if ((io->flags & ISCHR) == 0 && (n < 0 || n > OFF_MAX / (ssize_t)sz))
+	if ((io->flags & ISCHR) == 0 && (n < 0 || n > LONG_MAX / (ssize_t)sz))
 		errx(1, "seek offsets cannot be larger than %jd",
-		    (intmax_t)OFF_MAX);
+		    (intmax_t)LONG_MAX);
 	else if ((io->flags & ISCHR) != 0 && (uint64_t)n > UINT64_MAX / sz)
 		errx(1, "seek offsets cannot be larger than %ju",
 		    (uintmax_t)UINT64_MAX);
--- src.orig/coreutils/df/df.1
+++ src.freebsd/coreutils/df/df.1
@@ -38,7 +38,7 @@
 .Nm
 .Op Fl -libxo
 .Op Fl b | g | H | h | k | m | P
-.Op Fl acilnT
+.Op Fl acilT
 .Op Fl \&,
 .Op Fl t Ar type
 .Op Ar file | filesystem ...
@@ -129,15 +129,6 @@
 This overrides any
 .Ev BLOCKSIZE
 specification from the environment.
-.It Fl n
-Print out the previously obtained statistics from the file systems.
-This option should be used if it is possible that one or more
-file systems are in a state such that they will not be able to provide
-statistics without a long delay.
-When this option is specified,
-.Nm
-will not request new statistics from the file systems, but will respond
-with the possibly stale statistics that were previously obtained.
 .It Fl P
 Explicitly use 512 byte blocks, overriding any
 .Ev BLOCKSIZE
@@ -221,7 +212,7 @@
 .Fl t
 option can be specified only once:
 .Bd -literal -offset indent
-$ df -i -n -t nodevfs,linsysfs
+$ df -i -t nodevfs,linsysfs
 Filesystem   1K-blocks      Used      Avail Capacity iused     ifree %iused
 Mounted on
 /dev/ada1p2  223235736 159618992   45757888    78% 1657590  27234568    6%   /
@@ -289,13 +280,6 @@
 command appeared in
 .At v1 .
 .Sh BUGS
-The
-.Fl n
-flag is ignored if a file or file system is specified.
-Also, if a mount
-point is not accessible by the user, it is possible that the file system
-information could be stale.
-.Pp
 The
 .Fl b
 and
--- src.orig/coreutils/df/df.c
+++ src.freebsd/coreutils/df/df.c
@@ -48,8 +48,8 @@
 #include <sys/cdefs.h>
 #include <sys/param.h>
 #include <sys/stat.h>
+#include <sys/statvfs.h>
 #include <sys/mount.h>
-#include <sys/sysctl.h>
 #include <getopt.h>
 #include <libutil.h>
 #include <locale.h>
@@ -60,10 +60,38 @@
 #include <sysexits.h>
 #include <unistd.h>
 #include <libxo/xo.h>
+#include <assert.h>
+#include <mntent.h>
 
 #define UNITS_SI	1
 #define UNITS_2		2
 
+/*
+ * Static list of network filesystems
+ *
+ * This replaces the makenetvfslist() function from FreeBSD, but this
+ * list should be made in to something we can generate at runtime or
+ * just expand the list.
+ */
+static char NETVFSLIST[] = "nonfs,nfs4,smb,cifs";
+
+/* combining data from getmntent() and statvfs() on Linux */
+struct mntinfo {
+    char *f_mntfromname;          /* mnt_fsname from getmntent */
+    char *f_mntonname;            /* mnt_dir from getmntent */
+    char *f_fstypename;           /* mnt_fsname from getmntent */
+    char *f_opts;                 /* mnt_opts from getmntent */
+    unsigned long f_bsize;        /* f_bsize from statvfs */
+    fsblkcnt_t f_blocks;          /* f_blocks from statvfs */
+    fsblkcnt_t f_bfree;           /* f_bfree from statvfs */
+    fsblkcnt_t f_bavail;          /* f_bavail from statvfs */
+    fsfilcnt_t f_files;           /* f_files from statvfs */
+    fsfilcnt_t f_ffree;           /* f_ffree from statvfs */
+    unsigned long f_flag;         /* f_flag from statvfs */
+    dev_t f_dev;                  /* st_dev from stat */
+    unsigned int f_selected;      /* used internally here only */
+};
+
 /* Maximum widths of various fields. */
 struct maxwidths {
 	int	mntfrom;
@@ -75,20 +103,20 @@
 	int	ifree;
 };
 
-static void	  addstat(struct statfs *, struct statfs *);
-static char	 *getmntpt(const char *);
+static void	  addstat(struct mntinfo *, struct mntinfo *);
+static char	 *getmntpt(struct mntinfo **, const size_t, const char *);
 static const char **makevfslist(char *fslist, int *skip);
 static int	  checkvfsname(const char *vfsname, const char **vfslist, int skip);
 static int	  checkvfsselected(char *);
 static int	  int64width(int64_t);
-static char	 *makenetvfslist(void);
-static void	  prthuman(const struct statfs *, int64_t);
+static void	  prthuman(const struct mntinfo *, int64_t);
 static void	  prthumanval(const char *, int64_t);
 static intmax_t	  fsbtoblk(int64_t, uint64_t, u_long);
-static void	  prtstat(struct statfs *, struct maxwidths *);
-static size_t	  regetmntinfo(struct statfs **, long);
-static void	  update_maxwidths(struct maxwidths *, const struct statfs *);
+static void	  prtstat(struct mntinfo *, struct maxwidths *);
+static void	  update_maxwidths(struct maxwidths *, const struct mntinfo *);
 static void	  usage(void);
+static int	  getmntinfo(struct mntinfo **);
+static void	  freemntinfo(struct mntinfo *, int);
 
 static __inline int
 imax(int a, int b)
@@ -96,7 +124,7 @@
 	return (a > b ? a : b);
 }
 
-static int	  aflag = 0, cflag, hflag, iflag, kflag, lflag = 0, nflag, Tflag;
+static int	  aflag = 0, cflag, hflag, iflag, kflag, lflag = 0, Tflag;
 static int	  thousands;
 static int	  skipvfs_l, skipvfs_t;
 static const char **vfslist_l, **vfslist_t;
@@ -111,9 +139,9 @@
 main(int argc, char *argv[])
 {
 	struct stat stbuf;
-	struct statfs statfsbuf, totalbuf;
+	struct mntinfo *mntbuf = NULL;
+	struct mntinfo totalbuf;
 	struct maxwidths maxwidths;
-	struct statfs *mntbuf;
 	char *mntpt;
 	int i, mntsize;
 	int ch, rv;
@@ -122,13 +150,12 @@
 	memset(&maxwidths, 0, sizeof(maxwidths));
 	memset(&totalbuf, 0, sizeof(totalbuf));
 	totalbuf.f_bsize = DEV_BSIZE;
-	strlcpy(totalbuf.f_mntfromname, "total", MNAMELEN);
 
 	argc = xo_parse_args(argc, argv);
 	if (argc < 0)
 		exit(1);
 
-	while ((ch = getopt_long(argc, argv, "+abcgHhiklmnPt:T,", long_options,
+	while ((ch = getopt_long(argc, argv, "+abcgHhiklmPt:T,", long_options,
 	    NULL)) != -1)
 		switch (ch) {
 		case 'a':
@@ -173,7 +200,7 @@
 			/* Ignore duplicate -l */
 			if (lflag)
 				break;
-			vfslist_l = makevfslist(makenetvfslist(), &skipvfs_l);
+			vfslist_l = makevfslist(NETVFSLIST, &skipvfs_l);
 			lflag = 1;
 			break;
 		case 'm':
@@ -181,7 +208,6 @@
 			hflag = 0;
 			break;
 		case 'n':
-			nflag = 1;
 			break;
 		case 't':
 			if (vfslist_t != NULL)
@@ -202,32 +228,28 @@
 	argv += optind;
 
 	rv = EXIT_SUCCESS;
-	if (!*argv) {
-		/* everything (modulo -t) */
-		mntsize = getmntinfo(&mntbuf, MNT_NOWAIT);
-		mntsize = regetmntinfo(&mntbuf, mntsize);
-	} else {
-		/* just the filesystems specified on the command line */
-		mntbuf = malloc(argc * sizeof(*mntbuf));
-		if (mntbuf == NULL)
-			xo_err(1, "malloc()");
-		mntsize = 0;
-		/* continued in for loop below */
-	}
+	mntsize = getmntinfo(&mntbuf);
 
 	xo_open_container("storage-system-information");
 	xo_open_list("filesystem");
 
+	/* unselect all filesystems if an explicit list is given */
+	if (*argv) {
+		for (i = 0; i < mntsize; i++) {
+			mntbuf[i].f_selected = 0;
+		}
+	}
+
 	/* iterate through specified filesystems */
 	for (; *argv; argv++) {
 		if (stat(*argv, &stbuf) < 0) {
-			if ((mntpt = getmntpt(*argv)) == NULL) {
+			if ((mntpt = getmntpt(&mntbuf, mntsize, *argv)) == NULL) {
 				xo_warn("%s", *argv);
 				rv = EXIT_FAILURE;
 				continue;
 			}
 		} else if (S_ISCHR(stbuf.st_mode)) {
-			mntpt = getmntpt(*argv);
+			mntpt = getmntpt(&mntbuf, mntsize, *argv);
 			if (mntpt == NULL) {
 				xo_warnx("%s: not mounted", *argv);
 				rv = EXIT_FAILURE;
@@ -237,44 +259,25 @@
 			mntpt = *argv;
 		}
 
-		/*
-		 * Statfs does not take a `wait' flag, so we cannot
-		 * implement nflag here.
-		 */
-		if (statfs(mntpt, &statfsbuf) < 0) {
-			xo_warn("%s", mntpt);
-			rv = EXIT_FAILURE;
-			continue;
+		for (i = 0; i < mntsize; i++) {
+			/* selected specified filesystems if the mount point or device matches */
+			if (((stbuf.st_dev == mntbuf[i].f_dev) || !strcmp(mntbuf[i].f_mntfromname, mntpt) || !strcmp(mntbuf[i].f_mntonname, mntpt)) && checkvfsselected(mntbuf[i].f_fstypename) == 0) {
+				mntbuf[i].f_selected = 1;
+				break;
+			}
 		}
-
-		/*
-		 * Check to make sure the arguments we've been given are
-		 * satisfied.  Return an error if we have been asked to
-		 * list a mount point that does not match the other args
-		 * we've been given (-l, -t, etc.).
-		 */
-		if (checkvfsselected(statfsbuf.f_fstypename) != 0) {
-			rv = EXIT_FAILURE;
-			continue;
-		}
-
-		/* the user asked for it, so ignore the ignore flag */
-		statfsbuf.f_flags &= ~MNT_IGNORE;
-
-		/* add to list */
-		mntbuf[mntsize++] = statfsbuf;
 	}
 
 	memset(&maxwidths, 0, sizeof(maxwidths));
 	for (i = 0; i < mntsize; i++) {
-		if (aflag || (mntbuf[i].f_flags & MNT_IGNORE) == 0) {
+		if ((aflag || (mntbuf[i].f_blocks > 0)) && mntbuf[i].f_selected) {
 			update_maxwidths(&maxwidths, &mntbuf[i]);
 			if (cflag)
 				addstat(&totalbuf, &mntbuf[i]);
 		}
 	}
 	for (i = 0; i < mntsize; i++)
-		if (aflag || (mntbuf[i].f_flags & MNT_IGNORE) == 0)
+		if ((aflag || (mntbuf[i].f_blocks > 0)) && mntbuf[i].f_selected)
 			prtstat(&mntbuf[i], &maxwidths);
 
 	xo_close_list("filesystem");
@@ -285,19 +288,21 @@
 	xo_close_container("storage-system-information");
 	if (xo_finish() < 0)
 		rv = EXIT_FAILURE;
+	freemntinfo(mntbuf, mntsize);
 	exit(rv);
 }
 
 static char *
-getmntpt(const char *name)
+getmntpt(struct mntinfo **mntbuf, const size_t mntsize, const char *name)
 {
-	size_t mntsize, i;
-	struct statfs *mntbuf;
+	size_t i;
 
-	mntsize = getmntinfo(&mntbuf, MNT_NOWAIT);
+	if (mntsize == 0 || mntbuf == NULL || name == NULL)
+		return NULL;
+
 	for (i = 0; i < mntsize; i++) {
-		if (!strcmp(mntbuf[i].f_mntfromname, name))
-			return (mntbuf[i].f_mntonname);
+		if (mntbuf[i] == NULL)
+			continue;
 	}
 	return (NULL);
 }
@@ -374,6 +379,7 @@
 	return (result);
 }
 
+#if 0
 /*
  * Make a pass over the file system info in ``mntbuf'' filtering out
  * file system types not in vfslist_{l,t} and possibly re-stating to get
@@ -410,9 +416,10 @@
 	}
 	return (j);
 }
+#endif
 
 static void
-prthuman(const struct statfs *sfsp, int64_t used)
+prthuman(const struct mntinfo *sfsp, int64_t used)
 {
 
 	prthumanval("  {:blocks/%6s}", sfsp->f_blocks * sfsp->f_bsize);
@@ -456,7 +463,7 @@
 }
 
 /*
- * Convert statfs returned file system size into BLOCKSIZE units.
+ * Convert statvfs returned file system size into BLOCKSIZE units.
  */
 static intmax_t
 fsbtoblk(int64_t num, uint64_t fsbs, u_long bs)
@@ -468,7 +475,7 @@
  * Print out status about a file system.
  */
 static void
-prtstat(struct statfs *sfsp, struct maxwidths *mwp)
+prtstat(struct mntinfo *sfsp, struct maxwidths *mwp)
 {
 	static long blocksize;
 	static int headerlen, timesthrough = 0;
@@ -542,7 +549,7 @@
 		    mwp->avail, fsbtoblk(sfsp->f_bavail,
 		    sfsp->f_bsize, blocksize));
 	}
-	xo_emit(" {:used-percent/%5.0f}{U:%%}",
+	xo_emit("   {:used-percent/%5.0f}{U:%%}",
 	    availblks == 0 ? 100.0 : (double)used / (double)availblks * 100.0);
 	if (iflag) {
 		inodes = sfsp->f_files;
@@ -567,23 +574,23 @@
 		}
 	} else
 		xo_emit("  ");
-	if (strncmp(sfsp->f_mntfromname, "total", MNAMELEN) != 0)
-		xo_emit("  {:mounted-on}", sfsp->f_mntonname);
+	if (strcmp(sfsp->f_mntfromname, "total") != 0)
+		xo_emit("{:mounted-on}", sfsp->f_mntonname);
 	xo_emit("\n");
 	xo_close_instance("filesystem");
 }
 
 static void
-addstat(struct statfs *totalfsp, struct statfs *statfsp)
+addstat(struct mntinfo *totalfsp, struct mntinfo *statvfsp)
 {
 	uint64_t bsize;
 
-	bsize = statfsp->f_bsize / totalfsp->f_bsize;
-	totalfsp->f_blocks += statfsp->f_blocks * bsize;
-	totalfsp->f_bfree += statfsp->f_bfree * bsize;
-	totalfsp->f_bavail += statfsp->f_bavail * bsize;
-	totalfsp->f_files += statfsp->f_files;
-	totalfsp->f_ffree += statfsp->f_ffree;
+	bsize = statvfsp->f_bsize / totalfsp->f_bsize;
+	totalfsp->f_blocks += statvfsp->f_blocks * bsize;
+	totalfsp->f_bfree += statvfsp->f_bfree * bsize;
+	totalfsp->f_bavail += statvfsp->f_bavail * bsize;
+	totalfsp->f_files += statvfsp->f_files;
+	totalfsp->f_ffree += statvfsp->f_ffree;
 }
 
 /*
@@ -591,7 +598,7 @@
  * the file system specified by `sfsp'.
  */
 static void
-update_maxwidths(struct maxwidths *mwp, const struct statfs *sfsp)
+update_maxwidths(struct maxwidths *mwp, const struct mntinfo *sfsp)
 {
 	static long blocksize = 0;
 	int dummy;
@@ -643,69 +650,95 @@
 	exit(EX_USAGE);
 }
 
-static char *
-makenetvfslist(void)
+static int
+getmntinfo(struct mntinfo **mntbuf)
 {
-	char *str, *strptr, **listptr;
-	struct xvfsconf *xvfsp, *keep_xvfsp;
-	size_t buflen;
-	int cnt, i, maxvfsconf;
+	struct mntinfo *list = NULL;
+	struct mntinfo *current = NULL;
+	struct mntent *ent = NULL;
+	int mntsize = 0;
+	FILE *fp = NULL;
+	struct statvfs svfsbuf;
+	struct stat stmnt;
 
-	if (sysctlbyname("vfs.conflist", NULL, &buflen, NULL, 0) < 0) {
-		xo_warn("sysctl(vfs.conflist)");
-		return (NULL);
+#ifdef _PATH_MOUNTED
+	fp = setmntent(_PATH_MOUNTED, "r");
+#else
+	if (access("/proc/self/mounts", R_OK) == 0) {
+	    fp = setmntent("/proc/self/mounts", "r");
+	} else if (access("/proc/mounts", R_OK) == 0) {
+	    fp = setmntent("/proc/mounts", "r");
+	} else if (access("/etc/mtab", R_OK) == 0) {
+	    fp = setmntent("/etc/mtab", "r");
 	}
-	xvfsp = malloc(buflen);
-	if (xvfsp == NULL) {
-		xo_warnx("malloc failed");
-		return (NULL);
-	}
-	keep_xvfsp = xvfsp;
-	if (sysctlbyname("vfs.conflist", xvfsp, &buflen, NULL, 0) < 0) {
-		xo_warn("sysctl(vfs.conflist)");
-		free(keep_xvfsp);
-		return (NULL);
-	}
-	maxvfsconf = buflen / sizeof(struct xvfsconf);
+#endif
 
-	if ((listptr = malloc(sizeof(char*) * maxvfsconf)) == NULL) {
-		xo_warnx("malloc failed");
-		free(keep_xvfsp);
-		return (NULL);
+	if (fp == NULL) {
+	    xo_err(1, "setmntent");
 	}
 
-	for (cnt = 0, i = 0; i < maxvfsconf; i++) {
-		if (xvfsp->vfc_flags & VFCF_NETWORK) {
-			listptr[cnt++] = strdup(xvfsp->vfc_name);
-			if (listptr[cnt-1] == NULL) {
-				xo_warnx("malloc failed");
-				free(listptr);
-				free(keep_xvfsp);
-				return (NULL);
-			}
-		}
-		xvfsp++;
-	}
+	while ((ent = getmntent(fp)) != NULL) {
+	    /* skip if necessary */
+	    if (hasmntopt(ent, MNTTYPE_IGNORE) != NULL) {
+	        continue;
+	    }
 
-	if (cnt == 0 ||
-	    (str = malloc(sizeof(char) * (32 * cnt + cnt + 2))) == NULL) {
-		if (cnt > 0)
-			xo_warnx("malloc failed");
-		free(listptr);
-		free(keep_xvfsp);
-		return (NULL);
+	    /* filter out filesystems to be skipped */
+	    if (vfslist_l || vfslist_t) {
+	        if (checkvfsselected(ent->mnt_type) != 0)
+	            continue;
+	    }
+
+	    /* get stat(vfs) fields and copy those over */
+	    if (statvfs(ent->mnt_dir, &svfsbuf) == -1 || stat(ent->mnt_dir, &stmnt) == -1) {
+	        if ((errno == EACCES) || (errno == EPERM) || (errno == ENOTCONN)) continue;
+	        xo_err(1, "statvfs");
+	    }
+
+	    /* allocate the entry */
+	    list = realloc(list, (mntsize + 1) * sizeof(*list));
+	    assert(list != NULL);
+	    current = list + mntsize;
+
+	    /* fill the struct with getmntent fields */
+	    current->f_fstypename = strdup(ent->mnt_type);
+	    current->f_mntfromname = strdup(ent->mnt_fsname);
+	    current->f_mntonname = strdup(ent->mnt_dir);
+	    current->f_opts = strdup(ent->mnt_opts);
+
+	    current->f_flag = svfsbuf.f_flag;
+	    current->f_blocks = svfsbuf.f_blocks;
+	    current->f_bsize = svfsbuf.f_bsize;
+	    current->f_bfree = svfsbuf.f_bfree;
+	    current->f_bavail = svfsbuf.f_bavail;
+	    current->f_files = svfsbuf.f_files;
+	    current->f_ffree = svfsbuf.f_ffree;
+
+	    current->f_dev = stmnt.st_dev;
+
+	    current->f_selected = 1;
+
+	    mntsize++;
 	}
 
-	*str = 'n'; *(str + 1) = 'o';
-	for (i = 0, strptr = str + 2; i < cnt; i++, strptr++) {
-		strlcpy(strptr, listptr[i], 32);
-		strptr += strlen(listptr[i]);
-		*strptr = ',';
-		free(listptr[i]);
+	endmntent(fp);
+
+	*mntbuf = list;
+	return mntsize;
+}
+
+static void
+freemntinfo(struct mntinfo *mntbuf, int mntsize)
+{
+	int i = 0;
+
+	for (i = 0; i < mntsize; i++) {
+	    free(mntbuf[i].f_fstypename);
+	    free(mntbuf[i].f_mntfromname);
+	    free(mntbuf[i].f_mntonname);
+	    free(mntbuf[i].f_opts);
 	}
-	*(--strptr) = '\0';
 
-	free(keep_xvfsp);
-	free(listptr);
-	return (str);
+	free(mntbuf);
+	return;
 }
--- src.orig/coreutils/du/du.1
+++ src.freebsd/coreutils/du/du.1
@@ -115,12 +115,6 @@
 are counted (and displayed) as many times as they are found.
 .It Fl m
 Display block counts in 1048576-byte (1 MiB) blocks.
-.It Fl n
-Ignore files and directories with user
-.Dq nodump
-flag
-.Pq Dv UF_NODUMP
-set.
 .It Fl r
 Generate messages about directories that cannot be read, files
 that cannot be opened, and so on.
--- src.orig/coreutils/du/du.c
+++ src.freebsd/coreutils/du/du.c
@@ -54,6 +54,7 @@
 #include <getopt.h>
 #include <libutil.h>
 #include <locale.h>
+#include <signal.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -80,7 +81,6 @@
 static int	ignorep(FTSENT *);
 static void	siginfo(int __unused);
 
-static int	nodumpflag = 0;
 static int	Aflag, hflag;
 static long	blocksize, cblocksize;
 static volatile sig_atomic_t info;
@@ -119,7 +119,7 @@
 	depth = INT_MAX;
 	SLIST_INIT(&ignores);
 
-	while ((ch = getopt_long(argc, argv, "+AB:HI:LPasd:cghklmnrt:x",
+	while ((ch = getopt_long(argc, argv, "+AB:HI:LPasd:cghklmrt:x",
 	    long_options, NULL)) != -1)
 		switch (ch) {
 		case 'A':
@@ -185,19 +185,18 @@
 			hflag = 0;
 			blocksize = 1048576;
 			break;
-		case 'n':
-			nodumpflag = 1;
-			break;
 		case 'r':		 /* Compatibility. */
 			break;
-		case 't' :
-			if (expand_number(optarg, &threshold) != 0 ||
-			    threshold == 0) {
+		case 't' : {
+			uint64_t thresh;
+			if (expand_number(optarg, &thresh) != 0 ||
+			    (threshold = thresh) == 0) {
 				warnx("invalid threshold: %s", optarg);
 				usage();
 			} else if (threshold < 0)
 				threshold_sign = -1;
 			break;
+		}
 		case 'x':
 			ftsoptions |= FTS_XDEV;
 			break;
@@ -279,18 +278,18 @@
 			curblocks = Aflag ?
 			    howmany(p->fts_statp->st_size, cblocksize) :
 			    howmany(p->fts_statp->st_blocks, cblocksize);
-			p->fts_parent->fts_bignum += p->fts_bignum +=
+			p->fts_parent->fts_number += p->fts_number +=
 			    curblocks;
 
 			if (p->fts_level <= depth && threshold <=
-			    threshold_sign * howmany(p->fts_bignum *
+			    threshold_sign * howmany(p->fts_number *
 			    cblocksize, blocksize)) {
 				if (hflag > 0) {
-					prthumanval(p->fts_bignum);
+					prthumanval(p->fts_number);
 					(void)printf("\t%s\n", p->fts_path);
 				} else {
 					(void)printf("%jd\t%s\n",
-					    (intmax_t)howmany(p->fts_bignum *
+					    (intmax_t)howmany(p->fts_number *
 					    cblocksize, blocksize),
 					    p->fts_path);
 				}
@@ -332,9 +331,9 @@
 				}
 			}
 
-			p->fts_parent->fts_bignum += curblocks;
+			p->fts_parent->fts_number += curblocks;
 		}
-		savednumber = p->fts_parent->fts_bignum;
+		savednumber = p->fts_parent->fts_number;
 	}
 
 	if (errno)
@@ -545,8 +544,6 @@
 {
 	struct ignentry *ign;
 
-	if (nodumpflag && (ent->fts_statp->st_flags & UF_NODUMP))
-		return 1;
 	SLIST_FOREACH(ign, &ignores, next)
 		if (fnmatch(ign->mask, ent->fts_name, 0) != FNM_NOMATCH)
 			return 1;
--- src.orig/coreutils/env/env.1
+++ src.freebsd/coreutils/env/env.1
@@ -39,13 +39,11 @@
 .Sh SYNOPSIS
 .Nm
 .Op Fl 0iv
-.Op Fl L Ns | Ns Fl U Ar user Ns Op / Ns Ar class
 .Op Fl u Ar name
 .Op Ar name Ns = Ns Ar value ...
 .Nm
 .Op Fl iv
 .Op Fl C Ar altwd
-.Op Fl L Ns | Ns Fl U Ar user Ns Op / Ns Ar class
 .Op Fl P Ar altpath
 .Op Fl S Ar string
 .Op Fl u Ar name
@@ -88,34 +86,6 @@
 the specified
 .Ar utility
 program.
-.\"	-L | -U
-.It Fl L | Fl U Ar user Ns Op / Ns Ar class
-Add the environment variable definitions from
-.Xr login.conf 5
-for the specified user and login class to the environment, after
-processing any
-.Fl i
-or
-.Fl u
-options, but before processing any
-.Ar name Ns = Ns Ar value
-options.
-If
-.Fl L
-is used, only the system-wide
-.Pa /etc/login.conf.db
-file is read; if
-.Fl U
-is used, then the specified user's
-.Pa ~/.login_conf
-is read as well.
-The user may be specified by name or by uid.
-If a username of
-.Sq Li \&-
-is given, then no user lookup will be done, the login class will default to
-.Sq Li default
-if not explicitly given, and no substitutions will be done on the values.
-.\"	-P
 .It Fl P Ar altpath
 Search the set of directories as specified by
 .Ar altpath
--- src.orig/coreutils/env/env.c
+++ src.freebsd/coreutils/env/env.c
@@ -46,7 +46,6 @@
 
 #include <err.h>
 #include <errno.h>
-#include <login_cap.h>
 #include <pwd.h>
 #include <stdbool.h>
 #include <stdio.h>
@@ -74,24 +73,19 @@
 {
 	char *altpath, *altwd, **ep, *p, **parg, term;
 	char *cleanenv[1];
-	char *login_class, *login_name;
+	char *login_name;
 	struct passwd *pw;
-	login_cap_t *lc;
-	bool login_as_user;
 	uid_t uid;
 	int ch, want_clear;
 	int rtrn;
 
 	altpath = NULL;
 	altwd = NULL;
-	login_class = NULL;
 	login_name = NULL;
 	pw = NULL;
-	lc = NULL;
-	login_as_user = false;
 	want_clear = 0;
 	term = '\n';
-	while ((ch = getopt(argc, argv, "-0C:iL:P:S:U:u:v")) != -1)
+	while ((ch = getopt(argc, argv, "0C:iP:S:u:v")) != -1)
 		switch(ch) {
 		case '-':
 		case 'i':
@@ -103,12 +97,6 @@
 		case 'C':
 			altwd = optarg;
 			break;
-		case 'U':
-			login_as_user = true;
-			/* FALLTHROUGH */
-		case 'L':
-			login_name = optarg;
-			break;
 		case 'P':
 			altpath = optarg;
 			break;
@@ -136,6 +124,10 @@
 		default:
 			usage();
 		}
+	if (optind < argc && !strcmp(argv[optind], "-")) {
+		want_clear = 1;
+		++argv; /* skip the initial - during later scan */
+	}
 	if (want_clear) {
 		environ = cleanenv;
 		cleanenv[0] = NULL;
@@ -143,9 +135,6 @@
 			fprintf(stderr, "#env clearing environ\n");
 	}
 	if (login_name != NULL) {
-		login_class = strchr(login_name, '/');
-		if (login_class)
-			*login_class++ = '\0';
 		if (*login_name != '\0' && strcmp(login_name, "-") != 0) {
 			pw = getpwnam(login_name);
 			if (pw == NULL) {
@@ -158,38 +147,8 @@
 			if (pw == NULL)
 				errx(EXIT_FAILURE, "no such user: %s", login_name);
 		}
-		/*
-		 * Note that it is safe for pw to be null here; the libutil
-		 * code handles that, bypassing substitution of $ and using
-		 * the class "default" if no class name is given either.
-		 */
-		if (login_class != NULL) {
-			lc = login_getclass(login_class);
-			if (lc == NULL)
-				errx(EXIT_FAILURE, "no such login class: %s",
-				    login_class);
-		} else {
-			lc = login_getpwclass(pw);
-			if (lc == NULL)
-				errx(EXIT_FAILURE, "login_getpwclass failed");
-		}
 
-		/*
-		 * This is not done with setusercontext() because that will
-		 * try and use ~/.login_conf even when we don't want it to.
-		 */
-		setclassenvironment(lc, pw, 1);
-		setclassenvironment(lc, pw, 0);
-		if (login_as_user) {
-			login_close(lc);
-			if ((lc = login_getuserclass(pw)) != NULL) {
-				setclassenvironment(lc, pw, 1);
-				setclassenvironment(lc, pw, 0);
-			}
-		}
 		endpwent();
-		if (lc != NULL)
-			login_close(lc);
 	}
 	for (argv += optind; *argv && (p = strchr(*argv, '=')); ++argv) {
 		if (env_verbosity)
--- src.orig/coreutils/env/envopts.c
+++ src.freebsd/coreutils/env/envopts.c
@@ -31,6 +31,7 @@
  */
 
 #include <sys/cdefs.h>
+#include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/param.h>
 #include <err.h>
--- src.orig/coreutils/expr/expr.y
+++ src.freebsd/coreutils/expr/expr.y
@@ -6,6 +6,7 @@
  * Largely rewritten by J.T. Conklin (jtc@wimsey.com)
  */
 
+#include <sys/cdefs.h>
 #include <sys/types.h>
 
 #include <ctype.h>
@@ -268,8 +269,7 @@
 	int c;
 
 	setlocale(LC_ALL, "");
-	if (getenv("EXPR_COMPAT") != NULL
-	    || check_utility_compat("expr")) {
+	if (getenv("EXPR_COMPAT") != NULL) {
 		av = argv + 1;
 		nonposix = 1;
 	} else {
--- src.orig/coreutils/factor/factor.c
+++ src.freebsd/coreutils/factor/factor.c
@@ -63,6 +63,7 @@
  * If no args are given, the list of numbers are read from stdin.
  */
 
+#include <sys/types.h>
 #include <ctype.h>
 #include <err.h>
 #include <errno.h>
@@ -98,7 +99,7 @@
 
 #define BN_CTX			int
 #define BN_CTX_new()		NULL
-#define BN_new()		((BIGNUM *)calloc(sizeof(BIGNUM), 1))
+#define BN_new()		((BIGNUM *)calloc(1, sizeof(BIGNUM)))
 #define BN_is_zero(v)		(*(v) == 0)
 #define BN_is_one(v)		(*(v) == 1)
 #define BN_mod_word(a, b)	(*(a) % (b))
--- src.orig/coreutils/fmt/fmt.c
+++ src.freebsd/coreutils/fmt/fmt.c
@@ -183,6 +183,7 @@
 #include <unistd.h>
 #include <wchar.h>
 #include <wctype.h>
+#include <stdint.h>
 
 /* Something that, we hope, will never be a genuine line length,
  * indentation etc.
@@ -378,7 +379,7 @@
 		goal_length = 65;
 	if (max_length == 0)
 		max_length = goal_length + 10;
-	if (max_length >= SIZE_T_MAX / sizeof(wchar_t))
+	if (max_length >= SIZE_MAX / sizeof(wchar_t))
 		errx(EX_USAGE, "max length too large");
 	/* really needn't be longer */
 	output_buffer = XMALLOC((max_length + 1) * sizeof(wchar_t));
--- src.orig/coreutils/head/head.c
+++ src.freebsd/coreutils/head/head.c
@@ -87,6 +87,7 @@
 	FILE *fp;
 	off_t bytecnt;
 	intmax_t linecnt;
+	uint64_t ucnt;
 	int ch, first, eval;
 	fileargs_t *fa;
 	cap_rights_t rights;
@@ -101,11 +102,11 @@
 	while ((ch = getopt_long(argc, argv, "+n:c:qv", long_opts, NULL)) != -1) {
 		switch(ch) {
 		case 'c':
-			if (expand_number(optarg, &bytecnt) || bytecnt <= 0)
+			if (expand_number(optarg, &ucnt) || ((bytecnt = ucnt) <= 0))
 				errx(1, "illegal byte count -- %s", optarg);
 			break;
 		case 'n':
-			if (expand_number(optarg, &linecnt) || linecnt <= 0)
+			if (expand_number(optarg, &ucnt) || ((linecnt = ucnt) <= 0))
 				errx(1, "illegal line count -- %s", optarg);
 			break;
 		case 'q':
@@ -168,15 +169,17 @@
 static void
 head(FILE *fp, intmax_t cnt)
 {
-	char *cp;
-	size_t error, readlen;
+	char *cp = NULL;
+	size_t error, bufsize = 0;
+	ssize_t readlen;
 
-	while (cnt != 0 && (cp = fgetln(fp, &readlen)) != NULL) {
+	while (cnt != 0 && (readlen = getline(&cp, &bufsize, fp)) >= 0) {
 		error = fwrite(cp, sizeof(char), readlen, stdout);
-		if (error != readlen)
+		if ((ssize_t)error != readlen)
 			err(1, "stdout");
 		cnt--;
 	}
+	free(cp);
 }
 
 static void
--- src.orig/coreutils/id/id.1
+++ src.freebsd/coreutils/id/id.1
@@ -40,8 +40,6 @@
 .Nm
 .Op Ar user
 .Nm
-.Fl A
-.Nm
 .Fl G Op Fl n
 .Op Ar user
 .Nm
@@ -50,8 +48,6 @@
 .Fl P
 .Op Ar user
 .Nm
-.Fl c
-.Nm
 .Fl g Op Fl nr
 .Op Ar user
 .Nm
@@ -76,9 +72,6 @@
 .Pp
 The options are as follows:
 .Bl -tag -width indent
-.It Fl A
-Display the process audit user ID and other process audit properties, which
-requires privilege.
 .It Fl G
 Display the different group IDs (effective, real and supplementary)
 as white-space separated numbers, in no particular order.
@@ -90,8 +83,6 @@
 Ignored for compatibility with other
 .Nm
 implementations.
-.It Fl c
-Display current login class.
 .It Fl g
 Display the effective group ID as a number.
 .It Fl n
--- src.orig/coreutils/id/id.c
+++ src.freebsd/coreutils/id/id.c
@@ -41,13 +41,9 @@
 #endif
 #endif /* not lint */
 #include <sys/cdefs.h>
+#include <sys/types.h>
 #include <sys/param.h>
-#include <sys/mac.h>
 
-#ifdef USE_BSM_AUDIT
-#include <bsm/audit.h>
-#endif
-
 #include <err.h>
 #include <errno.h>
 #include <grp.h>
@@ -58,6 +54,10 @@
 #include <string.h>
 #include <unistd.h>
 
+#ifdef HAVE_SELINUX
+#include <selinux/selinux.h>
+#endif
+
 static void	id_print(struct passwd *, int, int, int);
 static void	pline(struct passwd *);
 static void	pretty(struct passwd *);
@@ -77,13 +77,9 @@
 	struct group *gr;
 	struct passwd *pw;
 	int Gflag, Mflag, Pflag, ch, gflag, id, nflag, pflag, rflag, uflag;
-	int Aflag, cflag;
-	int error;
 	const char *myname;
-	char loginclass[MAXLOGNAME];
 
 	Gflag = Mflag = Pflag = gflag = nflag = pflag = rflag = uflag = 0;
-	Aflag = cflag = 0;
 
 	myname = strrchr(argv[0], '/');
 	myname = (myname != NULL) ? myname + 1 : argv[0];
@@ -97,13 +93,8 @@
 	}
 
 	while ((ch = getopt(argc, argv,
-	    (isgroups || iswhoami) ? "" : "APGMacgnpru")) != -1)
+	    (isgroups || iswhoami) ? "" : "PGMagnpru")) != -1)
 		switch(ch) {
-#ifdef USE_BSM_AUDIT
-		case 'A':
-			Aflag = 1;
-			break;
-#endif
 		case 'G':
 			Gflag = 1;
 			break;
@@ -115,9 +106,6 @@
 			break;
 		case 'a':
 			break;
-		case 'c':
-			cflag = 1;
-			break;
 		case 'g':
 			gflag = 1;
 			break;
@@ -142,10 +130,10 @@
 
 	if (iswhoami && argc > 0)
 		usage();
-	if ((cflag || Aflag || Mflag) && argc > 0)
+	if (Mflag && argc > 0)
 		usage();
 
-	switch(Aflag + Gflag + Mflag + Pflag + gflag + pflag + uflag) {
+	switch(Gflag + Pflag + Mflag + gflag + pflag + uflag) {
 	case 1:
 		break;
 	case 0:
@@ -161,21 +149,6 @@
 	if (Mflag && pw != NULL)
 		usage();
 
-#ifdef USE_BSM_AUDIT
-	if (Aflag) {
-		auditid();
-		exit(0);
-	}
-#endif
-
-	if (cflag) {
-		error = getloginclass(loginclass, sizeof(loginclass));
-		if (error != 0)
-			err(1, "loginclass");
-		(void)printf("%s\n", loginclass);
-		exit(0);
-	}
-
 	if (gflag) {
 		id = pw ? pw->pw_gid : rflag ? getgid() : getegid();
 		if (nflag && (gr = getgrgid(id)))
@@ -419,6 +392,7 @@
 static void
 maclabel(void)
 {
+#if 0
 	char *string;
 	mac_t label;
 	int error;
@@ -438,6 +412,19 @@
 	(void)printf("%s\n", string);
 	mac_free(label);
 	free(string);
+#elif defined(HAVE_SELINUX)
+	char *context;
+	if (is_selinux_enabled() > 0) {
+		if (getcon(&context) == 0) {
+			(void)printf("%s\n", context);
+			freecon(context);
+		} else
+			errx(1, "getcon failed: %s", strerror(errno));
+	} else
+		errx(1, "-M works only on an SELinux-enabled kernel");
+#else
+	errx(1, "-M requires a MAC-enabled build");
+#endif
 }
 
 static struct passwd *
@@ -469,9 +456,9 @@
 			err(1, "getpwuid");
 	}
 
-	(void)printf("%s:%s:%d:%d:%s:%ld:%ld:%s:%s:%s\n", pw->pw_name,
-			pw->pw_passwd, pw->pw_uid, pw->pw_gid, pw->pw_class,
-			(long)pw->pw_change, (long)pw->pw_expire, pw->pw_gecos,
+	(void)printf("%s:%s:%d:%d:%s:%s:%s\n", pw->pw_name,
+			pw->pw_passwd, pw->pw_uid, pw->pw_gid,
+			pw->pw_gecos,
 			pw->pw_dir, pw->pw_shell);
 }
 
@@ -485,7 +472,7 @@
 	else if (iswhoami)
 		(void)fprintf(stderr, "usage: whoami\n");
 	else
-		(void)fprintf(stderr, "%s\n%s%s\n%s\n%s\n%s\n%s\n%s\n%s\n",
+		(void)fprintf(stderr, "%s\n%s%s\n%s\n%s\n%s\n%s\n%s\n",
 		    "usage: id [user]",
 #ifdef USE_BSM_AUDIT
 		    "       id -A\n",
@@ -495,7 +482,6 @@
 		    "       id -G [-n] [user]",
 		    "       id -M",
 		    "       id -P [user]",
-		    "       id -c",
 		    "       id -g [-nr] [user]",
 		    "       id -p [user]",
 		    "       id -u [-nr] [user]");
--- src.orig/coreutils/join/join.c
+++ src.freebsd/coreutils/join/join.c
@@ -46,6 +46,7 @@
 #endif /* not lint */
 #include <sys/cdefs.h>
 #include <sys/param.h>
+#include <sys/types.h>
 
 #include <err.h>
 #include <errno.h>
@@ -274,9 +275,10 @@
 slurp(INPUT *F)
 {
 	LINE *lp, *lastlp, tmp;
-	size_t len;
+	size_t blen = 0;
+	ssize_t len;
 	int cnt;
-	char *bp, *fieldp;
+	char *bp, *buf = NULL, *fieldp;
 
 	/*
 	 * Read all of the lines from an input file that have the same
@@ -319,21 +321,21 @@
 			F->pushbool = 0;
 			continue;
 		}
-		if ((bp = fgetln(F->fp, &len)) == NULL)
+		if ((len = getline(&buf, &blen, F->fp)) < 0) {
+			free(buf);
 			return;
-		if (lp->linealloc <= len + 1) {
+		}
+		if (lp->linealloc <= (size_t)(len + 1)) {
 			lp->linealloc += MAX(100, len + 1 - lp->linealloc);
 			if ((lp->line =
 			    realloc(lp->line, lp->linealloc)) == NULL)
 				err(1, NULL);
 		}
-		memmove(lp->line, bp, len);
+		memmove(lp->line, buf, len);
 
 		/* Replace trailing newline, if it exists. */
-		if (bp[len - 1] == '\n')
+		if (buf[len - 1] == '\n')
 			lp->line[len - 1] = '\0';
-		else
-			lp->line[len] = '\0';
 		bp = lp->line;
 
 		/* Split the line into fields, allocate space as necessary. */
@@ -357,6 +359,7 @@
 			break;
 		}
 	}
+	free(buf);
 }
 
 static char *
--- src.orig/coreutils/ln/ln.1
+++ src.freebsd/coreutils/ln/ln.1
@@ -40,17 +40,30 @@
 .Nd link files
 .Sh SYNOPSIS
 .Nm
-.Op Fl L | Fl P | Fl s Op Fl F
+.Op Fl L | Fl P | Fl s Op Fl Fr
 .Op Fl f | iw
 .Op Fl hnv
 .Ar source_file
 .Op Ar target_file
 .Nm
-.Op Fl L | Fl P | Fl s Op Fl F
+.Op Fl L | Fl P | Fl s Op Fl Fr
 .Op Fl f | iw
 .Op Fl hnv
+.Fl T
+.Ar source_file
+.Ar target_file
+.Nm
+.Op Fl L | Fl P | Fl s Op Fl Fr
+.Op Fl f | iw
+.Op Fl hnv
 .Ar source_file ...
 .Ar target_dir
+.Nm
+.Op Fl L | Fl P | Fl s Op Fl Fr
+.Op Fl f | iw
+.Op Fl hnv
+.Fl t Ar target_dir
+.Ar source_file ...
 .Nm link
 .Ar source_file Ar target_file
 .Sh DESCRIPTION
@@ -111,6 +124,11 @@
 This option cancels the
 .Fl L
 option.
+.It Fl T
+In modes where the target may be a file, error if
+the target is a directory instead of linking into
+the directory. May not be used with
+.Fl t .
 .It Fl f
 If the target file already exists,
 then unlink it so that the link may occur.
@@ -151,8 +169,17 @@
 for compatibility with other
 .Nm
 implementations.
+.It Fl r
+When creating symbolic links, make the link source relative to the target.
+Must be used with the
+.Fl s
+option.
 .It Fl s
 Create a symbolic link.
+.It Fl t Ar target_directory
+Specify the target directory as an optional argument. In this
+mode, it must be a directory, and all the positional arguments
+are linked into it.
 .It Fl v
 Cause
 .Nm
--- src.orig/coreutils/ln/ln.cc
+++ src.freebsd/coreutils/ln/ln.cc
@@ -44,6 +44,8 @@
 #include <sys/param.h>
 #include <sys/stat.h>
 
+#include <filesystem>
+
 #include <err.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -64,6 +66,8 @@
 static bool	vflag;			/* Verbose output. */
 static bool	wflag;			/* Warn if symlink target does not
 					 * exist, and -f is not enabled. */
+static bool	rflag;			/* make a relative symlink */
+static bool	Tflag;			/* target must be a file */
 static char	linkch;
 
 static int	linkit(const char *, const char *, bool);
@@ -74,7 +78,7 @@
 main(int argc, char *argv[])
 {
 	struct stat sb;
-	char *targetdir;
+	char *targetdir, *targdir = NULL;
 	int ch, exitval;
 
 	/*
@@ -99,7 +103,7 @@
 		exit(linkit(argv[0], argv[1], false));
 	}
 
-	while ((ch = getopt(argc, argv, "FLPfhinsvw")) != -1)
+	while ((ch = getopt(argc, argv, "FLPTfhinst:vwr")) != -1)
 		switch (ch) {
 		case 'F':
 			Fflag = true;
@@ -123,9 +127,18 @@
 			iflag = true;
 			fflag = false;
 			break;
+		case 'r':
+			rflag = true;
+			break;
 		case 's':
 			sflag = true;
 			break;
+		case 't':
+			targdir = optarg;
+			break;
+		case 'T':
+			Tflag = true;
+			break;
 		case 'v':
 			vflag = true;
 			break;
@@ -148,19 +161,31 @@
 		wflag = false;		/* Implied when fflag is true */
 	}
 
+	if (Tflag && targdir) {
+		errx(1, "-T and -t may not be used together");
+	}
+	if (rflag && !sflag) {
+		errx(1, "-r must be used with -s");
+	}
+
 	switch (argc) {
 	case 0:
 		usage();
+		break;
 		/* NOTREACHED */
 	case 1:				/* ln source */
+		if (targdir) break; /* take the path below */
+		if (Tflag) usage();
 		exit(linkit(argv[0], ".", true));
 	case 2:				/* ln source target */
+		if (targdir) break; /* take the path below */
 		exit(linkit(argv[0], argv[1], false));
 	default:
 		;
 	}
+	if (Tflag) usage();
 					/* ln source1 source2 directory */
-	targetdir = argv[argc - 1];
+	targetdir = targdir ? targdir : argv[argc - 1];
 	if (hflag && lstat(targetdir, &sb) == 0 && S_ISLNK(sb.st_mode)) {
 		/*
 		 * We were asked not to follow symlinks, but found one at
@@ -171,9 +196,11 @@
 	}
 	if (stat(targetdir, &sb))
 		err(1, "%s", targetdir);
-	if (!S_ISDIR(sb.st_mode))
-		usage();
-	for (exitval = 0; *argv != targetdir; ++argv)
+	if (!S_ISDIR(sb.st_mode)) {
+		errno = ENOTDIR;
+		err(1, "%s", targetdir);
+	}
+	for (exitval = 0; *argv != (targdir ? NULL : targetdir); ++argv)
 		exitval |= linkit(*argv, targetdir, true);
 	exit(exitval);
 }
@@ -253,9 +280,14 @@
 	 * If the target is a directory (and not a symlink if hflag),
 	 * append the source's name, unless Fflag is set.
 	 */
-	if (!Fflag && (isdir ||
+	if ((!Fflag || Tflag) && (isdir ||
 	    (lstat(target, &sb) == 0 && S_ISDIR(sb.st_mode)) ||
 	    (!hflag && stat(target, &sb) == 0 && S_ISDIR(sb.st_mode)))) {
+		if (Tflag) {
+			errno = EEXIST;
+			warn("%s", target);
+			return (1);
+		}
 		if (strlcpy(bbuf, source, sizeof(bbuf)) >= sizeof(bbuf) ||
 		    (p = basename(bbuf)) == NULL ||
 		    snprintf(path, sizeof(path), "%s/%s", target, p) >=
@@ -341,8 +373,25 @@
 		}
 	}
 
+	std::filesystem::path sourcep;
+	if (rflag) {
+		std::error_code ec{};
+		try {
+			auto tgt = std::filesystem::path{target};
+			sourcep = std::filesystem::relative(source,
+			    tgt.remove_filename(), ec);
+		} catch (std::bad_alloc const &) {
+			warnc(ENOMEM, "%s", source);
+			return (1);
+		}
+		if (ec) {
+			warnc(ec.value(), "%s", source);
+			return (1);
+		}
+	}
+
 	/* Attempt the link. */
-	if (sflag ? symlink(source, target) :
+	if (sflag ? symlink(rflag ? sourcep.c_str() : source, target) :
 	    linkat(AT_FDCWD, source, AT_FDCWD, target,
 	    Pflag ? 0 : AT_SYMLINK_FOLLOW)) {
 		warn("%s", target);
@@ -363,8 +412,9 @@
 static void
 usage(void)
 {
-	(void)fprintf(stderr, "%s\n%s\n",
-	    "usage: ln [-s [-F] | -L | -P] [-f | -i] [-hnv] source_file [target_file]",
-	    "       ln [-s [-F] | -L | -P] [-f | -i] [-hnv] source_file ... target_dir");
+	(void)fprintf(stderr, "%s\n%s\n%s\n",
+	    "usage: ln [-s [-Fr] | -L | -P] [-f | -i] [-hnvT] source_file [target_file]",
+	    "       ln [-s [-Fr] | -L | -P] [-f | -i] [-hnv] source_file ... target_dir",
+	    "       ln [-s [-Fr] | -L | -P] [-f | -i] [-hnv] -t target_dir source_file ...");
 	exit(1);
 }
--- src.orig/coreutils/ls/cmp.c
+++ src.freebsd/coreutils/ls/cmp.c
@@ -136,7 +136,7 @@
 int
 birthcmp(const FTSENT *a, const FTSENT *b)
 {
-
+#if 0
 	if (b->fts_statp->st_birthtim.tv_sec >
 	    a->fts_statp->st_birthtim.tv_sec)
 		return (1);
@@ -149,6 +149,7 @@
 	if (b->fts_statp->st_birthtim.tv_nsec <
 	    a->fts_statp->st_birthtim.tv_nsec)
 		return (-1);
+#endif
 	if (f_samesort)
 		return (strcoll(b->fts_name, a->fts_name));
 	else
--- src.orig/coreutils/ls/ls.1
+++ src.freebsd/coreutils/ls/ls.1
@@ -39,7 +39,7 @@
 .Nd list directory contents
 .Sh SYNOPSIS
 .Nm
-.Op Fl ABCFGHILPRSTUWZabcdfghiklmnopqrstuvwxy1\&,
+.Op Fl ABCFGHILPRSTWZabcdfghiklmnpqrstuvwxy1\&,
 .Op Fl -color Ns = Ns Ar when
 .Op Fl D Ar format
 .Op Ar
@@ -99,7 +99,7 @@
 to format the date and time output.
 The argument
 .Ar format
-is a string used by
+is a string used by FreeBSD
 .Xr strftime 3 .
 Depending on the choice of format string, this may result in a
 different number of columns in the output.
@@ -121,9 +121,6 @@
 an equals sign
 .Pq Ql =
 after each socket,
-a percent sign
-.Pq Ql %
-after each whiteout,
 and a vertical bar
 .Pq Ql \&|
 after each that is a
@@ -184,17 +181,8 @@
 option gives even more control over the output format.
 This option is not defined in
 .St -p1003.1-2008 .
-.It Fl U
-Use time when file was created for sorting or printing.
-This option is not defined in
-.St -p1003.1-2008 .
-.It Fl W
-Display whiteouts when scanning directories.
-This option is not defined in
-.St -p1003.1-2008 .
 .It Fl Z
-Display each file's MAC label; see
-.Xr maclabel 7 .
+Display each file's MAC label; this requires support in the build (e.g. SELinux).
 This option is not defined in
 .St -p1003.1-2008 .
 .It Fl a
@@ -334,15 +322,6 @@
 or group name in a long
 .Pq Fl l
 output.
-.It Fl o
-Include the file flags in a long
-.Pq Fl l
-output.
-This option is incompatible with
-.St -p1003.1-2008 .
-See
-.Xr chflags 1
-for a list of file flags and their meanings.
 .It Fl p
 Write a slash
 .Pq Ql /
@@ -573,8 +552,6 @@
 .Tn FIFO .
 .It Sy s
 Socket.
-.It Sy w
-Whiteout.
 .El
 .Pp
 The next three fields
@@ -866,11 +843,10 @@
 .Dl $ ls -l
 .Pp
 In addition to listing the contents of the current working directory in
-long format, show inode numbers, file flags (see
-.Xr chflags 1 ) ,
+long format, show inode numbers,
 and suffix each filename with a symbol representing its file type:
 .Pp
-.Dl $ ls -lioF
+.Dl $ ls -liF
 .Pp
 List the files in
 .Pa /var/log ,
@@ -884,7 +860,6 @@
 .St -p1003.2
 specification.
 .Sh SEE ALSO
-.Xr chflags 1 ,
 .Xr chmod 1 ,
 .Xr getfacl 1 ,
 .Xr sort 1 ,
@@ -895,15 +870,14 @@
 .Xr strmode 3 ,
 .Xr strverscmp 3 ,
 .Xr termcap 5 ,
-.Xr maclabel 7 ,
 .Xr sticky 7 ,
 .Xr symlink 7 ,
 .Xr getfmac 8
 .Sh STANDARDS
 With the exception of options
-.Fl g , n
+.Fl g
 and
-.Fl o ,
+.Fl n,
 the
 .Nm
 utility conforms to
@@ -911,7 +885,7 @@
 and
 .St -p1003.1-2008 .
 The options
-.Fl B , D , G , I , T , U , W , Z , b , h , v , w , y
+.Fl B , D , G , I , T , Z , b , h , v , w , y
 and
 .Fl ,
 are non-standard extensions.
--- src.orig/coreutils/ls/ls.c
+++ src.freebsd/coreutils/ls/ls.c
@@ -47,7 +47,7 @@
 #include <sys/param.h>
 #include <sys/stat.h>
 #include <sys/ioctl.h>
-#include <sys/mac.h>
+#include <sys/types.h>
 
 #include <ctype.h>
 #include <dirent.h>
@@ -69,6 +69,9 @@
 #include <termcap.h>
 #include <signal.h>
 #endif
+#ifdef HAVE_SELINUX
+#include <selinux/selinux.h>
+#endif
 
 #include "ls.h"
 #include "extern.h"
@@ -96,7 +99,7 @@
 	} while(0)
 
 static void	 display(const FTSENT *, FTSENT *, int);
-static int	 mastercmp(const FTSENT * const *, const FTSENT * const *);
+static int	 mastercmp(const FTSENT **, const FTSENT **);
 static void	 traverse(int, char **, int);
 
 #define	COLOR_OPT	(CHAR_MAX + 1)
@@ -275,7 +278,7 @@
 		colorflag = COLORFLAG_AUTO;
 #endif
 	while ((ch = getopt_long(argc, argv,
-	    "+1ABCD:FGHILPRSTUWXZabcdfghiklmnopqrstuvwxy,", long_opts,
+	    "+1ABCD:FGHILPRSTXZabcdfghiklmnpqrstuvwxy,", long_opts,
 	    NULL)) != -1) {
 		switch (ch) {
 		/*
@@ -473,8 +476,6 @@
 				errx(2, "unsupported --color value '%s' (must be always, auto, or never)",
 				    optarg);
 			break;
-#else
-			warnx("color support not compiled in");
 #endif
 		default:
 		case '?':
@@ -713,7 +714,7 @@
  * points to the parent directory of the display list.
  */
 static void
-display(const FTSENT *p, FTSENT *list, int options)
+display(const FTSENT *p, FTSENT *list, int options __unused)
 {
 	struct stat *sp;
 	DISPLAY d;
@@ -731,8 +732,10 @@
 	size_t flen, ulen, glen;
 	char *initmax;
 	int entries, needstats;
+	struct passwd *pwentry = NULL;
+	struct group *grentry = NULL;
 	const char *user, *group;
-	char *flags, *labelstr = NULL;
+	char *labelstr = NULL;
 	char ngroup[STRBUF_SIZEOF(uid_t) + 1];
 	char nuser[STRBUF_SIZEOF(gid_t) + 1];
 	u_long width[9];
@@ -789,7 +792,6 @@
 
 	d.s_size = 0;
 	sizelen = 0;
-	flags = NULL;
 	for (cur = list, entries = 0; cur; cur = cur->fts_link) {
 		if (cur->fts_info == FTS_ERR || cur->fts_info == FTS_NS) {
 			warnx("%s: %s",
@@ -844,27 +846,33 @@
 					user = nuser;
 					group = ngroup;
 				} else {
-					user = user_from_uid(sp->st_uid, 0);
+					pwentry = getpwuid(sp->st_uid);
 					/*
-					 * user_from_uid(..., 0) only returns
-					 * NULL in OOM conditions.  We could
-					 * format the uid here, but (1) in
-					 * general ls(1) exits on OOM, and (2)
-					 * there is another allocation/exit
-					 * path directly below, which will
-					 * likely exit anyway.
+					 * getpwuid and getgrgid are allowed to
+					 * return NULL when the information is
+					 * not known (i.e. not in /etc/passwd)
+					 * so fall back to numeric IDs if needed
 					 */
-					if (user == NULL)
-						err(1, "user_from_uid");
-					group = group_from_gid(sp->st_gid, 0);
+					if (pwentry == NULL) {
+						(void)snprintf(nuser, sizeof(nuser),
+						    "%u", sp->st_uid);
+						user = nuser;
+					} else
+						user = pwentry->pw_name;
+					grentry = getgrgid(sp->st_gid);
 					/* Ditto. */
-					if (group == NULL)
-						err(1, "group_from_gid");
+					if (grentry == NULL) {
+						(void)snprintf(ngroup, sizeof(ngroup),
+						    "%u", sp->st_gid);
+						group = ngroup;
+					} else
+						group = grentry->gr_name;
 				}
 				if ((ulen = strlen(user)) > maxuser)
 					maxuser = ulen;
 				if ((glen = strlen(group)) > maxgroup)
 					maxgroup = glen;
+#if 0
 				if (f_flags) {
 					flags = fflagstostr(sp->st_flags);
 					if (flags != NULL && *flags == '\0') {
@@ -878,8 +886,10 @@
 						maxflags = flen;
 				} else
 					flen = 0;
+#endif
 				labelstr = NULL;
 				if (f_label) {
+#if 0
 					char name[PATH_MAX + 1];
 					mac_t label;
 					int error;
@@ -925,6 +935,27 @@
 					}
 					mac_free(label);
 label_out:
+#elif defined(HAVE_SELINUX)
+					char *context = NULL;
+					int error;
+
+					char name[PATH_MAX + 1];
+					if (cur->fts_level == FTS_ROOTLEVEL)
+						snprintf(name, sizeof(name), "%s", cur->fts_name);
+					else
+						snprintf(name, sizeof(name), "%s/%s", cur->fts_parent->fts_accpath, cur->fts_name);
+
+					if (options & FTS_LOGICAL)
+						error = getfilecon(name, &context);
+					else
+						error = lgetfilecon(name, &context);
+
+					if (error == -1) {
+						warn("SELinux context for %s/%s", cur->fts_parent->fts_path, cur->fts_name);
+						labelstr = strdup("?");
+					} else
+						labelstr = context;
+#endif
 					if (labelstr == NULL)
 						labelstr = strdup("-");
 					labelstrlen = strlen(labelstr);
@@ -932,7 +963,6 @@
 						maxlabelstr = labelstrlen;
 				} else
 					labelstrlen = 0;
-
 				if ((np = malloc(sizeof(NAMES) + labelstrlen +
 				    ulen + glen + flen + 4)) == NULL)
 					err(1, "malloc");
@@ -942,6 +972,11 @@
 				np->group = &np->data[ulen + 1];
 				(void)strcpy(np->group, group);
 
+				if (labelstr != NULL) {
+					np->label = &np->data[ulen + glen + 2];
+					(void)strcpy(np->label, labelstr);
+				}
+
 				if (S_ISCHR(sp->st_mode) ||
 				    S_ISBLK(sp->st_mode)) {
 					sizelen = snprintf(NULL, 0,
@@ -950,11 +985,6 @@
 						d.s_size = sizelen;
 				}
 
-				if (f_flags) {
-					np->flags = &np->data[ulen + glen + 2];
-					(void)strcpy(np->flags, flags);
-					free(flags);
-				}
 				if (f_label) {
 					np->label = &np->data[ulen + glen + 2
 					    + (f_flags ? flen + 1 : 0)];
@@ -1011,7 +1041,7 @@
  * All other levels use the sort function.  Error entries remain unsorted.
  */
 static int
-mastercmp(const FTSENT * const *a, const FTSENT * const *b)
+mastercmp(const FTSENT **a, const FTSENT **b)
 {
 	int a_info, b_info;
 
--- src.orig/coreutils/ls/print.c
+++ src.freebsd/coreutils/ls/print.c
@@ -41,6 +41,7 @@
 #include <sys/param.h>
 #include <sys/stat.h>
 #include <sys/acl.h>
+#include <acl/libacl.h>
 
 #include <err.h>
 #include <errno.h>
@@ -52,7 +53,7 @@
 #include <stdint.h>
 #include <stdlib.h>
 #include <string.h>
-#include <time.h>
+#include <time_bsd.h>
 #include <unistd.h>
 #include <wchar.h>
 #ifdef COLORLS
@@ -248,7 +249,7 @@
 		if (f_accesstime)
 			printtime(sp->st_atime);
 		else if (f_birthtime)
-			printtime(sp->st_birthtime);
+			printtime(sp->st_ctime);
 		else if (f_statustime)
 			printtime(sp->st_ctime);
 		else
@@ -453,7 +454,7 @@
 		}
 	}
 	if (tm != NULL)
-		strftime(str, len, format, tm);
+		strftime_bsd(str, len, format, tm);
 	else
 		strlcpy(str, "bad date val", len);
 }
@@ -466,8 +467,11 @@
 	const char *format;
 	static int d_first = -1;
 
-	if (d_first < 0)
-		d_first = (*nl_langinfo(D_MD_ORDER) == 'd');
+	if (d_first < 0) {
+		d_first = 0;
+		if (strlen(nl_langinfo(D_FMT)) >= 2 && nl_langinfo(D_FMT)[1] == 'd')
+			d_first = 1;
+	}
 	if (now == 0)
 		now = time(NULL);
 
@@ -513,9 +517,6 @@
 	case S_IFSOCK:
 		(void)putchar('=');
 		return (1);
-	case S_IFWHT:
-		(void)putchar('%');
-		return (1);
 	default:
 		break;
 	}
@@ -773,18 +774,12 @@
 aclmode(char *buf, const FTSENT *p)
 {
 	char name[MAXPATHLEN + 1];
-	int ret, trivial;
-	static dev_t previous_dev = NODEV;
+	int ret, trivial = -1;
+	static dev_t previous_dev = (dev_t)-1;
 	static int supports_acls = -1;
-	static int type = ACL_TYPE_ACCESS;
-	acl_t facl;
 
-	/*
-	 * XXX: ACLs are not supported on whiteouts and device files
-	 * residing on UFS.
-	 */
 	if (S_ISCHR(p->fts_statp->st_mode) || S_ISBLK(p->fts_statp->st_mode) ||
-	    S_ISWHT(p->fts_statp->st_mode))
+	    S_ISLNK(p->fts_statp->st_mode))
 		return;
 
 	if (previous_dev == p->fts_statp->st_dev && supports_acls == 0)
@@ -799,7 +794,7 @@
 	if (previous_dev != p->fts_statp->st_dev) {
 		previous_dev = p->fts_statp->st_dev;
 		supports_acls = 0;
-
+#if 0
 		ret = lpathconf(name, _PC_ACL_NFS4);
 		if (ret > 0) {
 			type = ACL_TYPE_NFS4;
@@ -808,30 +803,24 @@
 			warn("%s", name);
 			return;
 		}
+#endif
 		if (supports_acls == 0) {
-			ret = lpathconf(name, _PC_ACL_EXTENDED);
-			if (ret > 0) {
-				type = ACL_TYPE_ACCESS;
+			ret = acl_extended_file(name);
+			if (ret >= 0) {
 				supports_acls = 1;
-			} else if (ret < 0 && errno != EINVAL) {
+				trivial = !ret;
+			} else if (ret < 0 && errno != ENOTSUP) {
 				warn("%s", name);
 				return;
+			} else {
+				supports_acls = 0;
 			}
 		}
 	}
 	if (supports_acls == 0)
 		return;
-	facl = acl_get_link_np(name, type);
-	if (facl == NULL) {
-		warn("%s", name);
-		return;
-	}
-	if (acl_is_trivial_np(facl, &trivial)) {
-		acl_free(facl);
-		warn("%s", name);
-		return;
-	}
+	if (trivial < 0)
+		trivial = !(acl_extended_file(name) > 0);
 	if (!trivial)
 		buf[10] = '+';
-	acl_free(facl);
 }
--- src.orig/coreutils/ls/util.c
+++ src.freebsd/coreutils/ls/util.c
@@ -225,9 +225,9 @@
 {
 	(void)fprintf(stderr,
 #ifdef COLORLS
-	"usage: ls [-ABCFGHILPRSTUWZabcdfghiklmnopqrstuvwxy1,] [--color=when] [-D format]"
+	"usage: ls [-ABCFGHILPRSTZabcdfghiklmnpqrstuvwxy1,] [--color=when] [-D format]"
 #else
-	"usage: ls [-ABCFHILPRSTUWZabcdfghiklmnopqrstuvwxy1,] [-D format]"
+	"usage: ls [-ABCFHILPRSTZabcdfghiklmnpqrstuvwxy1,] [-D format]"
 #endif
 		      " [file ...]\n");
 	exit(1);
--- src.orig/coreutils/md5/md5.1
+++ src.freebsd/coreutils/md5/md5.1
@@ -4,10 +4,8 @@
 .Sh NAME
 .Nm md5 , sha1 , sha224 , sha256 , sha384 ,
 .Nm sha512 , sha512t224 , sha512t256 ,
-.Nm rmd160 , skein256 , skein512 , skein1024 ,
 .Nm md5sum , sha1sum , sha224sum , sha256sum , sha384sum ,
 .Nm sha512sum , sha512t224sum , sha512t256sum ,
-.Nm rmd160sum , skein256sum , skein512sum , skein1024sum ,
 .Nm shasum
 .Nd calculate a message-digest fingerprint (checksum) for a file
 .Sh SYNOPSIS
@@ -54,10 +52,9 @@
 .Op Ar
 .Sh DESCRIPTION
 The
-.Nm md5 , sha1 , sha224 , sha256 , sha384 , sha512 , sha512t224 , sha512t256 ,
-.Nm rmd160 , skein256 , skein512 ,
+.Nm md5 , sha1 , sha224 , sha256 , sha384 , sha512 , sha512t224 ,
 and
-.Nm skein1024
+.Nm sha512t256
 utilities take as input a message of arbitrary length and produce as
 output a
 .Dq fingerprint
@@ -67,9 +64,9 @@
 .Pp
 The
 .Nm md5sum , sha1sum , sha224sum , sha256sum , sha384sum , sha512sum ,
-.Nm sha512t224sum , sha512t256sum , rmd160sum , skein256sum , skein512sum ,
+.Nm sha512t224sum ,
 and
-.Nm skein1024sum
+.Nm sha512t256sum
 utilities do the same, but with command-line options and an output
 format that match those of their similary named GNU utilities.
 .Pp
@@ -87,8 +84,7 @@
 It is conjectured that it is computationally infeasible to
 produce two messages having the same message digest, or to produce any
 message having a given prespecified target message digest.
-The SHA-224 , SHA-256 , SHA-384 , SHA-512, RIPEMD-160,
-and SKEIN
+The SHA-224 , SHA-256 , SHA-384 , and SHA-512
 algorithms are intended for digital signature applications, where a
 large file must be
 .Dq compressed
@@ -112,7 +108,7 @@
 SHA-512t224 is identical to SHA-512t256, but with the digest truncated
 to 224 bits.
 .Pp
-It is recommended that all new applications use SHA-512 or SKEIN-512
+It is recommended that all new applications use SHA-512
 instead of one of the other hash functions.
 .Ss BSD OPTIONS
 The following options are available in BSD mode, i.e. when the program
@@ -279,11 +275,9 @@
 .El
 .Sh EXIT STATUS
 The
-.Nm md5 , sha1 , sha224 , sha256 , sha384 , sha512 ,
-.Nm sha512t224 , sha512t256 ,
-.Nm rmd160 , skein256 , skein512 ,
+.Nm md5 , sha1 , sha224 , sha256 , sha384 , sha512 , sha512t224 ,
 and
-.Nm skein1024
+.Nm sha512t256
 utilities exit 0 on success,
 1 if at least one of the input files could not be read,
 and 2 if at least one file does not have the same hash as the
@@ -292,10 +286,9 @@
 .Pp
 The
 .Nm md5sum , sha1sum , sha224sum , sha256sum , sha384sum , sha512sum ,
-.Nm sha512t224sum , sha512t256sum ,
-.Nm rmd160 , skein256 , skein512 , skein1024
+.Nm sha512t224sum ,
 and
-.Nm shasum
+.Nm sha512t256sum
 utilities exit 0 on success and 1 if at least one of the input files
 could not be read or, when verifying checksums, does not have the
 expected checksum.
@@ -380,12 +373,10 @@
 .Sh SEE ALSO
 .Xr cksum 1 ,
 .Xr md5 3 ,
-.Xr ripemd 3 ,
 .Xr sha 3 ,
 .Xr sha256 3 ,
 .Xr sha384 3 ,
 .Xr sha512 3 ,
-.Xr skein 3
 .Rs
 .%A R. Rivest
 .%T The MD5 Message-Digest Algorithm
@@ -402,15 +393,8 @@
 .%O RFC 3174
 .Re
 .Pp
-RIPEMD-160 is part of the ISO draft standard
-.Qq ISO/IEC DIS 10118-3
-on dedicated hash functions.
-.Pp
 Secure Hash Standard (SHS):
 .Pa https://www.nist.gov/publications/secure-hash-standard-shs
-.Pp
-The RIPEMD-160 page:
-.Pa https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
 .Sh BUGS
 In bits mode, the original
 .Nm shasum
@@ -422,15 +406,12 @@
 This utility was originally derived from a program which was placed in
 the public domain for free general use by RSA Data Security.
 .Pp
-Support for SHA-1 and RIPEMD-160 was added by
+Support for SHA-1 was added by
 .An Oliver Eikemeier Aq Mt eik@FreeBSD.org .
 .Pp
 Support for SHA-2 was added by
 .An Colin Percival Aq Mt cperciva@FreeBSD.org
 and
-.An Allan Jude Aq Mt allanjude@FreeBSD.org .
-.Pp
-Support for SKEIN was added by
 .An Allan Jude Aq Mt allanjude@FreeBSD.org .
 .Pp
 Compatibility with GNU coreutils was added by
--- src.orig/coreutils/md5/md5.c
+++ src.freebsd/coreutils/md5/md5.c
@@ -17,6 +17,8 @@
  *  documentation and/or software.
  */
 
+#include "config-compat.h"
+
 #include <sys/cdefs.h>
 #include <sys/param.h>
 #include <sys/resource.h>
@@ -28,15 +30,12 @@
 #include <fcntl.h>
 #include <getopt.h>
 #include <md5.h>
-#include <osreldate.h>
-#include <ripemd.h>
 #include <sha.h>
 #include <sha224.h>
 #include <sha256.h>
 #include <sha384.h>
 #include <sha512.h>
 #include <sha512t.h>
-#include <skein.h>
 #include <stdbool.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -73,9 +72,9 @@
 static bool failed;
 static int endl = '\n';
 
-typedef void (DIGEST_Init)(void *);
-typedef void (DIGEST_Update)(void *, const unsigned char *, size_t);
-typedef char *(DIGEST_End)(void *, char *);
+typedef void (DIGEST_Init)(EVP_MD_CTX **);
+typedef void (DIGEST_Update)(EVP_MD_CTX **, const void *, size_t);
+typedef char *(DIGEST_End)(EVP_MD_CTX **, char *);
 
 extern const char *MD5TestOutput[MDTESTCOUNT];
 extern const char *SHA1_TestOutput[MDTESTCOUNT];
@@ -85,10 +84,12 @@
 extern const char *SHA512_TestOutput[MDTESTCOUNT];
 extern const char *SHA512t224_TestOutput[MDTESTCOUNT];
 extern const char *SHA512t256_TestOutput[MDTESTCOUNT];
+#if 0
 extern const char *RIPEMD160_TestOutput[MDTESTCOUNT];
 extern const char *SKEIN256_TestOutput[MDTESTCOUNT];
 extern const char *SKEIN512_TestOutput[MDTESTCOUNT];
 extern const char *SKEIN1024_TestOutput[MDTESTCOUNT];
+#endif
 
 typedef struct Algorithm_t {
 	const char *progname;
@@ -101,7 +102,6 @@
 	char *(*Data)(const void *, unsigned int, char *);
 } Algorithm_t;
 
-static void MD5_Update(MD5_CTX *, const unsigned char *, size_t);
 static char *MDInput(const Algorithm_t *, FILE *, char *, bool);
 static void MDOutput(const Algorithm_t *, char *, const char *);
 static void MDTimeTrial(const Algorithm_t *);
@@ -109,6 +109,7 @@
 static void usage(const Algorithm_t *);
 static void version(void);
 
+#if 0
 typedef union {
 	MD5_CTX md5;
 	SHA1_CTX sha1;
@@ -121,6 +122,8 @@
 	SKEIN512_CTX skein512;
 	SKEIN1024_CTX skein1024;
 } DIGEST_CTX;
+#endif
+typedef EVP_MD_CTX *DIGEST_CTX;
 
 /* max(MD5_DIGEST_LENGTH, SHA_DIGEST_LENGTH,
 	SHA256_DIGEST_LENGTH, SHA512_DIGEST_LENGTH,
@@ -162,6 +165,7 @@
 		&SHA512t256_TestOutput, (DIGEST_Init*)&SHA512_256_Init,
 		(DIGEST_Update*)&SHA512_256_Update, (DIGEST_End*)&SHA512_256_End,
 		&SHA512_256_Data },
+#if 0
 	{ "rmd160", NULL, "RMD160",
 		&RIPEMD160_TestOutput,
 		(DIGEST_Init*)&RIPEMD160_Init, (DIGEST_Update*)&RIPEMD160_Update,
@@ -178,6 +182,7 @@
 		&SKEIN1024_TestOutput,
 		(DIGEST_Init*)&SKEIN1024_Init, (DIGEST_Update*)&SKEIN1024_Update,
 		(DIGEST_End*)&SKEIN1024_End, &SKEIN1024_Data },
+#endif
 	{ }
 };
 
@@ -281,11 +286,13 @@
 };
 static const char *perl_shortopts = "0a:bchqstUvw";
 
+#if 0
 static void
 MD5_Update(MD5_CTX *c, const unsigned char *data, size_t len)
 {
 	MD5Update(c, data, len);
 }
+#endif
 
 struct chksumrec {
 	char *filename;
@@ -311,7 +318,7 @@
 	int lineno;
 	char *filename;
 	char *hashstr;
-	struct chksumrec *rec;
+	struct chksumrec *rec = NULL;
 	const char *digestname;
 	size_t digestnamelen;
 	size_t hashstrlen;
@@ -589,11 +596,11 @@
 		 * with an array of the filenames from that list.
 		 */
 		if (argc < 1)
-			usage(&Algorithm[digest]);
-		while (argc--)
+			gnu_check("-");
+		else while (argc--)
 			gnu_check(*argv++);
 		argc = 0;
-		argv = calloc(sizeof(char *), numrecs + 1);
+		argv = calloc(numrecs + 1, sizeof(char *));
 		for (rec = head; rec != NULL; rec = rec->next) {
 			argv[argc] = rec->filename;
 			argc++;
@@ -687,7 +694,7 @@
 	DIGEST_CTX context;
 	char *end, *p, *q;
 	size_t len;
-	int bits;
+	int bits = 0;
 	uint8_t byte;
 	bool cr = false;
 
@@ -952,6 +959,7 @@
 	"dd095fc859b336c30a52548b3dc59fcc0d1be8616ebcf3368fad23107db2d736"
 };
 
+#if 0
 const char *RIPEMD160_TestOutput[MDTESTCOUNT] = {
 	"9c1185a5c5e9fc54612808977ee8f548b2258d31",
 	"0bdc9d2d256b3ee9daae347be6f4dc835a467ffe",
@@ -995,6 +1003,7 @@
 	"cf21a613620e6c119eca31fdfaad449a8e02f95ca256c21d2a105f8e4157048f9fe1e897893ea18b64e0e37cb07d5ac947f27ba544caf7cbc1ad094e675aed77a366270f7eb7f46543bccfa61c526fd628408058ed00ed566ac35a9761d002e629c4fb0d430b2f4ad016fcc49c44d2981c4002da0eecc42144160e2eaea4855a",
 	"e6799b78db54085a2be7ff4c8007f147fa88d326abab30be0560b953396d8802feee9a15419b48a467574e9283be15685ca8a079ee52b27166b64dd70b124b1d4e4f6aca37224c3f2685e67e67baef9f94b905698adc794a09672aba977a61b20966912acdb08c21a2c37001785355dc884751a21f848ab36e590331ff938138"
 };
+#endif
 
 static void
 MDTestSuite(const Algorithm_t *alg)
@@ -1038,8 +1047,6 @@
 {
 	if (mode == mode_gnu)
 		printf("%s (FreeBSD) ", progname);
-	printf("%d.%d\n",
-	    __FreeBSD_version / 100000,
-	    (__FreeBSD_version / 1000) % 100);
+	printf("%s\n", PROJECT_VERSION);
 	exit(0);
 }
--- src.orig/coreutils/mknod/mknod.c
+++ src.freebsd/coreutils/mknod/mknod.c
@@ -46,6 +46,7 @@
 
 #include <sys/types.h>
 #include <sys/stat.h>
+#include <sys/sysmacros.h>
 
 #include <err.h>
 #include <errno.h>
--- src.orig/coreutils/mktemp/mktemp.c
+++ src.freebsd/coreutils/mktemp/mktemp.c
@@ -36,6 +36,7 @@
  * more like the OpenBSD version - which was first to publish the interface.
  */
 
+#include <sys/cdefs.h>
 #include <err.h>
 #include <getopt.h>
 #include <paths.h>
@@ -162,7 +163,7 @@
 		}
 
 		if (dflag) {
-			if (mkdtemp(name) == NULL) {
+			if (compat_mkdtemp(name) == NULL) {
 				ret = 1;
 				if (!qflag)
 					warn("mkdtemp failed on %s", name);
@@ -172,7 +173,7 @@
 					rmdir(name);
 			}
 		} else {
-			fd = mkstemp(name);
+			fd = compat_mkstemp(name);
 			if (fd < 0) {
 				ret = 1;
 				if (!qflag)
--- src.orig/coreutils/mv/mv.1
+++ src.freebsd/coreutils/mv/mv.1
@@ -40,12 +40,17 @@
 .Sh SYNOPSIS
 .Nm
 .Op Fl f | i | n
-.Op Fl hv
+.Op Fl hvT
 .Ar source target
 .Nm
 .Op Fl f | i | n
 .Op Fl v
 .Ar source ... directory
+.Nm
+.Op Fl f | i | n
+.Op Fl v
+.Fl t Ar directory
+.Ar source ...
 .Sh DESCRIPTION
 In its first form, the
 .Nm
@@ -70,6 +75,9 @@
 .Pp
 The following options are available:
 .Bl -tag -width indent
+.It Fl T
+Ensure that the target is a file. May not be used with
+.Fl t .
 .It Fl f
 Do not prompt for confirmation before overwriting the destination
 path.
@@ -121,6 +129,8 @@
 or
 .Fl i
 options.)
+.It Fl t Ar directory
+Specify the target directory to move other arguments into.
 .It Fl v
 Cause
 .Nm
--- src.orig/coreutils/mv/mv.c
+++ src.freebsd/coreutils/mv/mv.c
@@ -50,7 +50,10 @@
 #include <sys/time.h>
 #include <sys/wait.h>
 #include <sys/stat.h>
+#include <sys/xattr.h>
 #include <sys/mount.h>
+#include <sys/statvfs.h>
+#include <acl/libacl.h>
 
 #include <err.h>
 #include <errno.h>
@@ -68,7 +71,7 @@
 /* Exit code for a failed exec. */
 #define EXEC_FAILED 127
 
-static int	fflg, hflg, iflg, nflg, vflg;
+static int	fflg, hflg, iflg, nflg, vflg, Tflg;
 
 static int	copy(const char *, const char *);
 static int	do_move(const char *, const char *);
@@ -76,18 +79,21 @@
 static void	usage(void);
 static void	preserve_fd_acls(int source_fd, int dest_fd, const char *source_path,
 		    const char *dest_path);
+static void	preserve_fd_xattrs(int source_fd, int dest_fd, const char *source_path,
+		    const char *dest_path);
 
 int
 main(int argc, char *argv[])
 {
 	size_t baselen, len;
 	int rval;
-	char *p, *endp;
+	char *p, *endp, *targdir = NULL;
 	struct stat sb;
 	int ch;
 	char path[PATH_MAX];
+	const char *target;
 
-	while ((ch = getopt(argc, argv, "fhinv")) != -1)
+	while ((ch = getopt(argc, argv, "Tfhint:v")) != -1)
 		switch (ch) {
 		case 'h':
 			hflg = 1;
@@ -104,6 +110,12 @@
 			nflg = 1;
 			fflg = iflg = 0;
 			break;
+		case 't':
+			targdir = optarg;
+			break;
+		case 'T':
+			Tflg = 1;
+			break;
 		case 'v':
 			vflg = 1;
 			break;
@@ -113,18 +125,28 @@
 	argc -= optind;
 	argv += optind;
 
-	if (argc < 2)
+	if (argc < (!targdir + 1) || (Tflg && argc > 2))
 		usage();
 
+	if (Tflg && targdir)
+		errx(1, "the -T and -t options may not be used together");
+	if (hflg && targdir)
+		errx(1, "the -h and -t options may not be used together");
+
+	target = targdir ? targdir : argv[argc - 1];
+
 	/*
 	 * If the stat on the target fails or the target isn't a directory,
 	 * try the move.  More than 2 arguments is an error in this case.
 	 */
-	if (stat(argv[argc - 1], &sb) || !S_ISDIR(sb.st_mode)) {
-		if (argc > 2)
-			errx(1, "%s is not a directory", argv[argc - 1]);
+	if (stat(target, &sb) || !S_ISDIR(sb.st_mode)) {
+		if (argc > 2 || targdir)
+			errx(1, "%s is not a directory", target);
 		exit(do_move(argv[0], argv[1]));
 	}
+	/* when -T is specified and target is a directory, error */
+	if (Tflg)
+		errx(1, "%s is a directory", target);
 
 	/*
 	 * If -h was specified, treat the target as a symlink instead of
@@ -138,16 +160,16 @@
 	}
 
 	/* It's a directory, move each file into it. */
-	if (strlen(argv[argc - 1]) > sizeof(path) - 1)
+	if (strlen(target) > sizeof(path) - 1)
 		errx(1, "%s: destination pathname too long", *argv);
-	(void)strcpy(path, argv[argc - 1]);
+	(void)strcpy(path, target);
 	baselen = strlen(path);
 	endp = &path[baselen];
 	if (!baselen || *(endp - 1) != '/') {
 		*endp++ = '/';
 		++baselen;
 	}
-	for (rval = 0; --argc; ++argv) {
+	for (rval = 0; targdir ? argc-- : --argc; ++argv) {
 		/*
 		 * Find the last component of the source pathname.  It
 		 * may have trailing slashes.
@@ -176,6 +198,8 @@
 	struct stat sb;
 	int ask, ch, first;
 	char modep[15];
+	struct passwd *pw = NULL;
+	struct group *gr = NULL;
 
 	/*
 	 * Check access.  If interactive and file exists, ask user if it
@@ -201,10 +225,15 @@
 			ask = 1;
 		} else if (access(to, W_OK) && !stat(to, &sb) && isatty(STDIN_FILENO)) {
 			strmode(sb.st_mode, modep);
+			pw = getpwuid(sb.st_uid);
+			if (pw == NULL)
+				err(EXIT_FAILURE, "getpwuid");
+			gr = getgrgid(sb.st_gid);
+			if (gr == NULL)
+				err(EXIT_FAILURE, "getgrgid");
 			(void)fprintf(stderr, "override %s%s%s/%s for %s? %s",
 			    modep + 1, modep[9] == ' ' ? "" : " ",
-			    user_from_uid((unsigned long)sb.st_uid, 0),
-			    group_from_gid((unsigned long)sb.st_gid, 0), to, YESNO);
+			    pw->pw_name, gr->gr_name, to, YESNO);
 			ask = 1;
 		}
 		if (ask) {
@@ -229,7 +258,6 @@
 	}
 
 	if (errno == EXDEV) {
-		struct statfs sfs;
 		char path[PATH_MAX];
 
 		/*
@@ -246,11 +274,6 @@
 				warn("cannot resolve %s: %s", from, path);
 				return (1);
 			}
-			if (!statfs(path, &sfs) &&
-			    !strcmp(path, sfs.f_mntonname)) {
-				warnx("cannot rename a mount point");
-				return (1);
-			}
 		}
 	} else {
 		warn("rename %s to %s", from, to);
@@ -278,7 +301,6 @@
 	static char *bp = NULL;
 	mode_t oldmode;
 	int nread, from_fd, to_fd;
-	struct stat tsb;
 
 	if ((from_fd = open(from, O_RDONLY, 0)) < 0) {
 		warn("fastcopy: open() failed (from): %s", from);
@@ -324,6 +346,7 @@
 	}
 	if (fchmod(to_fd, sbp->st_mode))
 		warn("%s: set mode (was: 0%03o)", to, oldmode);
+	preserve_fd_xattrs(from_fd, to_fd, from, to);
 	/*
 	 * POSIX 1003.2c states that if _POSIX_ACL_EXTENDED is in effect
 	 * for dest_file, then its ACLs shall reflect the ACLs of the
@@ -344,6 +367,7 @@
 	 * if the server supports flags and we were trying to *remove* flags
 	 * on a file that we copied, i.e., that we didn't create.)
 	 */
+#if 0
 	if (fstat(to_fd, &tsb) == 0) {
 		if ((sbp->st_flags  & ~UF_ARCHIVE) !=
 		    (tsb.st_flags & ~UF_ARCHIVE)) {
@@ -356,7 +380,7 @@
 		}
 	} else
 		warn("%s: cannot stat", to);
-
+#endif
 	if (close(to_fd)) {
 		warn("%s", to);
 		return (1);
@@ -454,9 +478,9 @@
     const char *dest_path)
 {
 	acl_t acl;
-	acl_type_t acl_type;
-	int acl_supported = 0, ret, trivial;
+	int acl_supported = 0, ret;
 
+#if 0
 	ret = fpathconf(source_fd, _PC_ACL_NFS4);
 	if (ret > 0 ) {
 		acl_supported = 1;
@@ -466,13 +490,13 @@
 		    source_path);
 		return;
 	}
+#endif
 	if (acl_supported == 0) {
-		ret = fpathconf(source_fd, _PC_ACL_EXTENDED);
+		ret = acl_extended_fd(source_fd);
 		if (ret > 0 ) {
 			acl_supported = 1;
-			acl_type = ACL_TYPE_ACCESS;
-		} else if (ret < 0 && errno != EINVAL) {
-			warn("fpathconf(..., _PC_ACL_EXTENDED) failed for %s",
+		} else if (ret < 0 && errno != ENOTSUP) {
+			warn("acl_extended_fd() failed for %s",
 			    source_path);
 			return;
 		}
@@ -480,21 +504,12 @@
 	if (acl_supported == 0)
 		return;
 
-	acl = acl_get_fd_np(source_fd, acl_type);
+	acl = acl_get_fd(source_fd);
 	if (acl == NULL) {
 		warn("failed to get acl entries for %s", source_path);
 		return;
 	}
-	if (acl_is_trivial_np(acl, &trivial)) {
-		warn("acl_is_trivial() failed for %s", source_path);
-		acl_free(acl);
-		return;
-	}
-	if (trivial) {
-		acl_free(acl);
-		return;
-	}
-	if (acl_set_fd_np(dest_fd, acl, acl_type) < 0) {
+	if (acl_set_fd(dest_fd, acl) < 0) {
 		warn("failed to set acl entries for %s", dest_path);
 		acl_free(acl);
 		return;
@@ -503,11 +518,75 @@
 }
 
 static void
+preserve_fd_xattrs(int source_fd, int dest_fd, const char *source_path,
+    const char *dest_path)
+{
+    ssize_t size;
+    char buf[256], vbuf[128];
+    char *names, *name, *nend;
+    char *value = vbuf;
+    size_t vbufs = sizeof(vbuf);
+
+    size = flistxattr(source_fd, NULL, 0);
+    if (size < 0) {
+        if (errno != ENOTSUP) warn("failed to get xattrs for %s", source_path);
+        return;
+    }
+
+    if (size < (ssize_t)sizeof(buf)) {
+        names = buf;
+    } else {
+        names = malloc(size + 1);
+        if (!names) err(1, "Not enough memory");
+    }
+
+    size = flistxattr(source_fd, names, size);
+    if (size < 0) {
+        if (errno != ENOTSUP) warn("failed to get xattrs for %s", source_path);
+        if (names != buf) free(names);
+        return;
+    }
+    names[size] = '\0';
+    nend = names + size;
+
+    for (name = names; name != nend; name = strchr(name, '\0') + 1) {
+        size = fgetxattr(source_fd, name, NULL, 0);
+        if (size < 0) {
+            if (errno != ENOTSUP)
+                warn("failed to get xattr %s for %s", name, source_path);
+            continue;
+        }
+        if (size > (ssize_t)vbufs) {
+            if (value == vbuf) value = NULL;
+            value = realloc(value, size);
+            if (!value) {
+                err(1, "Not enough memory");
+            }
+            vbufs = size;
+        }
+        size = fgetxattr(source_fd, name, value, size);
+        if (size < 0) {
+            if (errno != ENOTSUP)
+                warn("failed to get xattr %s for %s", name, source_path);
+            continue;
+        }
+        if (fsetxattr(dest_fd, name, value, size, 0)) {
+            if (errno != ENOTSUP)
+                warn("failed to set xattr %s for %s", name, dest_path);
+        }
+    }
+
+    if (names != buf) free(names);
+    if (value != vbuf) free(value);
+}
+
+static void
 usage(void)
 {
 
-	(void)fprintf(stderr, "%s\n%s\n",
-		      "usage: mv [-f | -i | -n] [-hv] source target",
-		      "       mv [-f | -i | -n] [-v] source ... directory");
+	(void)fprintf(stderr, "%s\n%s\n%s\n",
+		      "usage: mv [-f | -i | -n] [-hvT] source target",
+		      "       mv [-f | -i | -n] [-v] source ... directory",
+		      "       mv [-f | -i | -n] [-v] -t directory source ...");
 	exit(EX_USAGE);
 }
--- src.orig/coreutils/nproc/nproc.c
+++ src.freebsd/coreutils/nproc/nproc.c
@@ -14,7 +14,6 @@
  */
 
 #include <sys/param.h>
-#include <sys/cpuset.h>
 
 #include <err.h>
 #include <errno.h>
@@ -25,6 +24,8 @@
 #include <stdlib.h>
 #include <sysexits.h>
 #include <unistd.h>
+#include <pthread.h>
+#include <sched.h>
 
 #define OPT_ALL		(CHAR_MAX + 1)
 #define OPT_IGNORE	(CHAR_MAX + 2)
@@ -75,7 +76,7 @@
 main(int argc, char *argv[])
 {
 	const char *errstr;
-	cpuset_t mask;
+	cpu_set_t mask;
 	int ch, cpus, ignore;
 	bool all_flag;
 
@@ -115,9 +116,8 @@
 			err(1, "sysconf");
 	} else {
 		CPU_ZERO(&mask);
-		if (cpuset_getaffinity(CPU_LEVEL_WHICH, CPU_WHICH_TID, -1,
-		    sizeof(mask), &mask) != 0)
-			err(1, "cpuset_getaffinity");
+		if (pthread_getaffinity_np(pthread_self(), sizeof(cpu_set_t), &mask) != 0)
+			err(1, "pthread_geteaffinity_np");
 		cpus = CPU_COUNT(&mask);
 	}
 
--- src.orig/coreutils/pr/pr.c
+++ src.freebsd/coreutils/pr/pr.c
@@ -63,6 +63,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <time_bsd.h>
 
 #include "pr.h"
 #include "extern.h"
@@ -1399,7 +1400,7 @@
 	/*
 	 * set up time field used in header
 	 */
-	if (strftime(buf, HDBUF, timefrmt, timeptr) <= 0) {
+	if (strftime_bsd(buf, HDBUF, timefrmt, timeptr) <= 0) {
 		++errcnt;
 		if (inf != stdin)
 			(void)fclose(inf);
@@ -1855,7 +1856,9 @@
 
 	(void) setlocale(LC_TIME, (Lflag != NULL) ? Lflag : "");
 
-	d_first = (*nl_langinfo(D_MD_ORDER) == 'd');
+	d_first = 0;
+	if (strlen(nl_langinfo(D_FMT)) >= 2 && nl_langinfo(D_FMT)[1] == 'd')
+		d_first = 1;
 	timefrmt = strdup(d_first ? TIMEFMTD : TIMEFMTM);
 
 	return(0);
--- src.orig/coreutils/printf/printf.1
+++ src.freebsd/coreutils/printf/printf.1
@@ -96,6 +96,14 @@
 Write a <tab> character.
 .It Cm \ev
 Write a <vertical tab> character.
+.It Cm \ex Ns Ar num
+Write a byte whose
+value is the 1- or 2-digit
+hexadecimal number
+.Ar num .
+Multibyte characters can be constructed using multiple
+.Cm \ex Ns Ar num
+sequences.
 .It Cm \e\'
 Write a <single quote> character.
 .It Cm \e\e
--- src.orig/coreutils/printf/printf.c
+++ src.freebsd/coreutils/printf/printf.c
@@ -520,6 +520,24 @@
 		case 'v':		/* vertical tab */
 			*store = '\v';
 			break;
+		case 'x':		/* hexadecimal constant */
+			if (!percent) {
+				*store = 'x';
+				break;
+			}
+			c = 2;
+			++fmt;
+			for (value = 0; c-- && (
+				(*fmt >= '0' && *fmt <= '9') ||
+				((*fmt|32) >= 'a' && (*fmt|32) <= 'f')
+			); ++fmt) {
+				value <<= 4;
+				value += ((*fmt|32) >= 'a')
+					? (10 + (*fmt|32) - 'a') : (*fmt - '0');
+			}
+			--fmt;
+			*store = (char)value;
+			break;
 					/* octal constant */
 		case '0': case '1': case '2': case '3':
 		case '4': case '5': case '6': case '7':
--- src.orig/coreutils/rm/rm.1
+++ src.freebsd/coreutils/rm/rm.1
@@ -41,7 +41,7 @@
 .Sh SYNOPSIS
 .Nm
 .Op Fl f | i
-.Op Fl dIRrvWx
+.Op Fl dIRrvx
 .Ar
 .Nm unlink
 .Op Fl -
@@ -109,11 +109,6 @@
 .Fl R .
 .It Fl v
 Be verbose when deleting files, showing them as they are removed.
-.It Fl W
-Attempt to undelete the named files.
-Currently, this option can only be used to recover
-files covered by whiteouts in a union file system (see
-.Xr undelete 2 ) .
 .It Fl x
 When removing a hierarchy, do not cross mount points.
 .El
@@ -210,9 +205,7 @@
 .Fx 13
 and may be removed in the future.
 .Sh SEE ALSO
-.Xr chflags 1 ,
 .Xr rmdir 1 ,
-.Xr undelete 2 ,
 .Xr unlink 2 ,
 .Xr fts 3 ,
 .Xr getopt 3 ,
--- src.orig/coreutils/rm/rm.c
+++ src.freebsd/coreutils/rm/rm.c
@@ -52,13 +52,14 @@
 #include <grp.h>
 #include <locale.h>
 #include <pwd.h>
+#include <signal.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <sysexits.h>
 #include <unistd.h>
 
-static int dflag, eval, fflag, iflag, vflag, Wflag, stdin_ok;
+static int dflag, eval, fflag, iflag, vflag, stdin_ok;
 static int rflag, Iflag, xflag;
 static uid_t uid;
 static volatile sig_atomic_t info;
@@ -107,7 +108,7 @@
 	}
 
 	rflag = xflag = 0;
-	while ((ch = getopt(argc, argv, "dfiIPRrvWx")) != -1)
+	while ((ch = getopt(argc, argv, "dfiIPRrvx")) != -1)
 		switch(ch) {
 		case 'd':
 			dflag = 1;
@@ -133,9 +134,6 @@
 		case 'v':
 			vflag = 1;
 			break;
-		case 'W':
-			Wflag = 1;
-			break;
 		case 'x':
 			xflag = 1;
 			break;
@@ -196,8 +194,6 @@
 	flags = FTS_PHYSICAL;
 	if (!needstat)
 		flags |= FTS_NOSTAT;
-	if (Wflag)
-		flags |= FTS_WHITEOUT;
 	if (xflag)
 		flags |= FTS_XDEV;
 	if (!(fts = fts_open(argv, flags, NULL))) {
@@ -236,12 +232,6 @@
 				(void)fts_set(fts, p, FTS_SKIP);
 				p->fts_number = SKIPPED;
 			}
-			else if (!uid &&
-				 (p->fts_statp->st_flags & (UF_APPEND|UF_IMMUTABLE)) &&
-				 !(p->fts_statp->st_flags & (SF_APPEND|SF_IMMUTABLE)) &&
-				 lchflags(p->fts_accpath,
-					 p->fts_statp->st_flags &= ~(UF_APPEND|UF_IMMUTABLE)) < 0)
-				goto err;
 			continue;
 		case FTS_DP:
 			/* Post-order: see if user skipped. */
@@ -255,11 +245,13 @@
 		}
 
 		rval = 0;
+#if 0
 		if (!uid &&
 		    (p->fts_statp->st_flags & (UF_APPEND|UF_IMMUTABLE)) &&
 		    !(p->fts_statp->st_flags & (SF_APPEND|SF_IMMUTABLE)))
 			rval = lchflags(p->fts_accpath,
 				       p->fts_statp->st_flags &= ~(UF_APPEND|UF_IMMUTABLE));
+#endif
 		if (rval == 0) {
 			/*
 			 * If we can't read or search the directory, may still be
@@ -282,7 +274,7 @@
 					continue;
 				}
 				break;
-
+#if 0
 			case FTS_W:
 				rval = undelete(p->fts_accpath);
 				if (rval == 0 && (fflag && errno == ENOENT)) {
@@ -297,7 +289,7 @@
 					continue;
 				}
 				break;
-
+#endif
 			case FTS_NS:
 				/*
 				 * Assume that since fts_read() couldn't stat
@@ -306,7 +298,6 @@
 				if (fflag)
 					continue;
 				/* FALLTHROUGH */
-
 			case FTS_F:
 			case FTS_NSOK:
 			default:
@@ -324,7 +315,6 @@
 				}
 			}
 		}
-err:
 		warn("%s", p->fts_path);
 		eval = 1;
 	}
@@ -347,18 +337,10 @@
 	while ((f = *argv++) != NULL) {
 		/* Assume if can't stat the file, can't unlink it. */
 		if (lstat(f, &sb)) {
-			if (Wflag) {
-				sb.st_mode = S_IFWHT|S_IWUSR|S_IRUSR;
-			} else {
-				if (!fflag || errno != ENOENT) {
-					warn("%s", f);
-					eval = 1;
-				}
-				continue;
+			if (!fflag || errno != ENOENT) {
+				warn("%s", f);
+				eval = 1;
 			}
-		} else if (Wflag) {
-			warnx("%s: %s", f, strerror(EEXIST));
-			eval = 1;
 			continue;
 		}
 
@@ -367,21 +349,12 @@
 			eval = 1;
 			continue;
 		}
-		if (!fflag && !S_ISWHT(sb.st_mode) && !check(f, f, &sb))
+		if (!fflag && !check(f, f, &sb))
 			continue;
-		rval = 0;
-		if (!uid && !S_ISWHT(sb.st_mode) &&
-		    (sb.st_flags & (UF_APPEND|UF_IMMUTABLE)) &&
-		    !(sb.st_flags & (SF_APPEND|SF_IMMUTABLE)))
-			rval = lchflags(f, sb.st_flags & ~(UF_APPEND|UF_IMMUTABLE));
-		if (rval == 0) {
-			if (S_ISWHT(sb.st_mode))
-				rval = undelete(f);
-			else if (S_ISDIR(sb.st_mode))
-				rval = rmdir(f);
-			else
-				rval = unlink(f);
-		}
+		if (S_ISDIR(sb.st_mode))
+			rval = rmdir(f);
+		else
+			rval = unlink(f);
 		if (rval && (!fflag || errno != ENOENT)) {
 			warn("%s", f);
 			eval = 1;
@@ -399,7 +372,9 @@
 check(const char *path, const char *name, struct stat *sp)
 {
 	int ch, first;
-	char modep[15], *flagsp;
+	char modep[15];
+	struct passwd *pw = NULL;
+	struct group *gr = NULL;
 
 	/* Check -i first. */
 	if (iflag)
@@ -411,21 +386,20 @@
 		 * because their permissions are meaningless.  Check stdin_ok
 		 * first because we may not have stat'ed the file.
 		 */
-		if (!stdin_ok || S_ISLNK(sp->st_mode) ||
-		    (!access(name, W_OK) &&
-		    !(sp->st_flags & (SF_APPEND|SF_IMMUTABLE)) &&
-		    (!(sp->st_flags & (UF_APPEND|UF_IMMUTABLE)) || !uid)))
+		if (!stdin_ok || S_ISLNK(sp->st_mode) || !access(name, W_OK))
 			return (1);
 		strmode(sp->st_mode, modep);
-		if ((flagsp = fflagstostr(sp->st_flags)) == NULL)
-			err(1, "fflagstostr");
-		(void)fprintf(stderr, "override %s%s%s/%s %s%sfor %s? ",
+		pw = getpwuid(sp->st_uid);
+		if (pw == NULL)
+			err(EXIT_FAILURE, "getpwuid");
+		gr = getgrgid(sp->st_gid);
+		if (gr == NULL)
+			err(EXIT_FAILURE, "getgrgid");
+		(void)fprintf(stderr, "override %s%s%s/%s for %s? ",
 		    modep + 1, modep[10] == ' ' ? "" : " ",
-		    user_from_uid(sp->st_uid, 0),
-		    group_from_gid(sp->st_gid, 0),
-		    *flagsp ? flagsp : "", *flagsp ? " " : "",
+		    pw->pw_name,
+		    gr->gr_name,
 		    path);
-		free(flagsp);
 	}
 	(void)fflush(stderr);
 
--- src.orig/coreutils/seq/seq.1
+++ src.freebsd/coreutils/seq/seq.1
@@ -95,7 +95,10 @@
 defined in
 .St -ansiC .
 The default is
-.Cm %g .
+.Cm %g ,
+unless all numbers are integers representable losslessly as floating
+point (with mantissa bits), in which case the default is
+.Cm %.0f .
 .It Fl s Ar string , Fl -separator Ar string
 Use
 .Ar string
--- src.orig/coreutils/seq/seq.c
+++ src.freebsd/coreutils/seq/seq.c
@@ -36,6 +36,7 @@
 #include <errno.h>
 #include <getopt.h>
 #include <math.h>
+#include <float.h>
 #include <locale.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -49,12 +50,17 @@
 #define ISSIGN(c)	((int)(c) == '-' || (int)(c) == '+')
 #define ISEXP(c)	((int)(c) == 'e' || (int)(c) == 'E')
 #define ISODIGIT(c)	((int)(c) >= '0' && (int)(c) <= '7')
+#define VALID_INT(v)	(floor(v) == (v) && fabs(v) <= abs_int_max)
 
 /* Globals */
 
 static const char *decimal_point = ".";	/* default */
 static char default_format[] = { "%g" };	/* default */
+static char integer_format[] = { "%.0f" };	/* for integer printing */
 
+/* largest representable integer in a double */
+static const double abs_int_max = (double)(1ULL << DBL_MANT_DIG);
+
 static const struct option long_opts[] = {
 	{"format",	required_argument,	NULL, 'f'},
 	{"separator",	required_argument,	NULL, 's'},
@@ -71,7 +77,7 @@
 static int numeric(const char *);
 static int valid_format(const char *);
 
-static char *generate_format(double, double, double, int, char);
+static char *generate_format(double, double, double, int, char, int *);
 static char *unescape(char *);
 
 /*
@@ -87,7 +93,7 @@
 	struct lconv *locale;
 	char pad, *fmt, *cur_print, *last_print, *prev_print;
 	double first, last, incr, prev, cur, step;
-	int c, errflg, equalize;
+	int c, errflg, equalize, may_trunc = 1;
 
 	pad = ZERO;
 	fmt = NULL;
@@ -177,7 +183,7 @@
 		 * newline if none found at the end of the format string.
 		 */
 	} else
-		fmt = generate_format(first, incr, last, equalize, pad);
+		fmt = generate_format(first, incr, last, equalize, pad, &may_trunc);
 
 	for (step = 1, cur = first; incr > 0 ? cur <= last : cur >= last;
 	    cur = first + incr * step++) {
@@ -187,6 +193,13 @@
 	}
 
 	/*
+	 * If we guarantee no truncation (which happens when only integers are
+	 * used), skip the code below in order to avoid extra allocations.
+	 */
+	if (!may_trunc)
+		goto do_term;
+
+	/*
 	 * Did we miss the last value of the range in the loop above?
 	 *
 	 * We might have, so check if the printable version of the last
@@ -209,6 +222,7 @@
 	free(last_print);
 	free(prev_print);
 
+do_term:
 	if (term != NULL)
 		fputs(term, stdout);
 
@@ -456,27 +470,36 @@
  * when "%g" prints as "%e" (this way no width adjustments are made)
  */
 static char *
-generate_format(double first, double incr, double last, int equalize, char pad)
+generate_format(double first, double incr, double last, int equalize, char pad, int *may_trunc)
 {
 	static char buf[256];
 	char cc = '\0';
 	int precision, width1, width2, places;
+	int do_ints = 0;
+	char *def_fmt;
 
-	if (equalize == 0)
-		return (default_format);
-
 	/* figure out "last" value printed */
 	if (first > last)
 		last = first - incr * floor((first - last) / incr);
 	else
 		last = first + incr * floor((last - first) / incr);
 
-	sprintf(buf, "%g", incr);
+	do_ints = VALID_INT(first) && VALID_INT(last) && VALID_INT(incr);
+	if (do_ints) {
+		*may_trunc = 0;
+		def_fmt = (integer_format);
+	} else
+		def_fmt = (default_format);
+
+	if (equalize == 0)
+		return def_fmt;
+
+	sprintf(buf, def_fmt, incr);
 	if (strchr(buf, 'e'))
 		cc = 'e';
 	precision = decimal_places(buf);
 
-	width1 = sprintf(buf, "%g", first);
+	width1 = sprintf(buf, def_fmt, first);
 	if (strchr(buf, 'e'))
 		cc = 'e';
 	if ((places = decimal_places(buf)))
@@ -484,7 +507,7 @@
 
 	precision = MAX(places, precision);
 
-	width2 = sprintf(buf, "%g", last);
+	width2 = sprintf(buf, def_fmt, last);
 	if (strchr(buf, 'e'))
 		cc = 'e';
 	if ((places = decimal_places(buf)))
@@ -494,6 +517,8 @@
 		sprintf(buf, "%%%c%d.%d%c", pad,
 		    MAX(width1, width2) + (int) strlen(decimal_point) +
 		    precision, precision, (cc) ? cc : 'f');
+	} else if (do_ints) {
+		sprintf(buf, "%%%c%d.0f", pad, MAX(width1, width2));
 	} else {
 		sprintf(buf, "%%%c%d%c", pad, MAX(width1, width2),
 		    (cc) ? cc : 'g');
--- src.orig/coreutils/sleep/sleep.1
+++ src.freebsd/coreutils/sleep/sleep.1
@@ -60,7 +60,7 @@
 .Nm
 command receives a signal, it takes the standard action.
 When the
-.Dv SIGINFO
+.Dv SIGUSR1
 signal is received, the estimate of the amount of seconds left to
 sleep is printed on the standard output.
 .Sh IMPLEMENTATION NOTES
--- src.orig/coreutils/sort/coll.c
+++ src.freebsd/coreutils/sort/coll.c
@@ -35,7 +35,9 @@
 #include <langinfo.h>
 #include <limits.h>
 #include <math.h>
+#ifndef WITHOUT_LIBCRYPTO
 #include <md5.h>
+#endif
 #include <stdlib.h>
 #include <string.h>
 #include <wchar.h>
@@ -58,7 +60,9 @@
 static int monthcoll(struct key_value*, struct key_value *, size_t offset);
 static int numcoll(struct key_value*, struct key_value *, size_t offset);
 static int hnumcoll(struct key_value*, struct key_value *, size_t offset);
+#ifndef WITHOUT_LIBCRYPTO
 static int randomcoll(struct key_value*, struct key_value *, size_t offset);
+#endif
 static int versioncoll(struct key_value*, struct key_value *, size_t offset);
 
 /*
@@ -469,8 +473,10 @@
 		return (gnumcoll);
 	else if (sm->Mflag)
 		return (monthcoll);
+#ifndef WITHOUT_LIBCRYPTO
 	else if (sm->Rflag)
 		return (randomcoll);
+#endif
 	else if (sm->Vflag)
 		return (versioncoll);
 	else
@@ -603,18 +609,18 @@
  * Compare two sort list items, according to the sort specs.
  */
 int
-list_coll(struct sort_list_item **ss1, struct sort_list_item **ss2)
+list_coll(const void *ss1, const void *ss2)
 {
 
-	return (list_coll_offset(ss1, ss2, 0));
+	return (list_coll_offset((struct sort_list_item **)ss1, (struct sort_list_item **)ss2, 0));
 }
 
 #define	LSCDEF(N)							\
 static int 								\
-list_coll_##N(struct sort_list_item **ss1, struct sort_list_item **ss2)	\
+list_coll_##N(const void *ss1, const void *ss2)	\
 {									\
 									\
-	return (list_coll_offset(ss1, ss2, N));				\
+	return (list_coll_offset((struct sort_list_item **)ss1, (struct sort_list_item **)ss2, N)); \
 }
 
 LSCDEF(1)
@@ -658,9 +664,10 @@
  * Compare two sort list items, only by their original string.
  */
 int
-list_coll_by_str_only(struct sort_list_item **ss1, struct sort_list_item **ss2)
+list_coll_by_str_only(const void *a1, const void *a2)
 {
-
+	struct sort_list_item **ss1 = (struct sort_list_item **)a1;
+	struct sort_list_item **ss2 = (struct sort_list_item **)a2;
 	return (top_level_str_coll(((*ss1)->str), ((*ss2)->str)));
 }
 
@@ -977,6 +984,7 @@
 	return (numcoll_impl(kv1, kv2, offset, true));
 }
 
+#ifndef WITHOUT_LIBCRYPTO
 /* Use hint space to memoize md5 computations, at least. */
 static void
 randomcoll_init_hint(struct key_value *kv, void *hash)
@@ -1017,8 +1025,13 @@
 			return (cmp);
 	}
 
-	memcpy(&ctx1, &md5_ctx, sizeof(MD5_CTX));
-	memcpy(&ctx2, &md5_ctx, sizeof(MD5_CTX));
+	MD5Init(&ctx1);
+	MD5Init(&ctx2);
+	
+	if (!EVP_MD_CTX_copy_ex(ctx1, md5_ctx))
+		errx(1, "could not copy digest");
+	if (!EVP_MD_CTX_copy_ex(ctx2, md5_ctx))
+		errx(1, "could not copy digest");
 
 	MD5Update(&ctx1, bwsrawdata(s1), bwsrawlen(s1));
 	MD5Update(&ctx2, bwsrawdata(s2), bwsrawlen(s2));
@@ -1033,6 +1046,7 @@
 
 	return (memcmp(hash1, hash2, sizeof(hash1)));
 }
+#endif /* WITHOUT_LIBCRYPTO */
 
 /*
  * Implements version sort (-V).
--- src.orig/coreutils/sort/coll.h
+++ src.freebsd/coreutils/sort/coll.h
@@ -104,7 +104,7 @@
 {
 	struct bwstring		*k; /* key string */
 	struct key_hint		 hint[0]; /* key sort hint */
-} __packed;
+} __attribute__((packed));
 
 /*
  * Set of keys container object.
@@ -140,7 +140,7 @@
 /*
  * Function type, used to compare two list objects
  */
-typedef int (*listcoll_t)(struct sort_list_item **ss1, struct sort_list_item **ss2);
+typedef int (*listcoll_t)(const void *ss1, const void *ss2);
 
 extern struct key_specs *keys;
 extern size_t keys_num;
@@ -172,8 +172,8 @@
 int top_level_str_coll(const struct bwstring *, const struct bwstring *);
 int key_coll(struct keys_array *ks1, struct keys_array *ks2, size_t offset);
 int str_list_coll(struct bwstring *str1, struct sort_list_item **ss2);
-int list_coll_by_str_only(struct sort_list_item **ss1, struct sort_list_item **ss2);
-int list_coll(struct sort_list_item **ss1, struct sort_list_item **ss2);
+int list_coll_by_str_only(const void *ss1, const void *ss2);
+int list_coll(const void *ss1, const void *ss2);
 int list_coll_offset(struct sort_list_item **ss1, struct sort_list_item **ss2, size_t offset);
 
 listcoll_t get_list_call_func(size_t offset);
--- src.orig/coreutils/sort/file.c
+++ src.freebsd/coreutils/sort/file.c
@@ -37,6 +37,7 @@
 #include <fcntl.h>
 #if defined(SORT_THREADS)
 #include <pthread.h>
+#include <sched.h>
 #endif
 #include <semaphore.h>
 #include <stdio.h>
@@ -190,7 +191,7 @@
 
 	if (asprintf(&ret, "%s/.bsdsort.XXXXXXXXXX", tmpdir) == -1)
 		err(2, "asprintf()");
-	if ((fd = mkstemp(ret)) == -1)
+	if ((fd = compat_mkstemp(ret)) == -1)
 		err(2, "mkstemp()");
 	close(fd);
 
@@ -609,7 +610,7 @@
 			size_t sz = 0;
 			int fd, flags;
 
-			flags = MAP_NOCORE | MAP_NOSYNC;
+			flags = MAP_PRIVATE;
 
 			fd = open(fsrc, O_RDONLY);
 			if (fd < 0)
@@ -631,6 +632,7 @@
 				close(fd);
 				break;
 			}
+			madvise(addr, sz, MADV_DONTDUMP);
 
 			ret->fd = fd;
 			ret->mmapaddr = addr;
@@ -687,7 +689,7 @@
 		}
 		if (len > 0 && fr->buffer[len - 1] == fr->elsymb)
 			len--;
-		ret = bwscsbdup(fr->buffer, len);
+		ret = bwscsbdup((unsigned char *)fr->buffer, len);
 	}
 
 	return (ret);
@@ -1449,7 +1451,7 @@
 			pthread_attr_t attr;
 
 			pthread_attr_init(&attr);
-			pthread_attr_setdetachstate(&attr, PTHREAD_DETACHED);
+			pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
 
 			for (;;) {
 				int res = pthread_create(&pth, &attr,
@@ -1458,7 +1460,7 @@
 				if (res >= 0)
 					break;
 				if (errno == EAGAIN) {
-					pthread_yield();
+					sched_yield();
 					continue;
 				}
 				err(2, NULL);
--- src.orig/coreutils/sort/radixsort.c
+++ src.freebsd/coreutils/sort/radixsort.c
@@ -35,6 +35,7 @@
 #if defined(SORT_THREADS)
 #include <pthread.h>
 #include <semaphore.h>
+#include <sched.h>
 #endif
 #include <stdlib.h>
 #include <string.h>
@@ -642,7 +643,7 @@
 			pthread_t pth;
 
 			pthread_attr_init(&attr);
-			pthread_attr_setdetachstate(&attr, PTHREAD_DETACHED);
+			pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
 
 			for (;;) {
 				int res = pthread_create(&pth, &attr,
@@ -650,7 +651,7 @@
 				if (res >= 0)
 					break;
 				if (errno == EAGAIN) {
-					pthread_yield();
+					sched_yield();
 					continue;
 				}
 				err(2, NULL);
@@ -679,7 +680,9 @@
 		pthread_mutexattr_t mattr;
 
 		pthread_mutexattr_init(&mattr);
+#ifdef PTHREAD_MUTEX_ADAPTIVE_NP
 		pthread_mutexattr_settype(&mattr, PTHREAD_MUTEX_ADAPTIVE_NP);
+#endif
 
 		pthread_mutex_init(&g_ls_mutex, &mattr);
 		pthread_cond_init(&g_ls_cond, NULL);
--- src.orig/coreutils/sort/sort.1
+++ src.freebsd/coreutils/sort/sort.1
@@ -325,9 +325,9 @@
 .It Fl Fl debug
 Print some extra information about the sorting process to the
 standard output.
-%%THREADS%%.It Fl Fl parallel
-%%THREADS%%Set the maximum number of execution threads.
-%%THREADS%%Default number equals to the number of CPUs.
+.It Fl Fl parallel
+Set the maximum number of execution threads.
+Default number equals to the number of CPUs.
 .It Fl Fl files0-from Ns = Ns Ar filename
 Take the input file list from the file
 .Ar filename .
--- src.orig/coreutils/sort/sort.c
+++ src.freebsd/coreutils/sort/sort.c
@@ -29,7 +29,6 @@
 
 #include <sys/cdefs.h>
 #include <sys/stat.h>
-#include <sys/sysctl.h>
 #include <sys/types.h>
 
 #include <err.h>
@@ -38,7 +37,9 @@
 #include <getopt.h>
 #include <limits.h>
 #include <locale.h>
+#ifndef WITHOUT_LIBCRYPTO
 #include <md5.h>
+#endif
 #include <regex.h>
 #include <signal.h>
 #include <stdbool.h>
@@ -55,9 +56,11 @@
 
 #define	OPTIONS	"bcCdfghik:Mmno:RrsS:t:T:uVz"
 
+#ifndef WITHOUT_LIBCRYPTO
 static bool need_random;
 
 MD5_CTX md5_ctx;
+#endif
 
 /*
  * Default messages to use
@@ -83,7 +86,11 @@
       "[--parallel thread_no] "
 #endif
       "[--human-numeric-sort] "
+#ifndef WITHOUT_LIBCRYPTO
+      "[--version-sort]] "
+#else
       "[--version-sort] [--random-sort [--random-source file]] "
+#endif
       "[--compress-program program] [file ...]\n" };
 
 struct sort_opts sort_opts_vals;
@@ -125,7 +132,9 @@
 #if defined(SORT_THREADS)
 	PARALLEL_OPT,
 #endif
+#ifndef WITHOUT_LIBCRYPTO
 	RANDOMSOURCE_OPT,
+#endif
 	COMPRESSPROGRAM_OPT,
 	QSORT_OPT,
 	MERGESORT_OPT,
@@ -166,8 +175,10 @@
 #endif
 				{ "qsort", no_argument, NULL, QSORT_OPT },
 				{ "radixsort", no_argument, NULL, RADIXSORT_OPT },
+#ifndef WITHOUT_LIBCRYPTO
 				{ "random-sort", no_argument, NULL, 'R' },
 				{ "random-source", required_argument, NULL, RANDOMSOURCE_OPT },
+#endif
 				{ "reverse", no_argument, NULL, 'r' },
 				{ "sort", required_argument, NULL, SORT_OPT },
 				{ "stable", no_argument, NULL, 's' },
@@ -321,16 +332,24 @@
 	lc = localeconv();
 
 	if (lc) {
+		wchar_t sym_decimal_point;
+		wchar_t sym_thousands_sep;
+		wchar_t sym_positive_sign;
+		wchar_t sym_negative_sign;
 		/* obtain LC_NUMERIC info */
 		/* Convert to wide char form */
-		conv_mbtowc(&symbol_decimal_point, lc->decimal_point,
+		conv_mbtowc(&sym_decimal_point, lc->decimal_point,
 		    symbol_decimal_point);
-		conv_mbtowc(&symbol_thousands_sep, lc->thousands_sep,
+		conv_mbtowc(&sym_thousands_sep, lc->thousands_sep,
 		    symbol_thousands_sep);
-		conv_mbtowc(&symbol_positive_sign, lc->positive_sign,
+		conv_mbtowc(&sym_positive_sign, lc->positive_sign,
 		    symbol_positive_sign);
-		conv_mbtowc(&symbol_negative_sign, lc->negative_sign,
+		conv_mbtowc(&sym_negative_sign, lc->negative_sign,
 		    symbol_negative_sign);
+		symbol_decimal_point = sym_decimal_point;
+		symbol_thousands_sep = sym_thousands_sep;
+		symbol_positive_sign = sym_positive_sign;
+		symbol_negative_sign = sym_negative_sign;
 	}
 
 	if (getenv("GNUSORT_NUMERIC_COMPATIBILITY"))
@@ -577,11 +596,13 @@
 	case 'i':
 		sm->iflag = true;
 		break;
+#ifndef WITHOUT_LIBCRYPTO
 	case 'R':
 		sm->Rflag = true;
 		need_hint = true;
 		need_random = true;
 		break;
+#endif
 	case 'M':
 		initialise_months();
 		sm->Mflag = true;
@@ -847,7 +868,7 @@
 void
 fix_obsolete_keys(int *argc, char **argv)
 {
-	char sopt[129];
+	char sopt[304];
 
 	for (int i = 1; i < *argc; i++) {
 		char *arg1;
@@ -903,6 +924,7 @@
 	}
 }
 
+#ifndef WITHOUT_LIBCRYPTO
 /*
  * Seed random sort
  */
@@ -975,6 +997,7 @@
 	MD5Init(&md5_ctx);
 	MD5Update(&md5_ctx, randseed, rd);
 }
+#endif /* WITHOUT_LIBCRYPTO */
 
 /*
  * Main function.
@@ -983,7 +1006,9 @@
 main(int argc, char **argv)
 {
 	char *outfile, *real_outfile;
+#ifndef WITHOUT_LIBCRYPTO
 	char *random_source = NULL;
+#endif
 	int c, result;
 	bool mef_flags[NUMBER_OF_MUTUALLY_EXCLUSIVE_FLAGS] =
 	    { false, false, false, false, false, false };
@@ -1110,8 +1135,10 @@
 						set_sort_modifier(sm, 'n');
 					else if (!strcmp(optarg, "month"))
 						set_sort_modifier(sm, 'M');
+#ifndef WITHOUT_LIBCRYPTO
 					else if (!strcmp(optarg, "random"))
 						set_sort_modifier(sm, 'R');
+#endif
 					else
 						unknown(optarg);
 				}
@@ -1140,9 +1167,11 @@
 			case RADIXSORT_OPT:
 				sort_opts_vals.sort_method = SORT_RADIXSORT;
 				break;
+#ifndef WITHOUT_LIBCRYPTO
 			case RANDOMSOURCE_OPT:
 				random_source = strdup(optarg);
 				break;
+#endif
 			case COMPRESSPROGRAM_OPT:
 				compress_program = strdup(optarg);
 				break;
@@ -1235,8 +1264,10 @@
 		}
 	}
 
+#ifndef WITHOUT_LIBCRYPTO
 	if (need_random)
 		get_random_seed(random_source);
+#endif
 
 	/* Case when the outfile equals one of the input files: */
 	if (strcmp(outfile, "-")) {
--- src.orig/coreutils/sort/sort.h
+++ src.freebsd/coreutils/sort/sort.h
@@ -38,7 +38,9 @@
 #include <wchar.h>
 
 #include <sys/types.h>
+#ifndef WITHOUT_LIBCRYPTO
 #include <md5.h>
+#endif
 
 #define	VERSION	"2.3-FreeBSD"
 
@@ -57,10 +59,12 @@
  */
 extern bool debug_sort;
 
+#ifndef WITHOUT_LIBCRYPTO
 /*
  * MD5 context for random hash function
  */
 extern MD5_CTX md5_ctx;
+#endif
 
 /*
  * sort.c
--- src.orig/coreutils/split/split.c
+++ src.freebsd/coreutils/split/split.c
@@ -60,6 +60,10 @@
 #include <regex.h>
 #include <sysexits.h>
 
+#ifndef REG_STARTEND
+#define REG_STARTEND 0
+#endif
+
 #define DEFLINE	1000			/* Default num lines per file. */
 
 static off_t	 bytecnt;		/* Byte count to split on. */
@@ -87,6 +91,7 @@
 	char errbuf[64];
 	const char *p, *errstr;
 	int ch, error;
+	uint64_t ubytecnt;
 
 	setlocale(LC_ALL, "");
 
@@ -123,10 +128,11 @@
 			}
 			break;
 		case 'b':		/* Byte count. */
-			if (expand_number(optarg, &bytecnt) != 0) {
+			if (expand_number(optarg, &ubytecnt) != 0) {
 				errx(EX_USAGE, "%s: byte count is invalid",
 				    optarg);
 			}
+			bytecnt = ubytecnt;
 			break;
 		case 'c':               /* Continue, don't overwrite output files. */
 			clobber = false;
--- src.orig/coreutils/stat/stat.1
+++ src.freebsd/coreutils/stat/stat.1
@@ -36,7 +36,7 @@
 .Nd display file status
 .Sh SYNOPSIS
 .Nm
-.Op Fl FHLnq
+.Op Fl FLnq
 .Op Fl f Ar format | Fl l | r | s | x
 .Op Fl t Ar timefmt
 .Op Ar
@@ -88,11 +88,9 @@
 .Fa st_atime ,
 .Fa st_mtime ,
 .Fa st_ctime ,
-.Fa st_birthtime ,
 .Fa st_blksize ,
-.Fa st_blocks ,
 and
-.Fa st_flags
+.Fa st_blocks
 fields, in that order.
 .Pp
 The options are as follows:
@@ -122,13 +120,6 @@
 .Fl F
 implies
 .Fl l .
-.It Fl H
-Treat each argument as the hexadecimal representation of an NFS file handle,
-and use
-.Xr fhstat 2
-instead of
-.Xr lstat 2 .
-This requires root privileges.
 .It Fl L
 Use
 .Xr stat 2
@@ -180,7 +171,7 @@
 .It Fl t Ar timefmt
 Display timestamps using the specified format.
 This format is
-passed directly to
+passed directly to FreeBSD
 .Xr strftime 3 .
 .It Fl x
 Display information in a more verbose way as known from some
@@ -266,16 +257,11 @@
 May be used in combination with:
 .Bl -tag -width indent
 .It Cm amc
-Display date in
+Display date in FreeBSD
 .Xr strftime 3
 format.
 .It Cm dr
 Display actual device name.
-.It Cm f
-Display the flags of
-.Ar file
-as in
-.Nm ls Fl lTdo .
 .It Cm gu
 Display group or user name.
 .It Cm p
@@ -394,12 +380,11 @@
 .It Cm r
 Device number for character and block device special files
 .Pq Fa st_rdev .
-.It Cm a , m , c , B
+.It Cm a , m , c
 The time
 .Ar file
-was last accessed or modified, or when the inode was last changed, or
-the birth time of the inode
-.Pq Fa st_atime , st_mtime , st_ctime , st_birthtime .
+was last accessed or modified or when the inode was last changed
+.Pq Fa st_atime , st_mtime , st_ctime .
 .It Cm z
 The size of
 .Ar file
@@ -412,9 +397,6 @@
 .It Cm k
 Optimal file system I/O operation block size
 .Pq Fa st_blksize .
-.It Cm f
-User defined flags for
-.Ar file .
 .It Cm v
 Inode generation number
 .Pq Fa st_gen .
--- src.orig/coreutils/stat/stat.c
+++ src.freebsd/coreutils/stat/stat.c
@@ -39,17 +39,18 @@
 #if HAVE_CONFIG_H
 #include "config.h" 
 #else  /* HAVE_CONFIG_H */
-#define HAVE_STRUCT_STAT_ST_FLAGS 1
-#define HAVE_STRUCT_STAT_ST_GEN 1
-#define HAVE_STRUCT_STAT_ST_BIRTHTIME 1
+#define HAVE_STRUCT_STAT_ST_FLAGS 0
+#define HAVE_STRUCT_STAT_ST_GEN 0
+#define HAVE_STRUCT_STAT_ST_BIRTHTIME 0
 #define HAVE_STRUCT_STAT_ST_MTIMENSEC 1
-#define HAVE_DEVNAME 1
+#define HAVE_DEVNAME 0
 #endif /* HAVE_CONFIG_H */
 
 #include <sys/param.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/mount.h>
+#include <sys/sysmacros.h>
 
 #include <ctype.h>
 #include <err.h>
@@ -62,7 +63,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <time.h>
+#include <time_bsd.h>
 #include <unistd.h>
 
 #if HAVE_STRUCT_STAT_ST_FLAGS
@@ -79,10 +80,12 @@
 #define DEF_B "\"%SB\" "
 #define RAW_B "%B "
 #define SHELL_B "st_birthtime=%B "
+#define STR_B "%SB"
 #else /* HAVE_STRUCT_STAT_ST_BIRTHTIME */
 #define DEF_B
 #define RAW_B
 #define SHELL_B
+#define STR_B "-"
 #endif /* HAVE_STRUCT_STAT_ST_BIRTHTIME */
 
 #if HAVE_STRUCT_STAT_ST_ATIM
@@ -111,7 +114,7 @@
 	"Access: %Sa%n" \
 	"Modify: %Sm%n" \
 	"Change: %Sc%n"	\
-	" Birth: %SB"
+	" Birth: " STR_B
 
 #define TIME_FORMAT	"%b %e %T %Y"
 
@@ -206,17 +209,14 @@
 {
 	struct stat st;
 	int ch, rc, errs, am_readlink;
-	int lsF, fmtchar, usestat, nfs_handle, fn, nonl, quiet;
+	int lsF, fmtchar, usestat, fn, nonl, quiet;
 	const char *statfmt, *options, *synopsis;
-	char dname[sizeof _PATH_DEV + SPECNAMELEN] = _PATH_DEV;
-	fhandle_t fhnd;
 	const char *file;
 
 	am_readlink = 0;
 	lsF = 0;
 	fmtchar = '\0';
 	usestat = 0;
-	nfs_handle = 0;
 	nonl = 0;
 	quiet = 0;
 	linkfail = 0;
@@ -231,7 +231,7 @@
 		fmtchar = 'f';
 		quiet = 1;
 	} else {
-		options = "f:FHlLnqrst:x";
+		options = "f:FlLnqrst:x";
 		synopsis = "[-FLnq] [-f format | -l | -r | -s | -x] "
 		    "[-t timefmt] [file|handle ...]";
 	}
@@ -241,9 +241,6 @@
 		case 'F':
 			lsF = 1;
 			break;
-                case 'H':
-			nfs_handle = 1;
-			break;
 		case 'L':
 			usestat = 1;
 			break;
@@ -321,37 +318,11 @@
 	errs = 0;
 	do {
 		if (argc == 0) {
-			if (fdevname_r(STDIN_FILENO, dname +
-			    sizeof _PATH_DEV - 1, SPECNAMELEN) != NULL)
-				file = dname;
-			else
-				file = "(stdin)";
+			file = "(stdin)";
 			rc = fstat(STDIN_FILENO, &st);
 		} else {
-			int j;
-
 			file = argv[0];
-			if (nfs_handle) {
-				rc = 0;
-				bzero(&fhnd, sizeof(fhnd));
-				j = MIN(2 * sizeof(fhnd), strlen(file));
-				if ((j & 1) != 0) {
-					rc = -1;
-				} else {
-					while (j) {
-						rc = hex2byte(&file[j - 2]);
-						if (rc == -1)
-							break;
-						((char*) &fhnd)[j / 2 - 1] = rc;
-						j -= 2;
-					}
-				}
-				if (rc == -1)
-					errno = EINVAL;
-				else
-					rc = fhstat(&fhnd, &st);
-
-			} else if (usestat) {
+			if (usestat) {
 				/*
 				 * Try stat() and if it fails, fall back to
 				 * lstat() just in case we're examining a
@@ -616,8 +587,10 @@
 {
 	u_int64_t data;
 	char *stmp, lfmt[24], tmp[20];
-	const char *sdata;
-	char smode[12], sid[12], path[PATH_MAX + 4];
+	struct passwd *pw = NULL;
+	struct group *gr = NULL;
+	const char *sdata = NULL;
+	char smode[12], sid[13], path[PATH_MAX + 4];
 	const struct timespec *tsp;
 	struct timespec ts;
 	struct tm *tm;
@@ -709,10 +682,12 @@
 	case SHOW_st_uid:
 		small = (sizeof(st->st_uid) == 4);
 		data = st->st_uid;
-		sdata = user_from_uid(st->st_uid, 1);
-		if (sdata == NULL) {
+		pw = getpwuid(st->st_uid);
+		if (pw == NULL) {
 			snprintf(sid, sizeof(sid), "(%ld)", (long)st->st_uid);
 			sdata = sid;
+		} else {
+			sdata = pw->pw_name;
 		}
 		formats = FMTF_DECIMAL | FMTF_OCTAL | FMTF_UNSIGNED | FMTF_HEX |
 		    FMTF_STRING;
@@ -722,10 +697,12 @@
 	case SHOW_st_gid:
 		small = (sizeof(st->st_gid) == 4);
 		data = st->st_gid;
-		sdata = group_from_gid(st->st_gid, 1);
-		if (sdata == NULL) {
+		gr = getgrgid(st->st_gid);
+		if (gr == NULL) {
 			snprintf(sid, sizeof(sid), "(%ld)", (long)st->st_gid);
 			sdata = sid;
+		} else {
+			sdata = gr->gr_name;
 		}
 		formats = FMTF_DECIMAL | FMTF_OCTAL | FMTF_UNSIGNED | FMTF_HEX |
 		    FMTF_STRING;
@@ -733,15 +710,15 @@
 			ofmt = FMTF_UNSIGNED;
 		break;
 	case SHOW_st_atime:
-		tsp = &st->st_atimespec;
+		tsp = &st->st_atim;
 		/* FALLTHROUGH */
 	case SHOW_st_mtime:
 		if (tsp == NULL)
-			tsp = &st->st_mtimespec;
+			tsp = &st->st_mtim;
 		/* FALLTHROUGH */
 	case SHOW_st_ctime:
 		if (tsp == NULL)
-			tsp = &st->st_ctimespec;
+			tsp = &st->st_ctim;
 		/* FALLTHROUGH */
 #if HAVE_STRUCT_STAT_ST_BIRTHTIME
 	case SHOW_st_btime:
@@ -757,7 +734,7 @@
 			tm = localtime(&ts.tv_sec);
 		}
 		(void)setlocale(LC_TIME, "");
-		(void)strftime(path, sizeof(path), timefmt, tm);
+		(void)strftime_bsd(path, sizeof(path), timefmt, tm);
 		sdata = path;
 		formats = FMTF_DECIMAL | FMTF_OCTAL | FMTF_UNSIGNED | FMTF_HEX |
 		    FMTF_FLOAT | FMTF_STRING;
@@ -1085,7 +1062,7 @@
 #define hex2nibble(c) (c <= '9' ? c - '0' : toupper(c) - 'A' + 10)
 int
 hex2byte(const char c[2]) {
-	if (!(ishexnumber(c[0]) && ishexnumber(c[1])))
+	if (!(isxdigit(c[0]) && isxdigit(c[1])))
 		return -1;
 	return (hex2nibble(c[0]) << 4) + hex2nibble(c[1]);
 }
--- src.orig/coreutils/stdbuf/stdbuf.c
+++ src.freebsd/coreutils/stdbuf/stdbuf.c
@@ -31,8 +31,9 @@
 #include <stdlib.h>
 #include <unistd.h>
 
+#ifndef LIBSTDBUF
 #define	LIBSTDBUF	"/usr/lib/libstdbuf.so"
-#define	LIBSTDBUF32	"/usr/lib32/libstdbuf.so"
+#endif
 
 static int
 appendenv(const char *key, const char *value)
@@ -101,7 +102,6 @@
 		    "_STDBUF_E", ebuf);
 
 	appendenv("LD_PRELOAD", LIBSTDBUF);
-	appendenv("LD_32_PRELOAD", LIBSTDBUF32);
 
 	execvp(argv[0], argv);
 	err(2, "%s", argv[0]);
--- src.orig/coreutils/stty/cchar.c
+++ src.freebsd/coreutils/stty/cchar.c
@@ -34,11 +34,14 @@
 #endif /* not lint */
 #include <sys/cdefs.h>
 #include <sys/types.h>
+#include <sys/ttydefaults.h>
 
 #include <err.h>
 #include <limits.h>
 #include <stdlib.h>
 #include <string.h>
+#include <unistd.h>
+#include <termios.h>
 
 #include "stty.h"
 #include "extern.h"
@@ -54,12 +57,10 @@
  */
 struct cchar cchars1[] = {
 	{ "discard",	VDISCARD, 	CDISCARD },
-	{ "dsusp", 	VDSUSP,		CDSUSP },
 	{ "eof",	VEOF,		CEOF },
 	{ "eol",	VEOL,		CEOL },
 	{ "eol2",	VEOL2,		CEOL },
 	{ "erase",	VERASE,		CERASE },
-	{ "erase2",	VERASE2,	CERASE2 },
 	{ "intr",	VINTR,		CINTR },
 	{ "kill",	VKILL,		CKILL },
 	{ "lnext",	VLNEXT,		CLNEXT },
@@ -67,11 +68,11 @@
 	{ "quit",	VQUIT,		CQUIT },
 	{ "reprint",	VREPRINT, 	CREPRINT },
 	{ "start",	VSTART,		CSTART },
-	{ "status",	VSTATUS, 	CSTATUS },
 	{ "stop",	VSTOP,		CSTOP },
 	{ "susp",	VSUSP,		CSUSP },
 	{ "time",	VTIME,		CTIME },
 	{ "werase",	VWERASE,	CWERASE },
+	{ "swtc",	VSWTC,		CEOL },
 	{ NULL,		0,		0},
 };
 
--- src.orig/coreutils/stty/extern.h
+++ src.freebsd/coreutils/stty/extern.h
@@ -41,4 +41,7 @@
 void	print(struct termios *, struct winsize *, int, enum FMT);
 void	usage(void) __dead2;
 
+int get_baud(speed_t s);
+speed_t get_speed(unsigned long b);
+
 extern struct cchar cchars1[], cchars2[];
--- src.orig/coreutils/stty/gfmt.c
+++ src.freebsd/coreutils/stty/gfmt.c
@@ -38,7 +38,9 @@
 #include <err.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <unistd.h>
 #include <string.h>
+#include <termios.h>
 
 #include "stty.h"
 #include "extern.h"
@@ -65,7 +67,7 @@
 	for (cp = cchars1; cp->name; ++cp)
 		(void)printf("%s=%x:", cp->name, tp->c_cc[cp->sub]);
 	(void)printf("ispeed=%lu:ospeed=%lu\n",
-	    (u_long)cfgetispeed(tp), (u_long)cfgetospeed(tp));
+	    (u_long)get_baud(cfgetispeed(tp)), (u_long)get_baud(cfgetospeed(tp)));
 }
 
 void
@@ -97,7 +99,7 @@
 		}
 		if (CHK("ispeed")) {
 			tmp = strtoul(ep, NULL, 10);
-			tp->c_ispeed = tmp;
+			cfsetispeed(tp, tmp);
 			continue;
 		}
 		if (CHK("lflag")) {
@@ -110,7 +112,7 @@
 		}
 		if (CHK("ospeed")) {
 			tmp = strtoul(ep, NULL, 10);
-			tp->c_ospeed = tmp;
+			cfsetospeed(tp, tmp);
 			continue;
 		}
 		for (cp = cchars1; cp->name != NULL; ++cp)
--- src.orig/coreutils/stty/key.c
+++ src.freebsd/coreutils/stty/key.c
@@ -34,11 +34,15 @@
 #endif /* not lint */
 #include <sys/cdefs.h>
 #include <sys/types.h>
+#include <sys/ttydefaults.h>
 
 #include <err.h>
+#include <errno.h>
 #include <stdlib.h>
 #include <stdio.h>
+#include <unistd.h>
 #include <string.h>
+#include <termios.h>
 
 #include "stty.h"
 #include "extern.h"
@@ -189,14 +193,24 @@
 void
 f_extproc(struct info *ip)
 {
+	struct termios tio;
+	errno = 0;
 
+	if (tcgetattr(ip->fd, &tio) == -1) {
+		err(1, "extproc");
+		return;
+	}
+
 	if (ip->off) {
-		int tmp = 0;
-		(void)ioctl(ip->fd, TIOCEXT, &tmp);
+		tio.c_lflag &= ~EXTPROC;
 	} else {
-		int tmp = 1;
-		(void)ioctl(ip->fd, TIOCEXT, &tmp);
+		tio.c_lflag |= EXTPROC;
 	}
+
+	if (tcsetattr(ip->fd, TCSANOW, &tio) == -1) {
+		err(1, "extproc");
+		return;
+	}
 }
 
 void
@@ -256,11 +270,16 @@
 {
 	struct termios def;
 
-	cfmakesane(&def);
+	def.c_cflag = TTYDEF_CFLAG;
+	def.c_iflag = TTYDEF_IFLAG;
+	def.c_lflag = TTYDEF_LFLAG;
+	def.c_oflag = TTYDEF_OFLAG;
+	cfsetispeed(&def, TTYDEF_SPEED);
+	cfsetospeed(&def, TTYDEF_SPEED);
 	ip->t.c_cflag = def.c_cflag | (ip->t.c_cflag & CLOCAL);
 	ip->t.c_iflag = def.c_iflag;
 	/* preserve user-preference flags in lflag */
-#define	LKEEP	(ECHOKE|ECHOE|ECHOK|ECHOPRT|ECHOCTL|ALTWERASE|TOSTOP|NOFLSH)
+#define	LKEEP	(ECHOKE|ECHOE|ECHOK|ECHOPRT|ECHOCTL|VWERASE|TOSTOP|NOFLSH)
 	ip->t.c_lflag = def.c_lflag | (ip->t.c_lflag & LKEEP);
 	ip->t.c_oflag = def.c_oflag;
 	ip->set = 1;
@@ -277,7 +296,7 @@
 f_speed(struct info *ip)
 {
 
-	(void)printf("%lu\n", (u_long)cfgetospeed(&ip->t));
+	(void)printf("%lu\n", (u_long)get_baud(cfgetospeed(&ip->t)));
 }
 
 void
@@ -285,7 +304,7 @@
 {
 	int tmp;
 
-	tmp = TTYDISC;
+	tmp = N_TTY;
 	if (ioctl(ip->fd, TIOCSETD, &tmp) < 0)
 		err(1, "TIOCSETD");
 }
--- src.orig/coreutils/stty/modes.c
+++ src.freebsd/coreutils/stty/modes.c
@@ -34,7 +34,9 @@
 #endif /* not lint */
 #include <sys/cdefs.h>
 #include <sys/types.h>
+#include <unistd.h>
 #include <string.h>
+#include <termios.h>
 #include "stty.h"
 
 int msearch(char ***, struct info *);
@@ -78,18 +80,6 @@
 	{ "-clocal",	0, CLOCAL },
 	{ "crtscts",	CRTSCTS, 0 },
 	{ "-crtscts",	0, CRTSCTS },
-	{ "ctsflow",	CCTS_OFLOW, 0 },
-	{ "-ctsflow",	0, CCTS_OFLOW },
-	{ "dsrflow",	CDSR_OFLOW, 0 },
-	{ "-dsrflow",	0, CDSR_OFLOW },
-	{ "dtrflow",	CDTR_IFLOW, 0 },
-	{ "-dtrflow",	0, CDTR_IFLOW },
-	{ "rtsflow",	CRTS_IFLOW, 0 },
-	{ "-rtsflow",	0, CRTS_IFLOW },
-	{ "mdmbuf",	MDMBUF, 0 },
-	{ "-mdmbuf",	0, MDMBUF },
-	{ "rtsdtr",	0, CNO_RTSDTR },
-	{ "-rtsdtr",	CNO_RTSDTR, 0 },
 	{ NULL,		0, 0 },
 };
 
@@ -146,8 +136,8 @@
 	{ "-echoke",	0, ECHOKE },
 	{ "crtkill",	ECHOKE, 0 },
 	{ "-crtkill",	0, ECHOKE },
-	{ "altwerase",	ALTWERASE, 0 },
-	{ "-altwerase",	0, ALTWERASE },
+	{ "altwerase",	VWERASE, 0 },
+	{ "-altwerase",	0, VWERASE },
 	{ "iexten",	IEXTEN, 0 },
 	{ "-iexten",	0, IEXTEN },
 	{ "echonl",	ECHONL, 0 },
@@ -176,10 +166,6 @@
 	{ "-crt",	ECHOK, ECHOE|ECHOKE|ECHOCTL },
 	{ "newcrt",	ECHOE|ECHOKE|ECHOCTL, ECHOK|ECHOPRT },
 	{ "-newcrt",	ECHOK, ECHOE|ECHOKE|ECHOCTL },
-	{ "nokerninfo",	NOKERNINFO, 0 },
-	{ "-nokerninfo",0, NOKERNINFO },
-	{ "kerninfo",	0, NOKERNINFO },
-	{ "-kerninfo",	NOKERNINFO, 0 },
 	{ NULL,		0, 0 },
 };
 
--- src.orig/coreutils/stty/print.c
+++ src.freebsd/coreutils/stty/print.c
@@ -38,6 +38,8 @@
 #include <stddef.h>
 #include <stdio.h>
 #include <string.h>
+#include <unistd.h>
+#include <termios.h>
 
 #include "stty.h"
 #include "extern.h"
@@ -58,12 +60,12 @@
 	cnt = 0;
 
 	/* Line discipline. */
-	if (ldisc != TTYDISC) {
+	if (ldisc != N_TTY) {
 		switch(ldisc) {
-		case SLIPDISC:
+		case N_SLIP:
 			cnt += printf("slip disc; ");
 			break;
-		case PPPDISC:
+		case N_PPP:
 			cnt += printf("ppp disc; ");
 			break;
 		default:
@@ -77,9 +79,9 @@
 	ospeed = cfgetospeed(tp);
 	if (ispeed != ospeed)
 		cnt +=
-		    printf("ispeed %d baud; ospeed %d baud;", ispeed, ospeed);
+		    printf("ispeed %d baud; ospeed %d baud;", get_baud(ispeed), get_baud(ospeed));
 	else
-		cnt += printf("speed %d baud;", ispeed);
+		cnt += printf("speed %d baud;", get_baud(ispeed));
 	if (fmt >= BSD)
 		cnt += printf(" %d rows; %d columns;", wp->ws_row, wp->ws_col);
 	if (cnt)
@@ -103,12 +105,11 @@
 	put("-echonl", ECHONL, 0);
 	put("-echoctl", ECHOCTL, 0);
 	put("-echoprt", ECHOPRT, 0);
-	put("-altwerase", ALTWERASE, 0);
+	put("-altwerase", VWERASE, 0);
 	put("-noflsh", NOFLSH, 0);
 	put("-tostop", TOSTOP, 0);
 	put("-flusho", FLUSHO, 0);
 	put("-pendin", PENDIN, 0);
-	put("-nokerninfo", NOKERNINFO, 0);
 	put("-extproc", EXTPROC, 0);
 
 	/* input flags */
@@ -169,26 +170,7 @@
 	put("-hupcl", HUPCL, 1);
 	put("-clocal", CLOCAL, 0);
 	put("-cstopb", CSTOPB, 0);
-	switch(tmp & (CCTS_OFLOW | CRTS_IFLOW)) {
-	case CCTS_OFLOW:
-		bput("ctsflow");
-		break;
-	case CRTS_IFLOW:
-		bput("rtsflow");
-		break;
-	default:
-		put("-crtscts", CCTS_OFLOW | CRTS_IFLOW, 0);
-		break;
-	}
-	put("-dsrflow", CDSR_OFLOW, 0);
-	put("-dtrflow", CDTR_IFLOW, 0);
-	put("-mdmbuf", MDMBUF, 0);	/* XXX mdmbuf ==  dtrflow */
-	if (on(CNO_RTSDTR))
-		bput("-rtsdtr");
-	else {
-		if (fmt >= BSD)
-			bput("rtsdtr");
-	}
+	put("-crtscts", CRTSCTS, 0);
 
 	/* special control characters */
 	cc = tp->c_cc;
--- src.orig/coreutils/stty/stty.1
+++ src.freebsd/coreutils/stty/stty.1
@@ -355,13 +355,6 @@
 erased with simply an
 .Dv ERASE
 character.)
-.It Cm mdmbuf Pq Fl mdmbuf
-If set, flow control output based on condition of Carrier Detect.
-Otherwise
-writes return an error if Carrier Detect is low (and Carrier is not being
-ignored with the
-.Dv CLOCAL
-flag.)
 .It Cm flusho Pq Fl flusho
 Indicates output is (is not) being discarded.
 .It Cm pendin Pq Fl pendin
@@ -395,7 +388,6 @@
 .It eol Ta Tn VEOL Ta EOL No character
 .It eol2 Ta Tn VEOL2 Ta EOL2 No character
 .It erase Ta Tn VERASE Ta ERASE No character
-.It erase2 Ta Tn VERASE2 Ta ERASE2 No character
 .It werase Ta Tn VWERASE Ta WERASE No character
 .It intr Ta Tn VINTR Ta INTR No character
 .It kill Ta Tn VKILL Ta KILL No character
@@ -403,10 +395,10 @@
 .It susp Ta Tn VSUSP Ta SUSP No character
 .It start Ta Tn VSTART Ta START No character
 .It stop Ta Tn VSTOP Ta STOP No character
-.It dsusp Ta Tn VDSUSP Ta DSUSP No character
+.It dsusp Ta Tn CDSUSP Ta DSUSP No character
 .It lnext Ta Tn VLNEXT Ta LNEXT No character
 .It reprint Ta Tn VREPRINT Ta REPRINT No character
-.It status Ta Tn VSTATUS Ta STATUS No character
+.It status Ta Tn CSTATUS Ta STATUS No character
 .El
 .Ed
 .It Cm min Ar number
@@ -454,22 +446,6 @@
 .Dv TTYDISC .
 .It Cm crt Pq Fl crt
 Set (disable) all modes suitable for a CRT display device.
-.It Cm kerninfo Pq Fl kerninfo
-Enable (disable) the system generated status line associated with
-processing a
-.Dv STATUS
-character (usually set to ^T).
-The status line consists of the
-system load average, the current command name, its process ID, the
-event the process is waiting on (or the status of the process), the user
-and system times, percent cpu, and current memory usage.
-.Pp
-If the
-.Xr sysctl 8
-variable
-.Va kern.tty_info_kstacks
-is set to a non-zero value, the status message also includes the kernel program
-stack of the foreground thread.
 .It Cm columns Ar number
 The terminal size is recorded as having
 .Ar number
--- src.orig/coreutils/stty/stty.c
+++ src.freebsd/coreutils/stty/stty.c
@@ -49,6 +49,8 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <errno.h>
+#include <termios.h>
 
 #include "stty.h"
 #include "extern.h"
@@ -127,10 +129,11 @@
 
 		if (isdigit(**argv)) {
 			speed_t speed;
-
-			speed = strtonum(*argv, 0, UINT_MAX, &errstr);
+			unsigned int baud;
+			baud = (unsigned int)strtonum(*argv, 0, UINT_MAX, &errstr);
 			if (errstr)
 				err(1, "speed");
+			speed = get_speed(baud);
 			cfsetospeed(&i.t, speed);
 			cfsetispeed(&i.t, speed);
 			i.set = 1;
--- src.orig/coreutils/stty/util.c
+++ src.freebsd/coreutils/stty/util.c
@@ -38,6 +38,7 @@
 
 #include <err.h>
 #include <unistd.h>
+#include <termios.h>
 
 #include "stty.h"
 #include "extern.h"
@@ -57,4 +58,32 @@
 	    !fstat(STDOUT_FILENO, &sb1) && !fstat(STDERR_FILENO, &sb2) &&
 	    (sb1.st_rdev != sb2.st_rdev))
 warnx("stdout appears redirected, but stdin is the control descriptor");
+}
+
+static const int baudlist[] = {
+	0, 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800, 9600,
+	19200, 38400, 57600, 115200, 230400, 460800, 500000, 576000, 921600,
+	1000000, 1152000, 1500000, 2000000, 2500000, 3000000, 3500000, 4000000,
+};
+
+static const speed_t baudvals[] = {
+	B0, B50, B75, B110, B134, B150, B200, B300, B600, B1200, B1800, B2400,
+	B4800, B9600, B19200, B38400, B57600, B115200, B230400, B460800, B500000,
+	B576000, B921600, B1000000, B1152000, B1500000, B2000000, B2500000,
+	B3000000, B3500000, B4000000,
+};
+
+int get_baud(speed_t s) {
+	if (s & CBAUDEX)
+		s = (s & ~CBAUDEX) + 15;
+	return baudlist[s];
+}
+
+speed_t get_speed(unsigned long b) {
+	for (size_t i = 0; i < (sizeof(baudlist) / sizeof(int)); ++i) {
+		if ((unsigned long)baudlist[i] != b)
+			continue;
+		return baudvals[i];
+	}
+	errx(1, "unknown speed for baud %lu", b);
 }
--- src.orig/coreutils/tail/forward.c
+++ src.freebsd/coreutils/tail/forward.c
@@ -43,7 +43,6 @@
 #include <sys/stat.h>
 #include <sys/time.h>
 #include <sys/mman.h>
-#include <sys/event.h>
 
 #include <err.h>
 #include <errno.h>
@@ -61,17 +60,7 @@
 
 static void rlines(FILE *, const char *fn, off_t, struct stat *);
 static int show(file_info_t *);
-static void set_events(file_info_t *files);
 
-/* defines for inner loop actions */
-#define USE_SLEEP	0
-#define USE_KQUEUE	1
-#define ADD_EVENTS	2
-
-static struct kevent *ev;
-static int action = USE_SLEEP;
-static int kq;
-
 static const file_info_t *last;
 
 /*
@@ -262,44 +251,6 @@
 	return 1;
 }
 
-static void
-set_events(file_info_t *files)
-{
-	int i, n = 0;
-	file_info_t *file;
-	struct timespec ts;
-	struct statfs sf;
-
-	ts.tv_sec = 0;
-	ts.tv_nsec = 0;
-
-	action = USE_KQUEUE;
-	for (i = 0, file = files; i < no_files; i++, file++) {
-		if (!file->fp)
-			continue;
-
-		if (fstatfs(fileno(file->fp), &sf) == 0 &&
-		    (sf.f_flags & MNT_LOCAL) == 0) {
-			action = USE_SLEEP;
-			return;
-		}
-
-		if (Fflag && fileno(file->fp) != STDIN_FILENO) {
-			EV_SET(&ev[n], fileno(file->fp), EVFILT_VNODE,
-			    EV_ADD | EV_ENABLE | EV_CLEAR,
-			    NOTE_DELETE | NOTE_RENAME, 0, 0);
-			n++;
-		}
-		EV_SET(&ev[n], fileno(file->fp), EVFILT_READ,
-		    EV_ADD | EV_ENABLE | EV_CLEAR, 0, 0, 0);
-		n++;
-	}
-
-	if (kevent(kq, ev, n, NULL, 0, &ts) < 0) {
-		action = USE_SLEEP;
-	}
-}
-
 /*
  * follow -- display the file, from an offset, forward.
  *
@@ -307,11 +258,10 @@
 void
 follow(file_info_t *files, enum STYLE style, off_t off)
 {
-	int active, ev_change, i, n;
+	int active, i;
 	struct stat sb2;
 	file_info_t *file;
 	FILE *ftmp;
-	struct timespec ts;
 
 	/* Position each of the files */
 	active = 0;
@@ -328,21 +278,7 @@
 
 	last = --file;
 
-	kq = kqueue();
-	if (kq < 0)
-		err(1, "kqueue");
-	/*
-	 * The number of kqueue events we track may vary over time and may
-	 * even grow past its initial value in the -F case, but it will
-	 * never exceed two per file, so just preallocate that.
-	 */
-	ev = malloc(no_files * 2 * sizeof(struct kevent));
-	if (ev == NULL)
-		err(1, "failed to allocate memory for kevents");
-	set_events(files);
-
 	for (;;) {
-		ev_change = 0;
 		if (Fflag) {
 			for (i = 0, file = files; i < no_files; i++, file++) {
 				if (!file->fp) {
@@ -355,8 +291,6 @@
 						fclose(file->fp);
 						file->fp = NULL;
 					}
-					if (file->fp != NULL)
-						ev_change++;
 					continue;
 				}
 				if (fileno(file->fp) == STDIN_FILENO)
@@ -374,7 +308,6 @@
 					if (ftmp != NULL) {
 						fclose(ftmp);
 					}
-					ev_change++;
 					continue;
 				}
 
@@ -387,7 +320,6 @@
 					file->fp = ftmp;
 					memcpy(&file->st, &sb2,
 					    sizeof(struct stat));
-					ev_change++;
 				} else {
 					fclose(ftmp);
 				}
@@ -395,42 +327,8 @@
 		}
 
 		for (i = 0, file = files; i < no_files; i++, file++)
-			if (file->fp && !show(file))
-				ev_change++;
+			if (file->fp) show(file);
 
-		if (ev_change)
-			set_events(files);
-
-		switch (action) {
-		case USE_KQUEUE:
-			ts.tv_sec = 1;
-			ts.tv_nsec = 0;
-			/*
-			 * In the -F case we set a timeout to ensure that
-			 * we re-stat the file at least once every second.
-			 * If we've received EINTR, ignore it. Both reasons
-			 * for its generation are transient.
-			 */
-			do {
-				n = kevent(kq, NULL, 0, ev, 1, Fflag ? &ts : NULL);
-				if (n < 0 && errno != EINTR)
-					err(1, "kevent");
-			} while (n < 0);
-			if (n == 0) {
-				/* timeout */
-				break;
-			} else if (ev->filter == EVFILT_READ && ev->data < 0) {
-				/* file shrank, reposition to end */
-				if (lseek(ev->ident, (off_t)0, SEEK_END) == -1) {
-					ierr(file->file_name);
-					continue;
-				}
-			}
-			break;
-
-		case USE_SLEEP:
-			(void) usleep(250000);
-			break;
-		}
+		(void) usleep(250000);
 	}
 }
--- src.orig/coreutils/tail/tail.c
+++ src.freebsd/coreutils/tail/tail.c
@@ -43,6 +43,7 @@
 static const char sccsid[] = "@(#)tail.c	8.1 (Berkeley) 6/6/93";
 #endif
 
+#include <sys/cdefs.h>
 #include <sys/capsicum.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -87,6 +88,7 @@
 	const char *fn;
 	FILE *fp;
 	off_t off;
+	uint64_t uoff;
 	enum STYLE style;
 	int ch, first;
 	file_info_t file, *filep, *files;
@@ -107,8 +109,9 @@
 #define	ARG(units, forward, backward) {					\
 	if (style)							\
 		usage();						\
-	if (expand_number(optarg, &off))				\
+	if (expand_number(optarg, &uoff))				\
 		err(1, "illegal offset -- %s", optarg);			\
+	off = uoff;							\
 	if (off > INT64_MAX / units || off < INT64_MIN / units )	\
 		errx(1, "illegal offset -- %s", optarg);		\
 	switch(optarg[0]) {						\
--- src.orig/coreutils/tee/tee.c
+++ src.freebsd/coreutils/tee/tee.c
@@ -41,6 +41,7 @@
 #endif
 #endif /* not lint */
 
+#include <sys/cdefs.h>
 #include <sys/capsicum.h>
 #include <sys/queue.h>
 #include <sys/stat.h>
--- src.orig/coreutils/timeout/timeout.c
+++ src.freebsd/coreutils/timeout/timeout.c
@@ -26,10 +26,11 @@
  */
 
 #include <sys/cdefs.h>
-#include <sys/procctl.h>
+#include <sys/prctl.h>
 #include <sys/time.h>
 #include <sys/wait.h>
 
+#include <sysexits.h>
 #include <err.h>
 #include <errno.h>
 #include <getopt.h>
@@ -101,16 +102,19 @@
 {
 	int sig, i;
 	const char *errstr;
+	const char *signame;
 
-	sig = strtonum(str, 1, sys_nsig - 1, &errstr);
+	sig = strtonum(str, 1, NSIG, &errstr);
 
 	if (errstr == NULL)
 		return (sig);
+
 	if (strncasecmp(str, "SIG", 3) == 0)
 		str += 3;
 
-	for (i = 1; i < sys_nsig; i++) {
-		if (strcasecmp(str, sys_signame[i]) == 0)
+	for (i = 1; i < NSIG; i++) {
+		signame = signum_to_signame(i);
+		if (signame && strcasecmp(str, signame) == 0)
 			return (i);
 	}
 
@@ -171,8 +175,6 @@
 	bool do_second_kill = false;
 	bool child_done = false;
 	struct sigaction signals;
-	struct procctl_reaper_status info;
-	struct procctl_reaper_kill killemall;
 	int signums[] = {
 		-1,
 		SIGTERM,
@@ -225,8 +227,8 @@
 
 	if (!foreground) {
 		/* Acquire a reaper */
-		if (procctl(P_PID, getpid(), PROC_REAP_ACQUIRE, NULL) == -1)
-			err(EXIT_FAILURE, "Fail to acquire the reaper");
+		if (prctl(PR_SET_CHILD_SUBREAPER, 1, 0, 0) == -1)
+			err(EX_OSERR, "Fail to set the reaper");
 	}
 
 	memset(&signals, 0, sizeof(signals));
@@ -294,9 +296,7 @@
 				if (foreground) {
 					break;
 				} else {
-					procctl(P_PID, getpid(),
-					    PROC_REAP_STATUS, &info);
-					if (info.rs_children == 0)
+					if (waitpid(-1, NULL, WNOHANG) < 0)
 						break;
 				}
 			}
@@ -305,10 +305,8 @@
 
 			timedout = true;
 			if (!foreground) {
-				killemall.rk_sig = killsig;
-				killemall.rk_flags = 0;
-				procctl(P_PID, getpid(), PROC_REAP_KILL,
-				    &killemall);
+				if (kill(getpid(), SIGKILL) == -1)
+					err(EXIT_FAILURE, "kill");
 			} else
 				kill(pid, killsig);
 
@@ -322,10 +320,8 @@
 
 		} else if (sig_term) {
 			if (!foreground) {
-				killemall.rk_sig = sig_term;
-				killemall.rk_flags = 0;
-				procctl(P_PID, getpid(), PROC_REAP_KILL,
-				    &killemall);
+				if (kill(getpid(), SIGTERM) == -1)
+					err(EXIT_FAILURE, "kill");
 			} else
 				kill(pid, sig_term);
 
@@ -345,7 +341,7 @@
 	}
 
 	if (!foreground)
-		procctl(P_PID, getpid(), PROC_REAP_RELEASE, NULL);
+		prctl(PR_SET_CHILD_SUBREAPER, 0, 0, 0);
 
 	if (WEXITSTATUS(pstat))
 		pstat = WEXITSTATUS(pstat);
--- src.orig/coreutils/touch/touch.c
+++ src.freebsd/coreutils/touch/touch.c
@@ -52,7 +52,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <time.h>
+#include <time_bsd.h>
 #include <unistd.h>
 
 static void	stime_arg1(const char *, struct timespec *);
@@ -333,7 +333,7 @@
 		goto bad;
 	fmt = strchr(arg, 'T') != NULL ? "%Y-%m-%dT%H:%M:%S" :
 	    "%Y-%m-%d %H:%M:%S";
-	p = strptime(arg, fmt, &t);
+	p = strptime_bsd(arg, fmt, &t);
 	if (p == NULL)
 		goto bad;
 	/* POSIX: must have at least one digit after dot */
--- src.orig/coreutils/tr/cmap.h
+++ src.freebsd/coreutils/tr/cmap.h
@@ -45,7 +45,7 @@
 	wint_t		cm_cache[CM_CACHE_SIZE];
 	bool		cm_havecache;
 	struct cmapnode	*cm_root;
-#define	CM_DEF_SELF	-2
+#define	CM_DEF_SELF	(wint_t)(-2)
 	wint_t		cm_def;
 	wint_t		cm_min;
 	wint_t		cm_max;
--- src.orig/coreutils/tr/extern.h
+++ src.freebsd/coreutils/tr/extern.h
@@ -34,7 +34,7 @@
 #include <limits.h>
 
 #define	NCHARS_SB	(UCHAR_MAX + 1)	/* Number of single-byte characters. */
-#define	OOBCH		-1		/* Out of band character value. */
+#define	OOBCH		(wint_t)(-1)		/* Out of band character value. */
 
 typedef struct {
 	enum { STRING1, STRING2 } which;
@@ -50,3 +50,5 @@
 
 wint_t	 next(STR *);
 int charcoll(const void *, const void *);
+
+#define iswrune(v) (iswprint(v) || iswcntrl(v))
--- src.orig/coreutils/tr/str.c
+++ src.freebsd/coreutils/tr/str.c
@@ -55,6 +55,44 @@
 static int      genrange(STR *, int);
 static void	genseq(STR *);
 
+static wint_t
+findwchar(wctype_t wct, wchar_t min, wchar_t max)
+{
+	for (; min <= max; ++min) {
+		if (iswctype(min, wct))
+			return min;
+	}
+	return (wint_t)-1;
+}
+
+/* we cannot reasonably implement this for wide characters/unicode, since
+ * the standard posix api has no way to find out the actual ranges, and
+ * doing binary search on the entire wchar range is inefficient (especially
+ * considering the character range does not have to be contiguous, which
+ * means doing a new search after we get to the end of the current part
+ * of the range)
+ *
+ * therefore, stick with what is representable in the C locale and do a
+ * simple linear search instead, this should always get us reliable results
+ */
+
+static wint_t
+nextwctype(wint_t ch, wctype_t wct)
+{
+	if (ch == (wint_t)-1) {
+		/* locate first character in the class */
+		return findwchar(wct, 0, UCHAR_MAX);
+	}
+
+	if ((ch == (wint_t)-1) || (ch >= UCHAR_MAX))
+		return (wint_t)-1;
+
+	if (!iswctype(++ch, wct))
+		return findwchar(wct, ch, UCHAR_MAX);
+
+	return ch;
+}
+
 wint_t
 next(STR *s)
 {
@@ -113,7 +151,7 @@
 	case CCLASS_LOWER:
 		s->cnt++;
 		ch = nextwctype(s->lastch, s->cclass);
-		if (ch == -1) {
+		if (ch == (wint_t)-1) {
 			s->state = NORMAL;
 			return (next(s));
 		}
@@ -238,9 +276,10 @@
 static int
 genrange(STR *s, int was_octal)
 {
-	int stopval, octal;
+	wint_t stopval;
+	int octal;
 	char *savestart;
-	int n, cnt, *p;
+	wint_t n, cnt, *p;
 	size_t clen;
 	wchar_t wc;
 
--- src.orig/coreutils/tr/tr.c
+++ src.freebsd/coreutils/tr/tr.c
@@ -40,6 +40,7 @@
 static const char sccsid[] = "@(#)tr.c	8.2 (Berkeley) 5/4/95";
 #endif
 
+#include <sys/cdefs.h>
 #include <sys/types.h>
 #include <sys/capsicum.h>
 
@@ -75,6 +76,7 @@
 	int n, *p;
 	int Cflag, cflag, dflag, sflag, isstring2;
 	wint_t ch, cnt, lastch;
+	int optc;
 
 	(void)setlocale(LC_ALL, "");
 
@@ -85,8 +87,8 @@
 		err(1, "unable to enter capability mode");
 
 	Cflag = cflag = dflag = sflag = 0;
-	while ((ch = getopt(argc, argv, "Ccdsu")) != -1)
-		switch((char)ch) {
+	while ((optc = getopt(argc, argv, "Ccdsu")) != -1)
+		switch(optc) {
 		case 'C':
 			Cflag = 1;
 			cflag = 0;
@@ -116,6 +118,7 @@
 	default:
 		usage();
 		/* NOTREACHED */
+		return 1;
 	case 1:
 		isstring2 = 0;
 		break;
@@ -304,7 +307,7 @@
 
 		s2.str = argv[1];
 		s2.state = NORMAL;
-		for (cnt = 0; cnt < n; cnt++) {
+		for (cnt = 0; cnt < (wint_t)n; cnt++) {
 			(void)next(&s2);
 			cmap_add(map, carray[cnt], s2.lastch);
 			/*
--- src.orig/coreutils/truncate/truncate.1
+++ src.freebsd/coreutils/truncate/truncate.1
@@ -225,7 +225,7 @@
 .Sh SEE ALSO
 .Xr dd 1 ,
 .Xr touch 1 ,
-.Xr fspacectl 2 ,
+.Xr fallocate 2 ,
 .Xr truncate 2
 .Sh STANDARDS
 The
--- src.orig/coreutils/truncate/truncate.c
+++ src.freebsd/coreutils/truncate/truncate.c
@@ -41,6 +41,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
+#include <stdint.h>
 
 #include <libutil.h>
 
@@ -62,7 +63,6 @@
 	int do_refer;
 	int got_size;
 	char *fname, *rname;
-	struct spacectl_range sr;
 
 	fd = -1;
 	rsize = tsize = sz = off = 0;
@@ -198,9 +198,7 @@
 			tsize = 0;
 
 		if (do_dealloc == 1) {
-			sr.r_offset = off;
-			sr.r_len = len;
-			r = fspacectl(fd, SPACECTL_DEALLOC, &sr, 0, &sr);
+			r = fallocate(fd, FALLOC_FL_PUNCH_HOLE, off, len);
 		}
 		if (do_truncate == 1)
 			r = ftruncate(fd, tsize);
--- src.orig/coreutils/tsort/tsort.c
+++ src.freebsd/coreutils/tsort/tsort.c
@@ -46,7 +46,6 @@
 #include <sys/types.h>
 
 #include <ctype.h>
-#include <db.h>
 #include <err.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -96,7 +95,83 @@
 	int b_bsize;
 } BUF;
 
-static DB *db;
+#define HASH_CHUNK_SIZE 64
+#define HASH_BUCKET_COUNT 1024
+
+struct hash_elem {
+	NODE *elem;
+	struct hash_elem *next;
+};
+
+struct hash_chunk {
+	struct hash_elem elems[HASH_CHUNK_SIZE];
+	struct hash_chunk *next;
+};
+
+struct hash {
+	struct hash_elem **elems;
+	struct hash_chunk *chunks;
+	struct hash_elem *top;
+};
+
+static void hash_init(struct hash *h) {
+	h->chunks = NULL;
+	h->top = NULL;
+	h->elems = calloc(1024, sizeof(struct hash_elem *));
+}
+
+static void hash_destroy(struct hash *h) {
+	for (size_t i = 0; i < HASH_BUCKET_COUNT; ++i) {
+		struct hash_elem *e = h->elems[i];
+		while (e) {
+			free(e->elem->n_arcs);
+			free(e->elem);
+			e = e->next;
+		}
+	}
+	free(h->elems);
+	while (h->chunks) {
+		struct hash_chunk *c = h->chunks;
+		h->chunks = h->chunks->next;
+		free(c);
+	}
+}
+
+static size_t hash_key(char *key) {
+	size_t h = 5381;
+	for (size_t i = 0, k; (k = key[i]); ++i)
+		h = ((h << 5) + h) ^ k;
+	return h;
+}
+
+static NODE *hash_find(struct hash *h, char *key) {
+	size_t hash = hash_key(key) & (HASH_BUCKET_COUNT - 1);
+	for (struct hash_elem *c = h->elems[hash]; c; c = c->next) {
+		if (!strcmp(key, c->elem->n_name))
+			return c->elem;
+	}
+	return NULL;
+}
+
+static struct hash_elem *hash_insert(struct hash *h, char *key) {
+	size_t hash = hash_key(key) & (HASH_BUCKET_COUNT - 1);
+	if (!h->top) {
+		struct hash_chunk *c = calloc(1, sizeof(struct hash_chunk));
+		c->next = h->chunks;
+		h->chunks = c;
+		for (size_t i = 0; i < (HASH_CHUNK_SIZE - 1); ++i) 
+			c->elems[i].next = &c->elems[i + 1];
+		c->elems[HASH_CHUNK_SIZE - 1].next = h->top;
+		h->top = c->elems;
+	}
+	struct hash_elem *hc = h->top;
+	h->top = h->top->next;
+	hc->next = h->elems[hash];
+	h->elems[hash] = hc;
+	return hc;
+}
+
+static struct hash db;
 static NODE *graph, **cycle_buf, **longest_cycle;
 static int debug, longest, quiet;
 
@@ -152,6 +227,8 @@
 	for (b = bufs, n = 2; --n >= 0; b++)
 		b->b_buf = grow_buf(NULL, b->b_bsize = 1024);
 
+	hash_init(&db);
+
 	/* parse input and build the graph */
 	for (n = 0, c = getc(fp);;) {
 		while (c != EOF && isspace(c))
@@ -181,6 +258,7 @@
 
 	/* do the sort */
 	tsort();
+	hash_destroy(&db);
 	if (ferror(stdout) != 0 || fflush(stdout) != 0)
 		err(1, "stdout");
 	exit(0);
@@ -237,28 +315,15 @@
 static NODE *
 get_node(char *name)
 {
-	DBT data, key;
-	NODE *n;
+	NODE *n = hash_find(&db, name);
+	size_t nlen;
 
-	if (db == NULL &&
-	    (db = dbopen(NULL, O_RDWR, 0, DB_HASH, NULL)) == NULL)
-		err(1, "db: %s", name);
+	if (n)
+		return n;
 
-	key.data = name;
-	key.size = strlen(name) + 1;
+	nlen = strlen(name) + 1;
 
-	switch ((*db->get)(db, &key, &data, 0)) {
-	case 0:
-		memcpy(&n, data.data, sizeof(n));
-		return (n);
-	case 1:
-		break;
-	default:
-	case -1:
-		err(1, "db: %s", name);
-	}
-
-	if ((n = malloc(sizeof(NODE) + key.size)) == NULL)
+	if ((n = malloc(sizeof(NODE) + nlen)) == NULL)
 		err(1, NULL);
 
 	n->n_narcs = 0;
@@ -266,7 +331,7 @@
 	n->n_arcs = NULL;
 	n->n_refcnt = 0;
 	n->n_flags = 0;
-	memcpy(n->n_name, name, key.size);
+	memcpy(n->n_name, name, nlen);
 
 	/* Add to linked list. */
 	if ((n->n_next = graph) != NULL)
@@ -275,10 +340,7 @@
 	graph = n;
 
 	/* Add to hash table. */
-	data.data = &n;
-	data.size = sizeof(n);
-	if ((*db->put)(db, &key, &data, 0))
-		err(1, "db: %s", name);
+	hash_insert(&db, name)->elem = n;
 	return (n);
 }
 
--- src.orig/coreutils/uname/uname.1
+++ src.freebsd/coreutils/uname/uname.1
@@ -83,8 +83,6 @@
 .It Fl r
 Write the current release level of the kernel
 to standard output.
-.Xr freebsd-version 1
-can be used to print the release level of the userland.
 .It Fl s
 Write the name of the operating system implementation to standard output.
 .It Fl U
@@ -133,13 +131,12 @@
 e.g., on 64-bit PowerPC,
 .Fl m
 would return
-.Va powerpc
+.Va ppc64
 and
 .Fl p
 would return
-.Va powerpc64 .
+.Va unknown .
 .Sh SEE ALSO
-.Xr freebsd-version 1 ,
 .Xr feature_present 3 ,
 .Xr getosreldate 3 ,
 .Xr sysctl 3 ,
--- src.orig/coreutils/uname/uname.c
+++ src.freebsd/coreutils/uname/uname.c
@@ -45,16 +45,16 @@
 static const char sccsid[] = "@(#)uname.c	8.2 (Berkeley) 5/4/95";
 #endif
 
+#include <sys/cdefs.h>
 #include <sys/param.h>
-#include <sys/sysctl.h>
+#include <sys/utsname.h>
+#include <sys/types.h>
 
 #include <err.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
 
-#include <osreldate.h>
-
 #define	MFLAG	0x01
 #define	NFLAG	0x02
 #define	PFLAG	0x04
@@ -202,94 +202,38 @@
 	printf("\n");
 }
 
-#define	NATIVE_SYSCTL2_GET(var,mib0,mib1)	\
-static void					\
-native_##var(void)				\
-{						\
-	int mib[] = { (mib0), (mib1) };		\
-	size_t len;				\
-	static char buf[1024];			\
-	char **varp = &(var);			\
-						\
-	len = sizeof buf;			\
-	if (sysctl(mib, sizeof mib / sizeof mib[0],	\
-	   &buf, &len, NULL, 0) == -1)		\
-		err(1, "sysctl");
-
-#define	NATIVE_SYSCTLNAME_GET(var,name)		\
-static void					\
-native_##var(void)				\
-{						\
-	size_t len;				\
-	static char buf[1024];			\
-	char **varp = &(var);			\
-						\
-	len = sizeof buf;			\
-	if (sysctlbyname(name, &buf, &len, NULL,\
-	    0) == -1)				\
-		err(1, "sysctlbyname");
-
-#define	NATIVE_SET				\
-	*varp = buf;				\
-	return;					\
-}	struct __hack
-
-#define	NATIVE_BUFFER	(buf)
-#define	NATIVE_LENGTH	(len)
-
-NATIVE_SYSCTL2_GET(sysname, CTL_KERN, KERN_OSTYPE) {
-} NATIVE_SET;
-
-NATIVE_SYSCTL2_GET(hostname, CTL_KERN, KERN_HOSTNAME) {
-} NATIVE_SET;
-
-NATIVE_SYSCTL2_GET(release, CTL_KERN, KERN_OSRELEASE) {
-} NATIVE_SET;
-
-NATIVE_SYSCTL2_GET(version, CTL_KERN, KERN_VERSION) {
-	size_t n;
-	char *p;
-
-	p = NATIVE_BUFFER;
-	n = NATIVE_LENGTH;
-	for (; n--; ++p)
-		if (*p == '\n' || *p == '\t') {
-			if (n > 1)
-				*p = ' ';
-			else
-				*p = '\0';
-		}
-} NATIVE_SET;
-
-NATIVE_SYSCTL2_GET(platform, CTL_HW, HW_MACHINE) {
-} NATIVE_SET;
-
-NATIVE_SYSCTL2_GET(arch, CTL_HW, HW_MACHINE_ARCH) {
-} NATIVE_SET;
-
-NATIVE_SYSCTLNAME_GET(ident, "kern.ident") {
-} NATIVE_SET;
-
-NATIVE_SYSCTLNAME_GET(buildid, "kern.build_id") {
-} NATIVE_SET;
-
-static void
-native_uservers(void)
-{
-	static char buf[128];
-
-	snprintf(buf, sizeof(buf), "%d", __FreeBSD_version);
-	uservers = buf;
+#define NATIVE_UNAME_GET(var,field) \
+static void \
+native_##var(void) \
+{ \
+	static char buf[1024]; \
+	struct utsname u; \
+ \
+	if (uname(&u) != 0) \
+		err(1, "uname"); \
+\
+	snprintf(buf, sizeof(buf), "%s", u.field); \
+	var = buf; \
 }
 
-static void
-native_kernvers(void)
-{
-	static char buf[128];
+NATIVE_UNAME_GET(sysname, sysname)
+NATIVE_UNAME_GET(hostname, nodename)
+NATIVE_UNAME_GET(release, release)
+NATIVE_UNAME_GET(version, version)
+NATIVE_UNAME_GET(platform, machine)
 
-	snprintf(buf, sizeof(buf), "%d", getosreldate());
-	kernvers = buf;
+#define UNKNOWN_GET(var) \
+static void \
+native_##var(void) \
+{ \
+	var = "unknown"; \
 }
+
+UNKNOWN_GET(arch)
+UNKNOWN_GET(ident)
+UNKNOWN_GET(buildid)
+UNKNOWN_GET(uservers)
+UNKNOWN_GET(kernvers)
 
 static void
 usage(void)
--- src.orig/coreutils/unexpand/unexpand.c
+++ src.freebsd/coreutils/unexpand/unexpand.c
@@ -40,6 +40,8 @@
 static const char sccsid[] = "@(#)unexpand.c	8.1 (Berkeley) 6/6/93";
 #endif
 
+#include <sys/cdefs.h>
+
 /*
  * unexpand - put tabs into a file replacing blanks
  */
--- src.orig/coreutils/uniq/uniq.c
+++ src.freebsd/coreutils/uniq/uniq.c
@@ -172,7 +172,7 @@
 	if (cap_rights_is_set(&rights, CAP_IOCTL)) {
 		unsigned long cmd;
 
-		cmd = TIOCGETA; /* required by isatty(3) in printf(3) */
+		cmd = 0; /* required by isatty(3) in printf(3) */
 
 		if (caph_ioctls_limit(fileno(ofp), &cmd, 1) < 0) {
 			err(1, "unable to limit ioctls for %s",
--- src.orig/coreutils/wc/wc.1
+++ src.freebsd/coreutils/wc/wc.1
@@ -129,7 +129,7 @@
 If
 .Nm
 receives a
-.Dv SIGINFO
+.Dv SIGUSR1
 (see the
 .Cm status
 argument for
--- src.orig/coreutils/wc/wc.c
+++ src.freebsd/coreutils/wc/wc.c
@@ -45,12 +45,14 @@
 #include <sys/capsicum.h>
 #include <sys/param.h>
 #include <sys/stat.h>
+#include <sys/types.h>
 
 #include <capsicum_helpers.h>
 #include <ctype.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <locale.h>
+#include <signal.h>
 #include <stdbool.h>
 #include <stdint.h>
 #include <stdio.h>
@@ -308,7 +310,7 @@
 			if (!domulti || MB_CUR_MAX == 1) {
 				clen = 1;
 				wch = (unsigned char)*p;
-			} else if ((clen = mbrtowc(&wch, p, len, &mbs)) == 0) {
+			} else if ((clen = mbrtowc(&wch, (char *)p, len, &mbs)) == 0) {
 				clen = 1;
 			} else if (clen == (size_t)-1) {
 				if (!warned) {
--- src.orig/coreutils/who/who.c
+++ src.freebsd/coreutils/who/who.c
@@ -42,8 +42,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <time.h>
-#include <timeconv.h>
+#include <time_bsd.h>
 #include <unistd.h>
 #include <utmpx.h>
 
@@ -116,7 +115,7 @@
 		usage();
 
 	if (*argv != NULL) {
-		if (setutxdb(UTXDB_ACTIVE, *argv) != 0)
+		if (utmpxname(*argv) == 0)
 			err(1, "%s", *argv);
 	}
 
@@ -169,8 +168,10 @@
 	struct tm *tm;
 	char state;
 
-	if (d_first < 0)
-		d_first = (*nl_langinfo(D_MD_ORDER) == 'd');
+	if (d_first < 0) {
+		char *s = nl_langinfo(D_FMT);
+		d_first = (strchr(s, 'd') < strchr(s, 'm'));
+	}
 
 	state = '?';
 	idle = 0;
@@ -192,7 +193,7 @@
 		printf("%-12s ", ut->ut_line);
 	t = ut->ut_tv.tv_sec;
 	tm = localtime(&t);
-	strftime(buf, sizeof(buf), d_first ? "%e %b %R" : "%b %e %R", tm);
+	strftime_bsd(buf, sizeof(buf), d_first ? "%e %b %R" : "%b %e %R", tm);
 	printf("%-*s ", 12, buf);
 	if (uflag) {
 		if (idle < 60)
@@ -289,7 +290,7 @@
 	else
 		name = "?";
 	strlcpy(ut.ut_user, name, sizeof ut.ut_user);
-	gettimeofday(&ut.ut_tv, NULL);
+	gettimeofday((struct timeval *)&ut.ut_tv, NULL);
 	row(&ut);
 }
 
--- src.orig/coreutils/xinstall/install.1
+++ src.freebsd/coreutils/xinstall/install.1
@@ -32,47 +32,43 @@
 .Os
 .Sh NAME
 .Nm install
-.Nd install binaries
+.Nd install files
 .Sh SYNOPSIS
 .Nm
-.Op Fl bCcpSsUv
+.Op Fl bCcDpSsTv
 .Op Fl B Ar suffix
-.Op Fl D Ar destdir
-.Op Fl f Ar flags
 .Op Fl g Ar group
-.Op Fl h Ar hash
 .Op Fl l Ar linkflags
-.Op Fl M Ar metalog
 .Op Fl m Ar mode
 .Op Fl N Ar dbdir
 .Op Fl o Ar owner
-.Op Fl T Ar tags
 .Ar file1 file2
 .Nm
-.Op Fl bCcpSsUv
+.Op Fl bCcDpSsv
 .Op Fl B Ar suffix
-.Op Fl D Ar destdir
-.Op Fl f Ar flags
 .Op Fl g Ar group
-.Op Fl h Ar hash
 .Op Fl l Ar linkflags
-.Op Fl M Ar metalog
 .Op Fl m Ar mode
 .Op Fl N Ar dbdir
 .Op Fl o Ar owner
-.Op Fl T Ar tags
 .Ar file1 ... fileN directory
 .Nm
+.Op Fl bCcDpSsv
+.Op Fl B Ar suffix
+.Op Fl g Ar group
+.Op Fl l Ar linkflags
+.Op Fl m Ar mode
+.Op Fl N Ar dbdir
+.Op Fl o Ar owner
+.Fl t Ar directory
+.Ar file1 ... fileN
+.Nm
 .Fl d
-.Op Fl Uv
-.Op Fl D Ar destdir
+.Op Fl v
 .Op Fl g Ar group
-.Op Fl h Ar hash
-.Op Fl M Ar metalog
 .Op Fl m Ar mode
 .Op Fl N Ar dbdir
 .Op Fl o Ar owner
-.Op Fl T Ar tags
 .Ar directory ...
 .Sh DESCRIPTION
 The file(s) are copied
@@ -115,7 +111,7 @@
 Copy the file.
 If the target file already exists and the files are the same,
 then do not change the modification time of the target.
-If the target's file flags and mode need not to be changed,
+If the target's mode needs not to be changed,
 the target's inode change time is also unchanged.
 .It Fl c
 Copy the file.
@@ -123,51 +119,17 @@
 The
 .Fl c
 option is only included for backwards compatibility.
-.It Fl D Ar destdir
-Specify the
-.Ev DESTDIR
-(top of the file hierarchy) that the items are installed in to.
-If
-.Fl M Ar metalog
-is in use, a leading string of
-.Dq Ar destdir
-will be removed from the file names logged to the
-.Ar metalog .
-This option does not affect where the actual files are installed.
+.It Fl D
+Create all leading components of the destination directory except
+the last, or all components of
+.Fl t ,
+before copying.
 .It Fl d
 Create directories.
 Missing parent directories are created as required.
-.It Fl f Ar flags
-Specify the target's file flags; see
-.Xr chflags 1
-for a list of possible flags and their meanings.
 .It Fl g Ar group
 Specify a group.
 A numeric GID is allowed.
-.It Fl h Ar hash
-When copying, calculate the digest of the files with
-.Ar hash
-to store in the
-.Fl M Ar metalog .
-When
-.Fl d
-is given no hash is emitted.
-Supported digests:
-.Bl -tag -width rmd160 -offset indent
-.It Sy none
-No hash.
-This is the default.
-.It Sy md5
-The MD5 cryptographic message digest.
-.It Sy rmd160
-The RMD-160 cryptographic message digest.
-.It Sy sha1
-The SHA-1 cryptographic message digest.
-.It Sy sha256
-The 256-bits SHA-2 cryptographic message digest of the file.
-.It Sy sha512
-The 512-bits SHA-2 cryptographic message digest of the file.
-.El
 .It Fl l Ar linkflags
 Instead of copying the file make a link to the source.
 The type of the link is determined by the
@@ -189,15 +151,6 @@
 Absolute and relative have effect only for symbolic links.
 Mixed links
 are hard links for files on the same filesystem, symbolic otherwise.
-.It Fl M Ar metalog
-Write the metadata associated with each item installed to
-.Ar metalog
-in an
-.Xr mtree 8
-.Dq full path
-specification line.
-The metadata includes: the file name and file type, and depending upon
-other options, the owner, group, file flags, modification time, and tags.
 .It Fl m Ar mode
 Specify an alternate mode.
 The default mode is set to rwxr-xr-x (0755).
@@ -219,6 +172,8 @@
 .It Fl o Ar owner
 Specify an owner.
 A numeric UID is allowed.
+Typically this will only work as superuser.
+As normal user, a warning will be issued, but it is not a failure.
 .It Fl p
 Preserve the access and modification times.
 Copy the file, as if the
@@ -250,17 +205,11 @@
 See below for how
 .Nm
 can be instructed to use another program to strip binaries.
-.It Fl T Ar tags
-Specify the
-.Xr mtree 8
-tags to write out for the file when using
-.Fl M Ar metalog .
-.It Fl U
-Indicate that install is running unprivileged, and that it should not
-try to change the owner, the group, or the file flags of the destination.
-The information that would have been updated can be stored in a log
-file with
-.Fl M Ar metalog .
+.It Fl t Ar directory
+Copy all source arguments into the given
+.Ar directory .
+.It Fl T
+Treat the destination as a normal file.
 .It Fl v
 Cause
 .Nm
@@ -268,12 +217,6 @@
 showing files as they are installed or backed up.
 .El
 .Pp
-By default,
-.Nm
-preserves all file flags, with the exception of the
-.Dq nodump
-flag.
-.Pp
 The
 .Nm
 utility attempts to prevent moving a file onto itself.
@@ -320,8 +263,14 @@
 moved files by default.
 The default was changed to copy in
 .Fx 4.4 .
+.Pp
+This version in chimerautils is altered to use GNU-compatible
+arguments for
+.Fl D T t
+except when invoked as
+.Ar binstall
+which preserves the original semantics, which are not documented here.
 .Sh SEE ALSO
-.Xr chflags 1 ,
 .Xr chgrp 1 ,
 .Xr chmod 1 ,
 .Xr cp 1 ,
@@ -349,15 +298,6 @@
 Temporary files may be left in the target directory if
 .Nm
 exits abnormally.
-.Pp
-File flags cannot be set by
-.Xr fchflags 2
-over a NFS file system.
-Other file systems do not have a concept of flags.
-The
-.Nm
-utility will only warn when flags could not be set on a file system
-that does not support them.
 .Pp
 The
 .Nm
--- src.orig/coreutils/xinstall/xinstall.c
+++ src.freebsd/coreutils/xinstall/xinstall.c
@@ -42,6 +42,7 @@
 #endif /* not lint */
 #endif
 
+#include <sys/param.h>
 #include <sys/stat.h>
 #include <sys/time.h>
 #include <sys/wait.h>
@@ -70,9 +71,8 @@
 #include <sysexits.h>
 #include <unistd.h>
 #include <vis.h>
+#include <getopt.h>
 
-#include "mtree.h"
-
 /*
  * Memory strategy threshold, in pages: if physmem is larger then this, use a
  * large buffer.
@@ -142,13 +142,13 @@
 static gid_t gid;
 static uid_t uid;
 static int dobackup, docompare, dodir, dolink, dopreserve, dostrip, dounpriv,
-    safecopy, verbose;
+    dopdir, safecopy, verbose, gnumode;
 static int haveopt_f, haveopt_g, haveopt_m, haveopt_o;
 static mode_t mode = S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH;
 static FILE *metafp;
 static const char *group, *owner;
 static const char *suffix = BACKUP_SUFFIX;
-static char *destdir, *digest, *fflags, *metafile, *tags;
+static char *destdir, *digest, *fflags, *metafile, *tags, *targdir;
 
 static int	compare(int, const char *, size_t, int, const char *, size_t,
 		    char **);
@@ -163,13 +163,22 @@
 static void	do_symlink(const char *, const char *, const struct stat *);
 static void	makelink(const char *, const char *, const struct stat *);
 static void	install(const char *, const char *, u_long, u_int);
-static void	install_dir(char *);
+static void	install_dir(char *, mode_t);
 static void	metadata_log(const char *, const char *, struct timespec *,
 		    const char *, const char *, off_t);
 static int	parseid(const char *, id_t *);
 static int	strip(const char *, int, const char *, char **);
 static void	usage(void);
 
+static int
+do_getopt(int argc, char **argv)
+{
+	if (!gnumode)
+		return getopt(argc, argv, "B:bCcD:dg:h:l:M:m:o:pSsT:Uv");
+	/* use getopt_long to get argument interposition */
+	return getopt_long(argc, argv, "B:bCcDdg:l:m:o:pSst:Tv", NULL, NULL);
+}
+
 int
 main(int argc, char *argv[])
 {
@@ -180,13 +189,14 @@
 	u_int iflags;
 	char *p;
 	const char *to_name;
+	int notarg = 0;
 
+	gnumode = !!strcmp(getprogname(), "binstall");
 	fset = 0;
 	iflags = 0;
 	set = NULL;
 	group = owner = NULL;
-	while ((ch = getopt(argc, argv, "B:bCcD:df:g:h:l:M:m:N:o:pSsT:Uv")) !=
-	     -1)
+	while ((ch = do_getopt(argc, argv)) != -1)
 		switch((char)ch) {
 		case 'B':
 			suffix = optarg;
@@ -201,15 +211,18 @@
 			/* For backwards compatibility. */
 			break;
 		case 'D':
-			destdir = optarg;
+			if (gnumode) dopdir = 1;
+			else destdir = optarg;
 			break;
 		case 'd':
 			dodir = 1;
 			break;
+#if 0
 		case 'f':
 			haveopt_f = 1;
 			fflags = optarg;
 			break;
+#endif
 		case 'g':
 			haveopt_g = 1;
 			group = optarg;
@@ -255,11 +268,13 @@
 				errx(EX_USAGE, "invalid file mode: %s",
 				     optarg);
 			break;
+#if 0
 		case 'N':
 			if (!setup_getid(optarg))
 				err(EX_OSERR, "Unable to use user and group "
 				    "databases in `%s'", optarg);
 			break;
+#endif
 		case 'o':
 			haveopt_o = 1;
 			owner = optarg;
@@ -273,8 +288,16 @@
 		case 's':
 			dostrip = 1;
 			break;
+		case 't':
+			targdir = optarg;
+			if (notarg) errx(EX_USAGE, "cannot combine -T and -t");
+			break;
 		case 'T':
-			tags = optarg;
+			if (gnumode) {
+				notarg = 1;
+				if (targdir) errx(EX_USAGE, "cannot combine -T and -t");
+			}
+			else tags = optarg;
 			break;
 		case 'U':
 			dounpriv = 1;
@@ -294,6 +317,14 @@
 		warnx("-d and -s may not be specified together");
 		usage();
 	}
+	if (dopdir && dodir) {
+		warnx("-d and -D may not be specified together");
+		usage();
+	}
+	if (targdir && dodir) {
+		warnx("-d and -t may not be specified together");
+		usage();
+	}
 
 	/*
 	 * Default permissions based on whether we're a directory or not, since
@@ -309,7 +340,7 @@
 	}
 
 	/* must have at least two arguments, except when creating directories */
-	if (argc == 0 || (argc == 1 && !dodir))
+	if (argc == 0 || (argc == 1 && !dodir && !targdir))
 		usage();
 
 	if (digest != NULL) {
@@ -337,30 +368,38 @@
 
 	/* get group and owner id's */
 	if (group != NULL && !dounpriv) {
-		if (gid_from_group(group, &gid) == -1) {
+		struct group *gr = getgrnam(group);
+		if (!gr) {
 			id_t id;
 			if (!parseid(group, &id))
 				errx(1, "unknown group %s", group);
 			gid = id;
+		} else {
+			gid = gr->gr_gid;
 		}
 	} else
 		gid = (gid_t)-1;
 
 	if (owner != NULL && !dounpriv) {
-		if (uid_from_user(owner, &uid) == -1) {
+		struct passwd *pw = getpwnam(owner);
+		if (!pw) {
 			id_t id;
 			if (!parseid(owner, &id))
 				errx(1, "unknown user %s", owner);
 			uid = id;
+		} else {
+			uid = pw->pw_uid;
 		}
 	} else
 		uid = (uid_t)-1;
 
+#if 0
 	if (fflags != NULL && !dounpriv) {
 		if (strtofflags(&fflags, &fset, NULL))
 			errx(EX_USAGE, "%s: invalid flag", fflags);
 		iflags |= SETFLAGS;
 	}
+#endif
 
 	if (metafile != NULL) {
 		if ((metafp = fopen(metafile, "a")) == NULL)
@@ -370,14 +409,26 @@
 
 	if (dodir) {
 		for (; *argv != NULL; ++argv)
-			install_dir(*argv);
+			install_dir(*argv, mode);
 		exit(EX_OK);
 		/* NOTREACHED */
+	} else if (dopdir) {
+		mode_t dmode = S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH;
+		if (targdir) install_dir(targdir, dmode);
+		else {
+			char *bsl = strrchr(argv[argc - 1], '/');
+			if (bsl && bsl != argv[argc - 1]) {
+				*bsl = '\0';
+				install_dir(argv[argc - 1], dmode);
+				*bsl = '/';
+			}
+		}
 	}
 
-	to_name = argv[argc - 1];
+	to_name = targdir ? targdir : argv[argc - 1];
 	no_target = stat(to_name, &to_sb);
 	if (!no_target && S_ISDIR(to_sb.st_mode)) {
+		if (notarg) errx(EX_OSERR, "cannot overwrite directory '%s' with non-directory", to_name);
 		if (dolink & LN_SYMBOLIC) {
 			if (lstat(to_name, &to_sb) != 0)
 				err(EX_OSERR, "%s vanished", to_name);
@@ -390,11 +441,12 @@
 				exit(EX_OK);
 			}
 		}
-		for (; *argv != to_name; ++argv)
+		for (; *argv != (targdir ? NULL : to_name); ++argv)
 			install(*argv, to_name, fset, iflags | DIRECTORY);
 		exit(EX_OK);
 		/* NOTREACHED */
-	}
+	} else if (targdir)
+		err(EX_OSERR, "failed to access '%s'", targdir);
 
 	/* can't do file1 file2 directory/file */
 	if (argc != 2) {
@@ -411,7 +463,7 @@
 		if (stat(*argv, &from_sb))
 			err(EX_OSERR, "%s", *argv);
 		if (!S_ISREG(to_sb.st_mode))
-			errc(EX_CANTCREAT, EFTYPE, "%s", to_name);
+			errx(EX_CANTCREAT, "%s: not a regular file", to_name);
 		if (to_sb.st_dev == from_sb.st_dev &&
 		    to_sb.st_ino == from_sb.st_ino) {
 			errx(EX_USAGE, "%s and %s are the same file",
@@ -554,7 +606,7 @@
 {
 	int fd;
 
-	if ((fd = mkstemp(template)) == -1)
+	if ((fd = compat_mkstemp(template)) == -1)
 		return (NULL);
 	close (fd);
 	if (unlink(template) == -1)
@@ -571,7 +623,7 @@
 do_link(const char *from_name, const char *to_name,
     const struct stat *target_sb)
 {
-	char tmpl[MAXPATHLEN];
+	char tmpl[MAXPATHLEN + 12];
 	int ret;
 
 	if (target_sb != NULL) {
@@ -811,7 +863,7 @@
  *	build a path name and install the file
  */
 static void
-install(const char *from_name, const char *to_name, u_long fset, u_int flags)
+install(const char *from_name, const char *to_name, u_long fset __unused, u_int flags)
 {
 	struct stat from_sb, temp_sb, to_sb;
 	struct timespec tsb[2];
@@ -831,7 +883,7 @@
 			if (stat(from_name, &from_sb))
 				err(EX_OSERR, "%s", from_name);
 			if (!S_ISREG(from_sb.st_mode))
-				errc(EX_OSERR, EFTYPE, "%s", from_name);
+				errx(EX_OSERR, "%s: not a regular file", from_name);
 		}
 		/* Build the target path. */
 		if (flags & DIRECTORY) {
@@ -856,7 +908,7 @@
 	}
 
 	if (target && !S_ISREG(to_sb.st_mode) && !S_ISLNK(to_sb.st_mode))
-		errc(EX_CANTCREAT, EFTYPE, "%s", to_name);
+		errx(EX_CANTCREAT, "%s: not a regular file or symlink", to_name);
 
 	if (!devnull && (from_fd = open(from_name, O_RDONLY, 0)) < 0)
 		err(EX_OSERR, "%s", from_name);
@@ -1037,9 +1089,11 @@
 	    (uid != (uid_t)-1 && uid != to_sb.st_uid))) {
 		if (fchown(to_fd, uid, gid) == -1) {
 			serrno = errno;
-			(void)unlink(to_name);
-			errno = serrno;
-			err(EX_OSERR,"%s: chown/chgrp", to_name);
+			if (!gnumode) {
+				(void)unlink(to_name);
+				errno = serrno;
+				err(EX_OSERR,"%s: chown/chgrp", to_name);
+			} else warn("%s: chown/chgrp", to_name);
 		}
 	}
 	if (mode != (to_sb.st_mode & ALLPERMS)) {
@@ -1149,14 +1203,14 @@
 		lseek(from_fd, 0, SEEK_SET);
 		lseek(to_fd, 0, SEEK_SET);
 	} else {
-		rv = 1;	/* don't bother in this case */
+		return 1;	/* don't bother in this case */
 	}
 
 	if (do_digest) {
 		if (rv == 0)
 			*dresp = digest_end(&ctx, NULL);
 		else
-			(void)digest_end(&ctx, NULL);
+			free(digest_end(&ctx, NULL));
 	}
 
 	return rv;
@@ -1179,7 +1233,7 @@
 		p = temp;
 	(void)strncpy(p, "INS@XXXXXX", &temp[tsize - 1] - p);
 	temp[tsize - 1] = '\0';
-	return (mkstemp(temp));
+	return (compat_mkstemp(temp));
 }
 
 /*
@@ -1214,11 +1268,17 @@
 		} while (ret > 0);
 		if (ret == 0)
 			goto done;
-		if (errno != EINVAL) {
+		switch (errno) {
+		case EINVAL:
+		case ENOSYS:
+		case EXDEV:
+			break;
+		default:
 			serrno = errno;
 			(void)unlink(to_name);
 			errno = serrno;
 			err(EX_OSERR, "%s", to_name);
+			break;
 		}
 		/* Fall back */
 	}
@@ -1317,7 +1377,7 @@
 	    __DECONST(char **, args), environ);
 	if (error != 0) {
 		(void)unlink(to_name);
-		errc(error == EAGAIN || error == EPROCLIM || error == ENOMEM ?
+		errc(error == EAGAIN || error == ENOMEM ?
 		    EX_TEMPFAIL : EX_OSERR, error, "spawn %s", stripbin);
 	}
 	free(prefixed_from_name);
@@ -1350,7 +1410,7 @@
  *	build directory hierarchy
  */
 static void
-install_dir(char *path)
+install_dir(char *path, mode_t dmode)
 {
 	char *p;
 	struct stat sb;
@@ -1385,8 +1445,8 @@
 		    chown(path, uid, gid))
 			warn("chown %u:%u %s", uid, gid, path);
 		/* XXXBED: should we do the chmod in the dounpriv case? */
-		if (chmod(path, mode))
-			warn("chmod %o %s", mode, path);
+		if (chmod(path, dmode))
+			warn("chmod %o %s", dmode, path);
 	}
 	metadata_log(path, "dir", NULL, NULL, NULL, 0);
 }
@@ -1483,16 +1543,16 @@
 usage(void)
 {
 	(void)fprintf(stderr,
-"usage: install [-bCcpSsUv] [-f flags] [-g group] [-m mode] [-o owner]\n"
-"               [-M log] [-D dest] [-h hash] [-T tags]\n"
+"usage: install [-bCcDpSsTv] [-g group] [-m mode] [-o owner]\n"
 "               [-B suffix] [-l linkflags] [-N dbdir]\n"
 "               file1 file2\n"
-"       install [-bCcpSsUv] [-f flags] [-g group] [-m mode] [-o owner]\n"
-"               [-M log] [-D dest] [-h hash] [-T tags]\n"
+"       install [-bCcDpSsv] [-g group] [-m mode] [-o owner]\n"
 "               [-B suffix] [-l linkflags] [-N dbdir]\n"
 "               file1 ... fileN directory\n"
-"       install -dU [-vU] [-g group] [-m mode] [-N dbdir] [-o owner]\n"
-"               [-M log] [-D dest] [-h hash] [-T tags]\n"
+"       install [-bCcDpSsv] [-g group] [-m mode] [-o owner]\n"
+"               [-B suffix] [-l linkflags] [-N dbdir] -t directory\n"
+"               file1 ... fileN\n"
+"       install -d [-v] [-g group] [-m mode] [-N dbdir] [-o owner]\n"
 "               directory ...\n");
 	exit(EX_USAGE);
 	/* NOTREACHED */
--- src.orig/dbcompat/btree/bt_close.c
+++ src.freebsd/dbcompat/btree/bt_close.c
@@ -35,7 +35,7 @@
 #if defined(LIBC_SCCS) && !defined(lint)
 static char sccsid[] = "@(#)bt_close.c	8.7 (Berkeley) 8/17/94";
 #endif /* LIBC_SCCS and not lint */
-#include "namespace.h"
+#include <sys/cdefs.h>
 #include <sys/param.h>
 
 #include <errno.h>
@@ -43,7 +43,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
-#include "un-namespace.h"
 
 #include <db.h>
 #include "btree.h"
@@ -101,7 +100,7 @@
 	fd = t->bt_fd;
 	free(t);
 	free(dbp);
-	return (_close(fd) ? RET_ERROR : RET_SUCCESS);
+	return (close(fd) ? RET_ERROR : RET_SUCCESS);
 }
 
 /*
--- src.orig/dbcompat/btree/bt_delete.c
+++ src.freebsd/dbcompat/btree/bt_delete.c
@@ -141,7 +141,7 @@
 	EPG *e;
 	EPGNO *parent;
 	PAGE *h;
-	indx_t idx;
+	indx_t idx = 0;
 	pgno_t pgno;
 	recno_t nextpg, prevpg;
 	int exact, level;
--- src.orig/dbcompat/btree/bt_open.c
+++ src.freebsd/dbcompat/btree/bt_open.c
@@ -43,7 +43,6 @@
  * is wholly independent of the Postgres code.
  */
 
-#include "namespace.h"
 #include <sys/param.h>
 #include <sys/stat.h>
 
@@ -55,8 +54,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
-#include "un-namespace.h"
-#include "libc_private.h"
 
 #include <db.h>
 #include "btree.h"
@@ -196,7 +193,7 @@
 			goto einval;
 		}
 
-		if ((t->bt_fd = _open(fname, flags | O_CLOEXEC, mode)) < 0)
+		if ((t->bt_fd = open(fname, flags | O_CLOEXEC, mode)) < 0)
 			goto err;
 
 	} else {
@@ -207,10 +204,10 @@
 		F_SET(t, B_INMEM);
 	}
 
-	if (_fstat(t->bt_fd, &sb))
+	if (fstat(t->bt_fd, &sb))
 		goto err;
 	if (sb.st_size) {
-		if ((nr = _read(t->bt_fd, &m, sizeof(BTMETA))) < 0)
+		if ((nr = read(t->bt_fd, &m, sizeof(BTMETA))) < 0)
 			goto err;
 		if (nr != sizeof(BTMETA))
 			goto eftype;
@@ -319,7 +316,7 @@
 einval:	errno = EINVAL;
 	goto err;
 
-eftype:	errno = EFTYPE;
+eftype:	errno = EINVAL;
 	goto err;
 
 err:	saved_errno = errno;
@@ -327,7 +324,7 @@
 		if (t->bt_dbp)
 			free(t->bt_dbp);
 		if (t->bt_fd != -1)
-			(void)_close(t->bt_fd);
+			(void)close(t->bt_fd);
 		free(t);
 	}
 	errno = saved_errno;
@@ -400,10 +397,10 @@
 	}
 
 	(void)sigfillset(&set);
-	(void)__libc_sigprocmask(SIG_BLOCK, &set, &oset);
-	if ((fd = mkostemp(path, O_CLOEXEC)) != -1)
+	(void)sigprocmask(SIG_BLOCK, &set, &oset);
+	if ((fd = compat_mkostemp(path, O_CLOEXEC)) != -1)
 		(void)unlink(path);
-	(void)__libc_sigprocmask(SIG_SETMASK, &oset, NULL);
+	(void)sigprocmask(SIG_SETMASK, &oset, NULL);
 	return(fd);
 }
 
--- src.orig/dbcompat/btree/bt_put.c
+++ src.freebsd/dbcompat/btree/bt_put.c
@@ -65,7 +65,7 @@
 {
 	BTREE *t;
 	DBT tkey, tdata;
-	EPG *e;
+	EPG *e = NULL;
 	PAGE *h;
 	indx_t idx, nxtindex;
 	pgno_t pg;
--- src.orig/dbcompat/btree/bt_seq.c
+++ src.freebsd/dbcompat/btree/bt_seq.c
@@ -231,7 +231,7 @@
 {
 	CURSOR *c;
 	PAGE *h;
-	indx_t idx;
+	indx_t idx = 0;
 	pgno_t pg;
 	int exact;
 
--- src.orig/dbcompat/btree/bt_split.c
+++ src.freebsd/dbcompat/btree/bt_split.c
@@ -45,6 +45,10 @@
 #include <db.h>
 #include "btree.h"
 
+#ifndef __PAST_END
+#define __PAST_END(array, offset) (((__typeof__(*(array)) *)(array))[offset])
+#endif
+
 static int	 bt_broot(BTREE *, PAGE *, PAGE *, PAGE *);
 static PAGE	*bt_page(BTREE *, PAGE *, PAGE **, PAGE **, indx_t *, size_t);
 static int	 bt_preserve(BTREE *, pgno_t);
@@ -76,14 +80,14 @@
 __bt_split(BTREE *t, PAGE *sp, const DBT *key, const DBT *data, int flags,
     size_t ilen, u_int32_t argskip)
 {
-	BINTERNAL *bi;
-	BLEAF *bl, *tbl;
+	BINTERNAL *bi = NULL;
+	BLEAF *bl = NULL, *tbl;
 	DBT a, b;
 	EPGNO *parent;
 	PAGE *h, *l, *r, *lchild, *rchild;
 	indx_t nxtindex;
 	u_int16_t skip;
-	u_int32_t n, nbytes, nksize;
+	u_int32_t n, nbytes, nksize = 0;
 	int parentsplit;
 	char *dest;
 
@@ -597,7 +601,7 @@
 	CURSOR *c;
 	RLEAF *rl;
 	PAGE *rval;
-	void *src;
+	void *src = NULL;
 	indx_t full, half, nxt, off, skip, top, used;
 	u_int32_t nbytes;
 	int bigkeycnt, isbigkey;
--- src.orig/dbcompat/db.c
+++ src.freebsd/dbcompat/db.c
@@ -41,8 +41,6 @@
 
 #include <db.h>
 
-static int __dberr(void);
-
 #ifndef O_CLOEXEC
 #define O_CLOEXEC 0
 #endif
@@ -68,8 +66,13 @@
 			return (__bt_open(fname, flags & USE_OPEN_FLAGS,
 			    mode, openinfo, flags & DB_FLAGS));
 		case DB_HASH:
+#if 0
+/* libdbcompat: not supported */
 			return (__hash_open(fname, flags & USE_OPEN_FLAGS,
 			    mode, openinfo, flags & DB_FLAGS));
+#else
+			break;
+#endif
 		case DB_RECNO:
 			return (__rec_open(fname, flags & USE_OPEN_FLAGS,
 			    mode, openinfo, flags & DB_FLAGS));
@@ -79,11 +82,59 @@
 }
 
 static int
-__dberr(void)
+__dberr_del(const struct __db *db, const DBT *dbt, u_int flags)
 {
+	(void)db;
+	(void)dbt;
+	(void)flags;
 	return (RET_ERROR);
 }
 
+static int
+__dberr_fd(const struct __db *db)
+{
+	(void)db;
+	return (RET_ERROR);
+}
+
+static int
+__dberr_get(const struct __db *db, const DBT *key, DBT *data, u_int flags)
+{
+	(void)db;
+	(void)key;
+	(void)data;
+	(void)flags;
+	return (RET_ERROR);
+}
+
+static int
+__dberr_put(const struct __db *db, DBT *key, const DBT *data, u_int flags)
+{
+	(void)db;
+	(void)key;
+	(void)data;
+	(void)flags;
+	return (RET_ERROR);
+}
+
+static int
+__dberr_seq(const struct __db *db, DBT *key, DBT *data, u_int flags)
+{
+	(void)db;
+	(void)key;
+	(void)data;
+	(void)flags;
+	return (RET_ERROR);
+}
+
+static int
+__dberr_sync(const struct __db *db, u_int flags)
+{
+	(void)db;
+	(void)flags;
+	return (RET_ERROR);
+}
+
 /*
  * __DBPANIC -- Stop.
  *
@@ -94,10 +145,10 @@
 __dbpanic(DB *dbp)
 {
 	/* The only thing that can succeed is a close. */
-	dbp->del = (int (*)(const struct __db *, const DBT*, u_int))__dberr;
-	dbp->fd = (int (*)(const struct __db *))__dberr;
-	dbp->get = (int (*)(const struct __db *, const DBT*, DBT *, u_int))__dberr;
-	dbp->put = (int (*)(const struct __db *, DBT *, const DBT *, u_int))__dberr;
-	dbp->seq = (int (*)(const struct __db *, DBT *, DBT *, u_int))__dberr;
-	dbp->sync = (int (*)(const struct __db *, u_int))__dberr;
+	dbp->del = __dberr_del;
+	dbp->fd = __dberr_fd;
+	dbp->get = __dberr_get;
+	dbp->put = __dberr_put;
+	dbp->seq = __dberr_seq;
+	dbp->sync = __dberr_sync;
 }
--- src.orig/dbcompat/mpool.c
+++ src.freebsd/dbcompat/mpool.c
@@ -32,7 +32,7 @@
 #if defined(LIBC_SCCS) && !defined(lint)
 static char sccsid[] = "@(#)mpool.c	8.7 (Berkeley) 11/2/95";
 #endif /* LIBC_SCCS and not lint */
-#include "namespace.h"
+#include <sys/cdefs.h>
 #include <sys/param.h>
 #include <sys/queue.h>
 #include <sys/stat.h>
@@ -42,7 +42,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
-#include "un-namespace.h"
 
 #include <db.h>
 
@@ -65,13 +64,15 @@
 	MPOOL *mp;
 	int entry;
 
+	(void)key;
+
 	/*
 	 * Get information about the file.
 	 *
 	 * XXX
 	 * We don't currently handle pipes, although we should.
 	 */
-	if (_fstat(fd, &sb))
+	if (fstat(fd, &sb))
 		return (NULL);
 	if (!S_ISREG(sb.st_mode)) {
 		errno = ESPIPE;
@@ -275,6 +276,8 @@
 
 #ifdef STATISTICS
 	++mp->pageput;
+#else
+	(void)mp;
 #endif
 	bp = (BKT *)((char *)page - sizeof(BKT));
 #ifdef DEBUG
@@ -327,7 +330,7 @@
 			return (RET_ERROR);
 
 	/* Sync the file descriptor. */
-	return (_fsync(mp->fd) ? RET_ERROR : RET_SUCCESS);
+	return (fsync(mp->fd) ? RET_ERROR : RET_SUCCESS);
 }
 
 /*
--- src.orig/dbcompat/recno/rec_close.c
+++ src.freebsd/dbcompat/recno/rec_close.c
@@ -32,7 +32,7 @@
 #if defined(LIBC_SCCS) && !defined(lint)
 static char sccsid[] = "@(#)rec_close.c	8.6 (Berkeley) 8/18/94";
 #endif /* LIBC_SCCS and not lint */
-#include "namespace.h"
+#include <sys/cdefs.h>
 #include <sys/types.h>
 #include <sys/uio.h>
 #include <sys/mman.h>
@@ -41,7 +41,6 @@
 #include <limits.h>
 #include <stdio.h>
 #include <unistd.h>
-#include "un-namespace.h"
 
 #include <db.h>
 #include "recno.h"
@@ -82,7 +81,7 @@
 			if (fclose(t->bt_rfp))
 				status = RET_ERROR;
 		} else {
-			if (_close(t->bt_rfd))
+			if (close(t->bt_rfd))
 				status = RET_ERROR;
 		}
 	}
@@ -148,7 +147,7 @@
 		 */
 		status = (dbp->seq)(dbp, &key, &data, R_FIRST);
 		while (status == RET_SUCCESS) {
-			if (_write(t->bt_rfd, data.data, data.size) !=
+			if (write(t->bt_rfd, data.data, data.size) !=
 			    (ssize_t)data.size)
 				return (RET_ERROR);
 			status = (dbp->seq)(dbp, &key, &data, R_NEXT);
@@ -161,7 +160,7 @@
 		while (status == RET_SUCCESS) {
 			iov[0].iov_base = data.data;
 			iov[0].iov_len = data.size;
-			if (_writev(t->bt_rfd, iov, 2) != (ssize_t)(data.size + 1))
+			if (writev(t->bt_rfd, iov, 2) != (ssize_t)(data.size + 1))
 				return (RET_ERROR);
 			status = (dbp->seq)(dbp, &key, &data, R_NEXT);
 		}
--- src.orig/dbcompat/recno/rec_open.c
+++ src.freebsd/dbcompat/recno/rec_open.c
@@ -35,7 +35,7 @@
 #if defined(LIBC_SCCS) && !defined(lint)
 static char sccsid[] = "@(#)rec_open.c	8.10 (Berkeley) 9/1/94";
 #endif /* LIBC_SCCS and not lint */
-#include "namespace.h"
+#include <sys/cdefs.h>
 #include <sys/types.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
@@ -46,7 +46,6 @@
 #include <stddef.h>
 #include <stdio.h>
 #include <unistd.h>
-#include "un-namespace.h"
 
 #include <db.h>
 #include "recno.h"
@@ -60,10 +59,10 @@
 	DB *dbp;
 	PAGE *h;
 	struct stat sb;
-	int rfd, sverrno;
+	int rfd = -1, sverrno;
 
 	/* Open the user's file -- if this fails, we're done. */
-	if (fname != NULL && (rfd = _open(fname, flags | O_CLOEXEC, mode)) < 0)
+	if (fname != NULL && (rfd = open(fname, flags | O_CLOEXEC, mode)) < 0)
 		return (NULL);
 
 	/* Create a btree in memory (backed by disk). */
@@ -141,7 +140,7 @@
 				goto einval;
 			}
 
-			if (_fstat(rfd, &sb))
+			if (fstat(rfd, &sb))
 				goto err;
 			/*
 			 * Kluge -- we'd like to test to see if the file is too
@@ -210,7 +209,7 @@
 	if (dbp != NULL)
 		(void)__bt_close(dbp);
 	if (fname != NULL)
-		(void)_close(rfd);
+		(void)close(rfd);
 	errno = sverrno;
 	return (NULL);
 }
--- src.orig/dbinclude/db.h
+++ src.freebsd/dbinclude/db.h
@@ -38,6 +38,7 @@
 #include <sys/cdefs.h>
 
 #include <limits.h>
+#include <stdint.h>
 
 #define	RET_ERROR	-1		/* Return values. */
 #define	RET_SUCCESS	 0
@@ -204,9 +205,7 @@
 #endif
 
 __BEGIN_DECLS
-#if __BSD_VISIBLE
 DB *dbopen(const char *, int, int, DBTYPE, const void *);
-#endif
 
 #ifdef __DBINTERFACE_PRIVATE
 DB	*__bt_open(const char *, int, int, const BTREEINFO *, int);
--- src.orig/diffutils/cmp/cmp.c
+++ src.freebsd/diffutils/cmp/cmp.c
@@ -56,6 +56,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <signal.h>
 
 #include <libutil.h>
 
@@ -90,16 +91,22 @@
 parse_iskipspec(char *spec, off_t *skip1, off_t *skip2)
 {
 	char *colon;
+	uint64_t uskip1, uskip2;
 
 	colon = strchr(spec, ':');
 	if (colon != NULL)
 		*colon++ = '\0';
 
-	if (expand_number(spec, skip1) < 0)
+	if (expand_number(spec, &uskip1) < 0)
 		return (false);
+	*skip1 = uskip1;
 
-	if (colon != NULL)
-		return (expand_number(colon, skip2) == 0);
+	if (colon != NULL) {
+		if (expand_number(colon, &uskip2) < 0)
+			return false;
+		*skip2 = uskip2;
+		return true;
+	}
 
 	*skip2 = *skip1;
 	return (true);
@@ -110,12 +117,14 @@
 {
 	struct stat sb1, sb2;
 	off_t skip1, skip2, limit;
+	uint64_t uskip1, uskip2, ulimit;
 	int ch, fd1, fd2, oflag;
 	bool special;
 	const char *file1, *file2;
 	int ret;
 
 	limit = skip1 = skip2 = ret = 0;
+	ulimit = uskip1 = uskip2 = 0;
 	oflag = O_RDONLY;
 	while ((ch = getopt_long(argc, argv, "+bhi:ln:sxz", long_opts, NULL)) != -1)
 		switch (ch) {
@@ -137,7 +146,7 @@
 			lflag = true;
 			break;
 		case 'n':		/* Limit */
-			if (expand_number(optarg, &limit) < 0 || limit < 0) {
+			if (expand_number(optarg, &ulimit) < 0 || ((limit = ulimit) < 0)) {
 				fprintf(stderr, "Invalid --bytes: %s\n",
 				    optarg);
 				usage();
@@ -198,15 +207,17 @@
 			exit(ERR_EXIT);
 	}
 
-	if (argc > 2 && expand_number(argv[2], &skip1) < 0) {
+	if (argc > 2 && expand_number(argv[2], &uskip1) < 0) {
 		fprintf(stderr, "Invalid skip1: %s\n", argv[2]);
 		usage();
 	}
+	skip1 = uskip1;
 
-	if (argc == 4 && expand_number(argv[3], &skip2) < 0) {
+	if (argc == 4 && expand_number(argv[3], &uskip2) < 0) {
 		fprintf(stderr, "Invalid skip2: %s\n", argv[3]);
 		usage();
 	}
+	skip2 = uskip2;
 
 	if (sflag && skip1 == 0 && skip2 == 0)
 		zflag = true;
--- src.orig/diffutils/cmp/extern.h
+++ src.freebsd/diffutils/cmp/extern.h
@@ -32,6 +32,8 @@
  *
  */
 
+#include <stdbool.h>
+
 #define OK_EXIT		0
 #define DIFF_EXIT	1
 #define ERR_EXIT	2	/* error exit code */
--- src.orig/diffutils/cmp/regular.c
+++ src.freebsd/diffutils/cmp/regular.c
@@ -39,6 +39,7 @@
 #include <sys/param.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
+#include <sys/types.h>
 
 #include <capsicum_helpers.h>
 #include <err.h>
--- src.orig/diffutils/diff/diff.c
+++ src.freebsd/diffutils/diff/diff.c
@@ -482,20 +482,23 @@
 read_excludes_file(char *file)
 {
 	FILE *fp;
-	char *buf, *pattern;
-	size_t len;
+	char *pattern = NULL;
+	size_t blen = 0;
+	ssize_t len;
 
 	if (strcmp(file, "-") == 0)
 		fp = stdin;
 	else if ((fp = fopen(file, "r")) == NULL)
 		err(2, "%s", file);
-	while ((buf = fgetln(fp, &len)) != NULL) {
-		if (buf[len - 1] == '\n')
-			len--;
-		if ((pattern = strndup(buf, len)) == NULL)
-			err(2, "xstrndup");
+	while ((len = getline(&pattern, &blen, fp)) >= 0) {
+		if ((len > 0) && (pattern[len - 1] == '\n'))
+			pattern[len - 1] = '\0';
 		push_excludes(pattern);
+		/* we allocate a new string per line */
+		pattern = NULL;
+		blen = 0;
 	}
+	free(pattern);
 	if (strcmp(file, "-") != 0)
 		fclose(fp);
 }
--- src.orig/diffutils/diff/diff.h
+++ src.freebsd/diffutils/diff/diff.h
@@ -114,3 +114,11 @@
 int	diffreg(char *, char *, int, int);
 void	diffdir(char *, char *, int);
 void	print_status(int, char *, char *, const char *);
+
+#ifndef MIN
+#define MIN(X, Y) (((X) < (Y)) ? (X) : (Y))
+#endif
+
+#ifndef MAX
+#define MAX(X, Y) (((X) > (Y)) ? (X) : (Y))
+#endif
--- src.orig/diffutils/diff/diffreg.c
+++ src.freebsd/diffutils/diff/diffreg.c
@@ -69,6 +69,7 @@
 #include <sys/cdefs.h>
 #include <sys/capsicum.h>
 #include <sys/stat.h>
+#include <sys/param.h>
 
 #include <capsicum_helpers.h>
 #include <ctype.h>
@@ -84,6 +85,9 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <unistd.h>
+#include <limits.h>
+#include <time_bsd.h>
 
 #include "pr.h"
 #include "diff.h"
@@ -497,7 +501,7 @@
 
 	(void)strlcpy(tempfile, _PATH_TMP "/diff.XXXXXXXX", sizeof(tempfile));
 
-	if ((ofd = mkstemp(tempfile)) == -1) {
+	if ((ofd = compat_mkstemp(tempfile)) == -1) {
 		close(ifd);
 		return (NULL);
 	}
@@ -1416,7 +1420,7 @@
 static char *
 match_function(const long *f, int pos, FILE *fp)
 {
-	unsigned char buf[FUNCTION_CONTEXT_SIZE];
+	char buf[FUNCTION_CONTEXT_SIZE];
 	size_t nc;
 	int last = lastline;
 	const char *state = NULL;
@@ -1658,11 +1662,11 @@
 		printf("%s %s\n", diff_format == D_CONTEXT ? "***" : "---",
 		    label[0]);
 	else {
-		strftime(buf, sizeof(buf), time_format, tm_ptr1);
+		strftime_bsd(buf, sizeof(buf), time_format, tm_ptr1);
 		printf("%s %s\t%s", diff_format == D_CONTEXT ? "***" : "---",
 		    file1, buf);
 		if (!cflag) {
-			strftime(buf, sizeof(buf), "%z", tm_ptr1);
+			strftime_bsd(buf, sizeof(buf), "%z", tm_ptr1);
 			printf(".%.9d %s", nsec1, buf);
 		}
 		printf("\n");
@@ -1671,11 +1675,11 @@
 		printf("%s %s\n", diff_format == D_CONTEXT ? "---" : "+++",
 		    label[1]);
 	else {
-		strftime(buf, sizeof(buf), time_format, tm_ptr2);
+		strftime_bsd(buf, sizeof(buf), time_format, tm_ptr2);
 		printf("%s %s\t%s", diff_format == D_CONTEXT ? "---" : "+++",
 		    file2, buf);
 		if (!cflag) {
-			strftime(buf, sizeof(buf), "%z", tm_ptr2);
+			strftime_bsd(buf, sizeof(buf), "%z", tm_ptr2);
 			printf(".%.9d %s", nsec2, buf);
 		}
 		printf("\n");
--- src.orig/diffutils/diff/pr.c
+++ src.freebsd/diffutils/diff/pr.c
@@ -25,7 +25,6 @@
  */
 
 #include <sys/cdefs.h>
-#include <sys/procdesc.h>
 #include <sys/wait.h>
 
 #include <err.h>
@@ -34,6 +33,9 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <poll.h>
 
 #include "pr.h"
 #include "diff.h"
@@ -41,11 +43,19 @@
 
 #define _PATH_PR "/usr/bin/pr"
 
+static int sigpipe[2] = {-1, -1};
+static struct pollfd poll_fd;
+
+static void
+handle_sig(int signo)
+{
+	write(sigpipe[1], &signo, sizeof(signo));
+}
+
 struct pr *
 start_pr(char *file1, char *file2)
 {
 	int pfd[2];
-	int pr_pd;
 	pid_t pid;
 	char *header;
 	struct pr *pr;
@@ -58,7 +68,20 @@
 	rewind(stdout);
 	if (pipe(pfd) == -1)
 		err(2, "pipe");
-	switch ((pid = pdfork(&pr_pd, PD_CLOEXEC))) {
+	if (sigpipe[0] < 0) {
+		if (pipe(sigpipe) == -1)
+			err(2, "pipe");
+		if (fcntl(sigpipe[0], F_SETFD, FD_CLOEXEC) == -1)
+			err(2, "fcntl");
+		if (fcntl(sigpipe[1], F_SETFD, FD_CLOEXEC) == -1)
+			err(2, "fcntl");
+		if (signal(SIGCHLD, handle_sig) == SIG_ERR)
+			err(2, "signal");
+		poll_fd.fd = sigpipe[0];
+		poll_fd.events = POLLIN;
+	}
+	poll_fd.revents = 0;
+	switch ((pid = fork())) {
 	case -1:
 		status |= 2;
 		free(header);
@@ -83,14 +106,7 @@
 		close(pfd[0]);
 		rewind(stdout);
 		free(header);
-		pr->kq = kqueue();
-		if (pr->kq == -1)
-			err(2, "kqueue");
-		pr->e = xmalloc(sizeof(struct kevent));
-		EV_SET(pr->e, pr_pd, EVFILT_PROCDESC, EV_ADD, NOTE_EXIT, 0,
-		    NULL);
-		if (kevent(pr->kq, pr->e, 1, NULL, 0, NULL) == -1)
-			err(2, "kevent");
+		pr->cpid = pid;
 	}
 	return (pr);
 }
@@ -100,6 +116,7 @@
 stop_pr(struct pr *pr)
 {
 	int wstatus;
+	int done = 0;
 
 	if (pr == NULL)
 		return;
@@ -110,14 +127,27 @@
 		dup2(pr->ostdout, STDOUT_FILENO);
 		close(pr->ostdout);
 	}
-	if (kevent(pr->kq, NULL, 0, pr->e, 1, NULL) == -1)
-		err(2, "kevent");
-	wstatus = pr->e[0].data;
-	close(pr->kq);
+	while (!done) {
+		pid_t wpid;
+		int npe = poll(&poll_fd, 1, -1);
+		if (npe == -1) {
+			if (errno == EINTR) continue;
+			err(2, "poll");
+		}
+		if (poll_fd.revents != POLLIN)
+			continue;
+		if (read(poll_fd.fd, &npe, sizeof(npe)) < 0)
+			err(2, "read");
+		while ((wpid = waitpid(-1, &wstatus, WNOHANG)) > 0) {
+			if (wpid != pr->cpid) continue;
+			if (WIFEXITED(wstatus) && WEXITSTATUS(wstatus) != 0)
+				errx(2, "pr exited abnormally");
+			else if (WIFSIGNALED(wstatus))
+				errx(2, "pr killed by signal %d",
+				    WTERMSIG(wstatus));
+			done = 1;
+			break;
+		}
+	}
 	free(pr);
-	if (WIFEXITED(wstatus) && WEXITSTATUS(wstatus) != 0)
-		errx(2, "pr exited abnormally");
-	else if (WIFSIGNALED(wstatus))
-		errx(2, "pr killed by signal %d",
-		    WTERMSIG(wstatus));
 }
--- src.orig/diffutils/diff/pr.h
+++ src.freebsd/diffutils/diff/pr.h
@@ -24,12 +24,9 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include <sys/event.h>
-
 struct pr {
 	int ostdout;
-	int kq;
-	struct kevent *e;
+	pid_t cpid;
 };
 
 struct pr *start_pr(char *file1, char *file2);
--- src.orig/diffutils/diff3/diff3.c
+++ src.freebsd/diffutils/diff3/diff3.c
@@ -71,9 +71,7 @@
 #endif /* not lint */
 #include <sys/cdefs.h>
 #include <sys/capsicum.h>
-#include <sys/procdesc.h>
 #include <sys/types.h>
-#include <sys/event.h>
 #include <sys/wait.h>
 
 #include <capsicum_helpers.h>
@@ -82,10 +80,13 @@
 #include <getopt.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <stdbool.h>
 #include <limits.h>
 #include <inttypes.h>
 #include <string.h>
 #include <unistd.h>
+#include <errno.h>
+#include <poll.h>
 
 
 /*
@@ -130,6 +131,7 @@
 static int  overlapcnt;
 static FILE *fp[3];
 static int cline[3];		/* # of the last-read line in each file (0-2) */
+static int sigpipe[2];
 /*
  * The latest known correspondence between line numbers of the 3 files
  * is stored in last[1-3];
@@ -245,12 +247,10 @@
 	return (i);
 }
 
-static int
+static void
 diffexec(const char *diffprog, char **diffargv, int fd[])
 {
-	int pd;
-
-	switch (pdfork(&pd, PD_CLOEXEC)) {
+	switch (fork()) {
 	case 0:
 		close(fd[0]);
 		if (dup2(fd[1], STDOUT_FILENO) == -1)
@@ -264,7 +264,6 @@
 		break;
 	}
 	close(fd[1]);
-	return (pd);
 }
 
 static char *
@@ -827,20 +826,25 @@
 	szchanges = newsz;
 }
 
+static void
+handle_sig(int signo)
+{
+    write(sigpipe[1], &signo, sizeof(signo));
+}
 
 int
 main(int argc, char **argv)
 {
-	int ch, nblabels, status, m, n, kq, nke, nleft, i;
+	int ch, nblabels, status, m, n, npe, nleft;
 	char *labels[] = { NULL, NULL, NULL };
 	const char *diffprog = DIFF_PATH;
 	char *file1, *file2, *file3;
 	char *diffargv[7];
 	int diffargc = 0;
-	int fd13[2], fd23[2];
-	int pd13, pd23;
+	int fd13[2], fd23[2], signo;
+	pid_t wpid;
+	struct pollfd pfd;
 	cap_rights_t rights_ro;
-	struct kevent *e;
 
 	nblabels = 0;
 	eflag = EFLAG_NONE;
@@ -921,14 +925,6 @@
 
 	cap_rights_init(&rights_ro, CAP_READ, CAP_FSTAT, CAP_SEEK);
 
-	kq = kqueue();
-	if (kq == -1)
-		err(2, "kqueue");
-
-	e = malloc(2 * sizeof(struct kevent));
-	if (e == NULL)
-		err(2, "malloc");
-
 	/* TODO stdio */
 	file1 = argv[0];
 	file2 = argv[1];
@@ -970,23 +966,30 @@
 		err(2, "pipe");
 	if (pipe(fd23))
 		err(2, "pipe");
+	if (pipe(sigpipe))
+		err(2, "pipe");
+	if (fcntl(sigpipe[0], F_SETFD, FD_CLOEXEC))
+		err(2, "fcntl");
+	if (fcntl(sigpipe[1], F_SETFD, FD_CLOEXEC))
+		err(2, "fcntl");
 
+	pfd.fd = sigpipe[0];
+	pfd.events = POLLIN;
+	pfd.revents = 0;
+
+	if (signal(SIGCHLD, handle_sig) == SIG_ERR)
+		err(2, "signal");
+
 	diffargv[diffargc] = file1;
 	diffargv[diffargc + 1] = file3;
 	diffargv[diffargc + 2] = NULL;
 
 	nleft = 0;
-	pd13 = diffexec(diffprog, diffargv, fd13);
-	EV_SET(e + nleft , pd13, EVFILT_PROCDESC, EV_ADD, NOTE_EXIT, 0, NULL);
-	if (kevent(kq, e + nleft, 1, NULL, 0, NULL) == -1)
-		err(2, "kevent1");
+	diffexec(diffprog, diffargv, fd13);
 	nleft++;
 
 	diffargv[diffargc] = file2;
-	pd23 = diffexec(diffprog, diffargv, fd23);
-	EV_SET(e + nleft , pd23, EVFILT_PROCDESC, EV_ADD, NOTE_EXIT, 0, NULL);
-	if (kevent(kq, e + nleft, 1, NULL, 0, NULL) == -1)
-		err(2, "kevent2");
+	diffexec(diffprog, diffargv, fd23);
 	nleft++;
 
 	caph_cache_catpages();
@@ -998,20 +1001,25 @@
 	m = readin(fd13[0], &d13);
 	n = readin(fd23[0], &d23);
 
-	/* waitpid cooked over pdforks */
+	/* waitpid */
 	while (nleft > 0) {
-		nke = kevent(kq, NULL, 0, e, nleft, NULL);
-		if (nke == -1)
-			err(2, "kevent");
-		for (i = 0; i < nke; i++) {
-			status = e[i].data;
+		npe = poll(&pfd, 1, -1);
+		if (npe == -1) {
+			if (errno == EINTR) continue;
+			err(2, "poll");
+		}
+		if (pfd.revents != POLLIN)
+			continue;
+		if (read(pfd.fd, &signo, sizeof(signo)) < 0)
+			err(2, "read");
+		while ((wpid = waitpid(-1, &status, WNOHANG)) > 0) {
 			if (WIFEXITED(status) && WEXITSTATUS(status) >= 2)
 				errx(2, "diff exited abnormally");
 			else if (WIFSIGNALED(status))
 				errx(2, "diff killed by signal %d",
 				    WTERMSIG(status));
+			--nleft;
 		}
-		nleft -= nke;
 	}
 	merge(m, n);
 
--- src.orig/diffutils/sdiff/edit.c
+++ src.freebsd/diffutils/sdiff/edit.c
@@ -141,7 +141,7 @@
 	/* Create temp file. */
 	if (asprintf(&filename, "%s/sdiff.XXXXXXXXXX", tmpdir) == -1)
 		err(2, "asprintf");
-	if ((fd = mkstemp(filename)) == -1)
+	if ((fd = compat_mkstemp(filename)) == -1)
 		err(2, "mkstemp");
 	if (text != NULL) {
 		size_t len;
--- src.orig/diffutils/sdiff/sdiff.c
+++ src.freebsd/diffutils/sdiff/sdiff.c
@@ -176,7 +176,7 @@
 	/* Not a regular file, so copy input into temporary file. */
 	if (asprintf(&target_file, "%s/sdiff.XXXXXXXXXX", tmpdir) == -1)
 		err(2, "asprintf");
-	if ((ofd = mkstemp(target_file)) == -1) {
+	if ((ofd = compat_mkstemp(target_file)) == -1) {
 		warn("error opening %s", target_file);
 		goto FAIL;
 	}
--- src.orig/ed/main.c
+++ src.freebsd/ed/main.c
@@ -210,6 +210,7 @@
 		switch (status) {
 		case EOF:
 			quit(0);
+			break; /* unreachable */
 		case EMOD:
 			modified = 0;
 			fputs("?\n", stderr);		/* give warning */
@@ -229,6 +230,7 @@
 			} else if (garrulous)
 				fprintf(stderr, "%s\n", errmsg);
 			quit(3);
+			break; /* unreachable */
 		default:
 			fputs("?\n", stderr);
 			if (!isatty(0)) {
--- src.orig/ee/ee.c
+++ src.freebsd/ee/ee.c
@@ -929,7 +929,7 @@
 {
 	int i1, i2;
 	char *string;
-	char string2[8];
+	char string2[16];
 
 	if (character == TAB)
 	{
@@ -2461,6 +2461,7 @@
 void 
 edit_abort(int arg)
 {
+	(void)arg;
 	wrefresh(com_win);
 	resetty();
 	endwin();
@@ -3365,8 +3366,8 @@
 			max_width = length;
 	}
 	max_width += 3;
-	max_width = max(max_width, strlen(menu_cancel_msg));
-	max_width = max(max_width, max(strlen(more_above_str), strlen(more_below_str)));
+	max_width = max(max_width, (int)strlen(menu_cancel_msg));
+	max_width = max(max_width, max((int)strlen(more_above_str), (int)strlen(more_below_str)));
 	max_width += 6;
 
 	/*
--- src.orig/fetch/fetch.c
+++ src.freebsd/fetch/fetch.c
@@ -32,6 +32,7 @@
 #include <sys/cdefs.h>
 #include <sys/param.h>
 #include <sys/socket.h>
+#include <sys/ioctl.h>
 #include <sys/stat.h>
 #include <sys/time.h>
 
@@ -52,6 +53,12 @@
 #define MINBUFSIZE	16384
 #define TIMEOUT		120
 
+#ifndef TCSASOFT
+#define TCSASOFT 0
+#endif
+
+#define setproctitle(...)
+
 /* Option flags */
 static int	 A_flag;	/*    -A: do not follow 302 redirects */
 static int	 a_flag;	/*    -a: auto retry */
@@ -281,7 +288,7 @@
 static void
 stat_display(struct xferstat *xs, int force)
 {
-	char bytes[16], bps[16], eta[16];
+	char bytes[16], bps[32], eta[32];
 	struct timeval now;
 	int ctty_pgrp;
 
@@ -431,11 +438,11 @@
 	struct xferstat xs;
 	FILE *f, *of;
 	size_t size, readcnt, wr;
-	off_t count, size_prev;
+	off_t count, size_prev = 0;
 	char flags[8];
 	const char *slash;
 	char *tmppath;
-	int r, tries;
+	int r, tries = 0;
 	unsigned timeout;
 	char *ptr;
 
@@ -638,6 +645,7 @@
 		if (!F_flag && us.mtime && sb.st_mtime != us.mtime && tries == 1) {
 			/* no match! have to refetch */
 			fclose(f);
+			f = NULL;
 			/* if precious, warn the user and give up */
 			if (R_flag) {
 				warnx("%s: local modification time "
--- src.orig/findutils/find/extern.h
+++ src.freebsd/findutils/find/extern.h
@@ -32,6 +32,8 @@
  */
 
 #include <sys/cdefs.h>
+#include <sys/types.h>
+#include <signal.h>
 
 void	 brace_subst(char *, char **, char *, size_t);
 PLAN	*find_create(char ***);
@@ -46,6 +48,7 @@
 int	 queryuser(char **);
 OPTION	*lookup_option(const char *);
 void	 finish_execplus(void);
+const char *f_fstypename(dev_t);
 
 creat_f	c_Xmin;
 creat_f	c_Xtime;
--- src.orig/findutils/find/find.1
+++ src.freebsd/findutils/find/find.1
@@ -201,35 +201,6 @@
 and neither means
 .Dq exactly n .
 .Bl -tag -width indent
-.It Ic -Bmin Ar n
-True if the difference between the time of a file's inode creation
-and the time
-.Nm
-was started, rounded up to the next full minute, is
-.Ar n
-minutes.
-.It Ic -Bnewer Ar file
-Same as
-.Ic -newerBm .
-.It Ic -Btime Ar n Ns Op Cm smhdw
-If no units are specified, this primary evaluates to
-true if the difference between the time of a file's inode creation
-and the time
-.Nm
-was started, rounded up to the next full 24-hour period, is
-.Ar n
-24-hour periods.
-.Pp
-If units are specified, this primary evaluates to
-true if the difference between the time of a file's inode creation
-and the time
-.Nm
-was started is exactly
-.Ar n
-units.
-Please refer to the
-.Ic -atime
-primary description for information on supported time units.
 .It Ic -acl
 May be used in conjunction with other primaries to locate
 files with extended ACLs.
@@ -473,50 +444,6 @@
 .Xr access 2
 system call, and so can be fooled by NFS servers which do UID mapping (or root-squashing).
 This is a GNU find extension.
-.It Ic -flags Oo Cm - Ns | Ns Cm + Oc Ns Ar flags , Ns Ar notflags
-The flags are specified using symbolic names (see
-.Xr chflags 1 ) .
-Those with the
-.Qq Li no
-prefix (except
-.Qq Li nodump )
-are said to be
-.Ar notflags .
-Flags in
-.Ar flags
-are checked to be set, and flags in
-.Ar notflags
-are checked to be not set.
-Note that this is different from
-.Ic -perm ,
-which only allows the user to specify mode bits that are set.
-.Pp
-If flags are preceded by a dash
-.Pq Dq Li - ,
-this primary evaluates to true
-if at least all of the bits in
-.Ar flags
-and none of the bits in
-.Ar notflags
-are set in the file's flags bits.
-If flags are preceded by a plus
-.Pq Dq Li + ,
-this primary evaluates to true
-if any of the bits in
-.Ar flags
-is set in the file's flags bits,
-or any of the bits in
-.Ar notflags
-is not set in the file's flags bits.
-Otherwise,
-this primary evaluates to true
-if the bits in
-.Ar flags
-exactly match the file's flags bits,
-and none of the
-.Ar flags
-bits match those of
-.Ar notflags .
 .It Ic -fstype Ar type
 True if the file is contained in a file system of type
 .Ar type .
@@ -524,15 +451,9 @@
 .Xr lsvfs 1
 command can be used to find out the types of file systems
 that are available on the system.
-In addition, there are two pseudo-types,
-.Dq Li local
-and
-.Dq Li rdonly .
-The former matches any file system physically mounted on the system where
-the
-.Nm
-is being executed and the latter matches any file system which is
-mounted read-only.
+In addition, there is a pseudotype
+.Dq Li rdonly
+that matches any file system which is mounted read-only.
 .It Ic -gid Ar gname
 The same thing as
 .Ic -group Ar gname
@@ -1055,7 +976,6 @@
 .Sx STANDARDS
 section below for details.
 .Sh SEE ALSO
-.Xr chflags 1 ,
 .Xr chmod 1 ,
 .Xr locate 1 ,
 .Xr lsvfs 1 ,
@@ -1086,9 +1006,7 @@
 .Ic -amin , -anewer , -cmin , -cnewer , -delete , -empty , -fstype ,
 .Ic -iname , -inum , -iregex , -ls , -maxdepth , -mindepth , -mmin ,
 .Ic -not , -path , -print0 , -regex , -sparse
-and all of the
-.Fl B*
-birthtime related primaries are extensions to
+are extensions to
 .St -p1003.1-2001 .
 .Pp
 Historically, the
--- src.orig/findutils/find/find.c
+++ src.freebsd/findutils/find/find.c
@@ -50,7 +50,7 @@
 
 #include "find.h"
 
-static int find_compare(const FTSENT * const *s1, const FTSENT * const *s2);
+static int find_compare(const FTSENT **s1, const FTSENT **s2);
 
 /*
  * find_compare --
@@ -59,7 +59,7 @@
  *	order within each directory.
  */
 static int
-find_compare(const FTSENT * const *s1, const FTSENT * const *s2)
+find_compare(const FTSENT **s1, const FTSENT **s2)
 {
 
 	return (strcoll((*s1)->fts_name, (*s2)->fts_name));
@@ -244,5 +244,6 @@
 	finish_execplus();
 	if (e && (!ignore_readdir_race || e != ENOENT))
 		errc(1, e, "fts_read");
+	f_fstypename(0); /* free allocated filesystem type resources */
 	return (exitstatus);
 }
--- src.orig/findutils/find/find.h
+++ src.freebsd/findutils/find/find.h
@@ -55,11 +55,7 @@
 #else
 #define HAVE_STRUCT_STAT_ST_BIRTHTIME 0
 #endif
-#if defined(MFSNAMELEN) || defined(MFSTYPENAMELEN)
 #define HAVE_STRUCT_STATFS_F_FSTYPENAME 1
-#else
-#define HAVE_STRUCT_STATFS_F_FSTYPENAME 0
-#endif
 
 /* forward declarations */
 struct _plandata;
--- src.orig/findutils/find/function.c
+++ src.freebsd/findutils/find/function.c
@@ -38,12 +38,14 @@
 
 #include <sys/cdefs.h>
 #include <sys/param.h>
-#include <sys/ucred.h>
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <sys/acl.h>
 #include <sys/wait.h>
 #include <sys/mount.h>
+#include <sys/sysmacros.h>
+#include <sys/statvfs.h>
+#include <acl/libacl.h>
 
 #include <dirent.h>
 #include <err.h>
@@ -62,6 +64,10 @@
 
 #include "find.h"
 
+#ifndef REG_STARTEND
+#define REG_STARTEND 0
+#endif
+
 static PLAN *palloc(OPTION *);
 static long long find_parsenum(PLAN *, const char *, char *, char *);
 static long long find_parsetime(PLAN *, const char *, char *);
@@ -371,12 +377,11 @@
 int
 f_acl(PLAN *plan __unused, FTSENT *entry)
 {
-	acl_t facl;
-	acl_type_t acl_type;
-	int acl_supported = 0, ret, trivial;
+	int acl_supported = 0, ret;
 
 	if (S_ISLNK(entry->fts_statp->st_mode))
 		return 0;
+#if 0
 	ret = pathconf(entry->fts_accpath, _PC_ACL_NFS4);
 	if (ret > 0) {
 		acl_supported = 1;
@@ -385,16 +390,17 @@
 		warn("%s", entry->fts_accpath);
 		return (0);
 	}
+#endif
 	if (acl_supported == 0) {
-		ret = pathconf(entry->fts_accpath, _PC_ACL_EXTENDED);
+		ret = acl_extended_file(entry->fts_accpath);
 		if (ret > 0) {
 			acl_supported = 1;
-			acl_type = ACL_TYPE_ACCESS;
-		} else if (ret < 0 && errno != EINVAL) {
+		} else if (ret < 0 && errno != ENOTSUP) {
 			warn("%s", entry->fts_accpath);
 			return (0);
 		}
 	}
+#if 0
 	if (acl_supported == 0)
 		return (0);
 
@@ -412,6 +418,8 @@
 	if (trivial)
 		return (0);
 	return (1);
+#endif
+	return acl_supported;
 }
 #endif
 
@@ -872,6 +880,65 @@
 }
 
 #if HAVE_STRUCT_STATFS_F_FSTYPENAME
+struct mntinfo {
+    dev_t devn;
+    char fstype[64];
+};
+
+const char *
+f_fstypename(dev_t curdev)
+{
+	static struct mntinfo *minfo = NULL;
+	static size_t ninfos = 0;
+	char curfstype[64];
+	/* to be freed */
+	if (!curdev) {
+		free(minfo);
+		minfo = NULL;
+		ninfos = 0;
+		return NULL;
+	}
+	if (!minfo) {
+		FILE *f = fopen("/proc/self/mountinfo", "rb");
+		if (!f)
+			return NULL;
+		char *lbuf = NULL;
+		size_t lsize = 0, ncap = 64;
+		minfo = malloc(ncap * sizeof(struct mntinfo));
+		if (!minfo)
+			err(1, "malloc");
+		const char *rfs = NULL;
+		while (getline(&lbuf, &lsize, f) > 0) {
+			unsigned int maj, min;
+			memset(curfstype, 0, sizeof(curfstype));
+			if (sscanf(
+			    lbuf, "%*d %*d %u:%u %*s %*s %*[^-]- %63s %*s %*s",
+			    &maj, &min, curfstype
+			) <= 0)
+				continue;
+			if (ninfos == ncap) {
+				ncap *= 2;
+				minfo = realloc(minfo, ncap * sizeof(struct mntinfo));
+				if (!minfo)
+					err(1, "realloc");
+			}
+			minfo[ninfos].devn = makedev(maj, min);
+			memcpy(minfo[ninfos].fstype, curfstype, sizeof(curfstype));
+			if (minfo[ninfos].devn == curdev)
+				rfs = minfo[ninfos].fstype;
+			++ninfos;
+		}
+		free(lbuf);
+		fclose(f);
+		return rfs;
+	}
+	for (size_t i = 0; i < ninfos; ++i) {
+		if (minfo[i].devn == curdev)
+			return minfo[i].fstype;
+	}
+	return NULL;
+}
+
 /*
  * -fstype functions --
  *
@@ -882,9 +949,9 @@
 {
 	static dev_t curdev;	/* need a guaranteed illegal dev value */
 	static int first = 1;
-	struct statfs sb;
-	static int val_flags;
-	static char fstype[sizeof(sb.f_fstypename)];
+	struct statvfs sb;
+	static unsigned long val_flags;
+	static const char *fstype;
 	char *p, save[2] = {0,0};
 
 	if ((plan->flags & F_MTMASK) == F_MTUNKNOWN)
@@ -895,7 +962,7 @@
 		curdev = entry->fts_statp->st_dev;
 
 		/*
-		 * Statfs follows symlinks; find wants the link's filesystem,
+		 * Statvfs follows symlinks; find wants the link's filesystem,
 		 * not where it points.
 		 */
 		if (entry->fts_info == FTS_SL ||
@@ -911,7 +978,7 @@
 		} else
 			p = NULL;
 
-		if (statfs(entry->fts_accpath, &sb)) {
+		if (statvfs(entry->fts_accpath, &sb)) {
 			if (!ignore_readdir_race || errno != ENOENT) {
 				warn("statfs: %s", entry->fts_accpath);
 				exitstatus = 1;
@@ -930,14 +997,14 @@
 		 * Further tests may need both of these values, so
 		 * always copy both of them.
 		 */
-		val_flags = sb.f_flags;
-		strlcpy(fstype, sb.f_fstypename, sizeof(fstype));
+		val_flags = sb.f_flag;
+		fstype = f_fstypename(curdev);
 	}
 	switch (plan->flags & F_MTMASK) {
 	case F_MTFLAG:
 		return val_flags & plan->mt_data;
 	case F_MTTYPE:
-		return (strncmp(fstype, plan->c_data, sizeof(fstype)) == 0);
+		return fstype && (strcmp(fstype, plan->c_data) == 0);
 	default:
 		abort();
 	}
@@ -954,17 +1021,10 @@
 
 	new = palloc(option);
 	switch (*fsname) {
-	case 'l':
-		if (!strcmp(fsname, "local")) {
-			new->flags |= F_MTFLAG;
-			new->mt_data = MNT_LOCAL;
-			return new;
-		}
-		break;
 	case 'r':
 		if (!strcmp(fsname, "rdonly")) {
 			new->flags |= F_MTFLAG;
-			new->mt_data = MNT_RDONLY;
+			new->mt_data = ST_RDONLY;
 			return new;
 		}
 		break;
@@ -1259,7 +1319,9 @@
 int
 f_nogroup(PLAN *plan __unused, FTSENT *entry)
 {
-	return group_from_gid(entry->fts_statp->st_gid, 1) == NULL;
+	struct group *gr;
+	gr = getgrgid(entry->fts_statp->st_gid);
+	return gr == NULL;
 }
 
 PLAN *
@@ -1279,7 +1341,9 @@
 int
 f_nouser(PLAN *plan __unused, FTSENT *entry)
 {
-	return user_from_uid(entry->fts_statp->st_uid, 1) == NULL;
+	struct passwd *pw;
+	pw = getpwuid(entry->fts_statp->st_uid);
+	return pw == NULL;
 }
 
 PLAN *
--- src.orig/findutils/find/ls.c
+++ src.freebsd/findutils/find/ls.c
@@ -36,6 +36,7 @@
 #include <sys/cdefs.h>
 #include <sys/param.h>
 #include <sys/stat.h>
+#include <sys/types.h>
 
 #include <err.h>
 #include <errno.h>
@@ -46,7 +47,7 @@
 #include <pwd.h>
 #include <stdio.h>
 #include <string.h>
-#include <time.h>
+#include <time_bsd.h>
 #include <unistd.h>
 
 #include "find.h"
@@ -60,13 +61,29 @@
 printlong(char *name, char *accpath, struct stat *sb)
 {
 	char modep[15];
+	struct passwd *pw = NULL;
+	struct group *gr = NULL;
+	char *uname = NULL;
+	char *gname = NULL;
 
+	pw = getpwuid(sb->st_uid);
+	if (pw == NULL)
+		uname = "root";
+	else
+		uname = pw->pw_name;
+
+	gr = getgrgid(sb->st_gid);
+	if (gr == NULL)
+		gname = "root";
+	else
+		gname = gr->gr_name;
+
 	(void)printf("%6ju %8"PRId64" ", (uintmax_t)sb->st_ino, sb->st_blocks);
 	(void)strmode(sb->st_mode, modep);
 	(void)printf("%s %3ju %-*s %-*s ", modep, (uintmax_t)sb->st_nlink,
 	    MAXLOGNAME - 1,
-	    user_from_uid(sb->st_uid, 0), MAXLOGNAME - 1,
-	    group_from_gid(sb->st_gid, 0));
+	    uname, MAXLOGNAME - 1,
+	    gname);
 
 	if (S_ISCHR(sb->st_mode) || S_ISBLK(sb->st_mode))
 		(void)printf("%#8jx ", (uintmax_t)sb->st_rdev);
@@ -103,7 +120,7 @@
 		/* mmm dd  yyyy || dd mmm  yyyy */
 		format = d_first ? "%e %b  %Y " : "%b %e  %Y ";
 	if ((tm = localtime(&ftime)) != NULL)
-		strftime(longstring, sizeof(longstring), format, tm);
+		strftime_bsd(longstring, sizeof(longstring), format, tm);
 	else
 		strlcpy(longstring, "bad date val ", sizeof(longstring));
 	fputs(longstring, stdout);
--- src.orig/findutils/find/main.c
+++ src.freebsd/findutils/find/main.c
@@ -32,9 +32,11 @@
  * SUCH DAMAGE.
  */
 
+#if 0
 static const char copyright[] =
 "@(#) Copyright (c) 1990, 1993, 1994\n\
 	The Regents of the University of California.  All rights reserved.\n";
+#endif
 
 #if 0
 static char sccsid[] = "@(#)main.c	8.4 (Berkeley) 5/4/95";
@@ -88,7 +90,7 @@
 	p = start = argv;
 	Hflag = Lflag = 0;
 	ftsoptions = FTS_NOSTAT | FTS_PHYSICAL;
-	while ((ch = getopt(argc, argv, "EHLPXdf:sx")) != -1)
+	while ((ch = getopt(argc, argv, "+EHLPXdf:sx")) != -1)
 		switch (ch) {
 		case 'E':
 			regexp_flags |= REG_EXTENDED;
--- src.orig/findutils/find/misc.c
+++ src.freebsd/findutils/find/misc.c
@@ -49,6 +49,10 @@
 
 #include "find.h"
 
+#if defined(__linux__) && !defined(__GLIBC__)
+#include <rpmatch.h>
+#endif
+
 /*
  * brace_subst --
  *	Replace occurrences of {} in s1 with s2 and return the result string.
--- src.orig/findutils/locate/bigram/locate.bigram.c
+++ src.freebsd/findutils/locate/bigram/locate.bigram.c
@@ -47,11 +47,12 @@
 #endif /* not lint */
 #endif
 
-
+#include <sys/types.h>
 #include <capsicum_helpers.h>
 #include <err.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <limits.h>
 #include "locate.h"
 
 u_char buf1[LOCATE_PATH_MAX] = " ";
@@ -68,7 +69,7 @@
 	if (caph_limit_stdio() < 0 || caph_enter() < 0)
 		err(1, "capsicum");
 
-     	while (fgets(path, sizeof(buf2), stdin) != NULL) {
+     	while (fgets((char *)path, sizeof(buf2), stdin) != NULL) {
 
 		/* 
 		 * We don't need remove newline character '\n'.
--- src.orig/findutils/locate/code/locate.code.c
+++ src.freebsd/findutils/locate/code/locate.code.c
@@ -90,6 +90,7 @@
  */
 
 #include <sys/param.h>
+#include <sys/types.h>
 #include <err.h>
 #include <errno.h>
 #include <stdlib.h>
@@ -133,7 +134,7 @@
 		err(1, "%s", argv[0]);
 
 	/* First copy bigram array to stdout. */
-	if (fgets(bigrams, BGBUFSIZE + 1, fp) == NULL) {
+	if (fgets((char *)bigrams, BGBUFSIZE + 1, fp) == NULL) {
 		if (!feof(fp) || ferror(fp))
 			err(1, "get bigram array");
 	}
@@ -154,7 +155,7 @@
 	path = buf2;
 	oldcount = 0;
 
-	while (fgets(path, sizeof(buf2), stdin) != NULL) {
+	while (fgets((char *)path, sizeof(buf2), stdin) != NULL) {
 
 		/* skip empty lines */
 		if (*path == '\n')
--- src.orig/findutils/locate/locate/concatdb.sh.in
+++ src.freebsd/findutils/locate/locate/concatdb.sh.in
@@ -38,7 +38,7 @@
 set -o pipefail
 
 # The directory containing locate subprograms
-: ${LIBEXECDIR:=/usr/libexec}; export LIBEXECDIR
+: ${LIBEXECDIR:=@LIBEXECDIR@}; export LIBEXECDIR
 
 PATH=$LIBEXECDIR:/bin:/usr/bin:$PATH; export PATH
 : ${TMPDIR:=/var/tmp}; export TMPDIR;
--- src.orig/findutils/locate/locate/fastfind.c
+++ src.freebsd/findutils/locate/locate/fastfind.c
@@ -152,7 +152,7 @@
 	/* use a lookup table for case insensitive search */
 	u_char table[UCHAR_MAX + 1];
 
-	tolower_word(pathpart);
+	tolower_word((u_char *)pathpart);
 #endif /* FF_ICASE*/
 
 	/* init bigram table */
@@ -169,8 +169,8 @@
 #endif /* FF_MMAP */
 
 	/* find optimal (last) char for searching */
-	for (p = pathpart; *p != '\0'; p++)
-		if (strchr(LOCATE_REG, *p) != NULL)
+	for (p = (u_char *)pathpart; *p != '\0'; p++)
+		if (strchr(LOCATE_REG, *(char *)p) != NULL)
 			break;
 
 	if (*p == '\0')
@@ -178,8 +178,8 @@
 	else
 		globflag = 1;
 
-	p = pathpart;
-	patend = patprep(p);
+	p = (u_char *)pathpart;
+	patend = (u_char *)patprep(pathpart);
 	cc = *patend;
 
 #ifdef FF_ICASE
@@ -209,7 +209,7 @@
 		/* go forward or backward */
 		if (c == SWITCH) { /* big step, an integer */
 #ifdef FF_MMAP
-			if (len < sizeof(int))
+			if (len < (off_t)sizeof(int))
 				errx(1, "corrupted database: %s", database);
 
 			count += getwm(paddr) - OFFSET;
@@ -318,9 +318,9 @@
 					found = 1;
 					if (!globflag || 
 #ifndef FF_ICASE
-					    !fnmatch(pathpart, path, 0)) 
+					    !fnmatch(pathpart, (char *)path, 0)) 
 #else 
-					    !fnmatch(pathpart, path, 
+					    !fnmatch(pathpart, (char *)path, 
 						     FNM_CASEFOLD))
 #endif /* !FF_ICASE */						
 					{
@@ -328,7 +328,7 @@
 							counter++;
 						else if (f_limit) {
 							counter++;
-							if (f_limit >= counter)
+							if (f_limit >= (int)counter)
 								(void)printf("%s%c",path,separator);
 							else 
 								errx(0, "[show only %ld lines]", counter - 1);
--- src.orig/findutils/locate/locate/locate.1
+++ src.freebsd/findutils/locate/locate/locate.1
@@ -45,7 +45,7 @@
 .Nm
 program searches a database for all pathnames which match the specified
 .Ar pattern .
-The database is recomputed periodically (usually weekly or daily),
+The database is recomputed as the user requires,
 and contains the pathnames
 of all files which are publicly accessible.
 .Pp
@@ -187,13 +187,11 @@
 option was specified.
 .El
 .Sh FILES
-.Bl -tag -width /etc/periodic/weekly/310.locate -compact
+.Bl -tag -width /var/db/locate.database -compact
 .It Pa /var/db/locate.database
 locate database
-.It Pa /usr/libexec/locate.updatedb
+.It Pa locate-updatedb
 Script to update the locate database
-.It Pa /etc/periodic/weekly/310.locate
-Script that starts the database rebuild
 .El
 .Sh SEE ALSO
 .Xr find 1 ,
@@ -224,9 +222,9 @@
 list files that have been removed from the system.
 This is because
 locate only reports files that are present in the database, which is
-typically only regenerated once a week by the
-.Pa /etc/periodic/weekly/310.locate
-script.
+typically only regenerated upon user request by the
+.Pa locate-updatedb
+command.
 Use
 .Xr find 1
 to locate files that are of a more transitory nature.
--- src.orig/findutils/locate/locate/locate.c
+++ src.freebsd/findutils/locate/locate/locate.c
@@ -75,6 +75,7 @@
  */
 
 #include <sys/param.h>
+#include <sys/types.h>
 #include <ctype.h>
 #include <err.h>
 #include <fnmatch.h>
--- src.orig/findutils/locate/locate/locate.rc
+++ src.freebsd/findutils/locate/locate/locate.rc
@@ -15,7 +15,7 @@
 #SEARCHPATHS="/"
 
 # paths unwanted in output
-#PRUNEPATHS="/tmp /usr/tmp /var/tmp /var/db/freebsd-update"
+#PRUNEPATHS="/tmp /var/tmp"
 
 # directories unwanted in output
 #PRUNEDIRS=".zfs"
@@ -24,9 +24,10 @@
 # and if the SEARCHPATHS starts in such a filesystem locate will build
 # an empty database.
 #
-# the default list contains all local file systems that are not synthetic,
-# loopback mounts, or read-only, according to lsvfs.
+# the default list contains filesystems known to be read-write,
+# non-virtual on-disk file systems; it is not possible to compute
+# this list reliably, so change it to your liking
 #
-# be careful if you add 'nfs' or other network file system types or file
-# systems that generally reside on slow or removable devices like cd9660
-#FILESYSTEMS="ufs ext2fs zfs xfs"
+# be careful if you add NFS or other network file system types or file
+# systems that generally reside on slow or removable devices (e.g. iso9660)
+#FILESYSTEMS="ext2 ext3 ext4 xfs vfat exfat ntfs ntfs3 f2fs zfs btrfs reiserfs reiser4 jfs"
--- src.orig/findutils/locate/locate/locate.updatedb.8
+++ src.freebsd/findutils/locate/locate/locate.updatedb.8
@@ -34,16 +34,11 @@
 .Sh NAME
 .Nm locate.updatedb
 .Nd update locate database
-.Sh SYNOPSIS
-.Nm /usr/libexec/locate.updatedb
 .Sh DESCRIPTION
 The
 .Nm
-utility updates the database used by
+utility, located in the configured libexec directory, updates the database used by
 .Xr locate 1 .
-It is typically run once a week by the
-.Pa /etc/periodic/weekly/310.locate
-script.
 .Pp
 The contents of the newly built database can be controlled by the
 .Pa /etc/locate.rc
@@ -61,8 +56,7 @@
 the configuration file
 .El
 .Sh SEE ALSO
-.Xr locate 1 ,
-.Xr periodic 8
+.Xr locate 1
 .Rs
 .%A Woods, James A.
 .%D 1983
--- src.orig/findutils/locate/locate/mklocatedb.sh.in
+++ src.freebsd/findutils/locate/locate/mklocatedb.sh.in
@@ -36,7 +36,7 @@
 set -o pipefail
 
 # The directory containing locate subprograms
-: ${LIBEXECDIR:=/usr/libexec}; export LIBEXECDIR
+: ${LIBEXECDIR:=@LIBEXECDIR@}; export LIBEXECDIR
 : ${TMPDIR:=/var/tmp}; export TMPDIR
 
 PATH=$LIBEXECDIR:/bin:/usr/bin:$PATH; export PATH
--- src.orig/findutils/locate/locate/updatedb.sh.in
+++ src.freebsd/findutils/locate/locate/updatedb.sh.in
@@ -40,7 +40,7 @@
 fi
 
 # The directory containing locate subprograms
-: ${LIBEXECDIR:=/usr/libexec}; export LIBEXECDIR
+: ${LIBEXECDIR:=@LIBEXECDIR@}; export LIBEXECDIR
 : ${TMPDIR:=/tmp}; export TMPDIR
 if ! TMPDIR=$(mktemp -d $TMPDIR/locateXXXXXXXXXX); then
 	exit 1
@@ -53,11 +53,10 @@
 : ${mklocatedb:=locate.mklocatedb}	 # make locate database program
 : ${FCODES:=/var/db/locate.database}	 # the database
 : ${SEARCHPATHS="/"}		# directories to be put in the database
-: ${PRUNEPATHS="/tmp /usr/tmp /var/tmp /var/db/freebsd-update"} # unwanted directories
+: ${PRUNEPATHS="/tmp /var/tmp"} # unwanted directories
 : ${PRUNEDIRS=".zfs"}	# unwanted directories, in any parent
-: ${FILESYSTEMS="$(lsvfs | tail -n +3 | \
-	egrep -vw "loopback|network|synthetic|read-only|0" | \
-	cut -d " " -f1)"}		# allowed filesystems
+# allowed filesystems
+: ${FILESYSTEMS="ext2 ext3 ext4 xfs vfat exfat ntfs ntfs3 f2fs zfs btrfs reiserfs reiser4 jfs"}
 : ${find:=find}
 
 if [ -z "$SEARCHPATHS" ]; then
--- src.orig/findutils/locate/locate/util.c
+++ src.freebsd/findutils/locate/locate/util.c
@@ -37,6 +37,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <err.h>
+#include <sys/types.h>
 #include <arpa/inet.h>
 #include <stdio.h>
 #include <sys/stat.h>
@@ -270,7 +271,7 @@
 	/* only for the default locate database */
 	if (strcmp(_PATH_FCODES, db) == 0) {
 		fprintf(stderr, "\nTo create a new database, please run the following command as root:\n\n");
-		fprintf(stderr, "  /etc/periodic/weekly/310.locate\n\n");
+		fprintf(stderr, "  locate-updatedb\n\n");
 	}
 }
 
--- src.orig/findutils/locate/updatedb.sh.in
+++ src.freebsd/findutils/locate/updatedb.sh.in
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# Updates the system database for locate(1).
+#
+# Based on FreeBSD's periodic script, made
+# standalone by q66 <q66@chimera-linux.org>.
+
+echo "Rebuilding locate database..."
+
+. /etc/locate.rc
+: ${FCODES:="/var/db/locate.database"}
+locdb="$FCODES"
+locbase=$(dirname "$locdb")
+
+mkdir -p "$locbase" && rc=0 || rc=3
+touch "$locdb" || rc=3
+chown nobody "$locdb" || rc=3
+chmod 644 "$locdb" || rc=3
+
+cd /
+printf "%s/locate.updatedb\n" @LIBEXECDIR@ | nice -n 5 su -m nobody || rc=3
+chmod 444 $locdb || rc=3
+
+exit $rc
--- src.orig/findutils/xargs/strnsubst.c
+++ src.freebsd/findutils/xargs/strnsubst.c
@@ -14,6 +14,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <stdint.h>
 
 bool	strnsubst(char **, const char *, const char *, size_t);
 
--- src.orig/findutils/xargs/xargs.c
+++ src.freebsd/findutils/xargs/xargs.c
@@ -49,8 +49,8 @@
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <sys/time.h>
-#include <sys/limits.h>
 #include <sys/resource.h>
+#include <limits.h>
 #include <err.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -92,7 +92,7 @@
 static long eoflen;
 static int count, insingle, indouble, oflag, pflag, tflag, Rflag, rval, zflag;
 static int cnt, Iflag, jfound, Lflag, Sflag, wasquoted, xflag;
-static int curprocs, maxprocs;
+static long unsigned int curprocs, maxprocs;
 static pid_t *childpids;
 
 static volatile int childerr;
@@ -607,6 +607,7 @@
 	case -1:
 		warn("vfork");
 		xexit(*argv, 1);
+		break;
 	case 0:
 		if (oflag) {
 			if ((fd = open(_PATH_TTY, O_RDONLY)) == -1)
@@ -701,7 +702,7 @@
 static void
 pids_init(void)
 {
-	int i;
+	long unsigned int i;
 
 	if ((childpids = malloc(maxprocs * sizeof(*childpids))) == NULL)
 		errx(1, "malloc failed");
@@ -760,7 +761,7 @@
 static int
 findslot(pid_t pid)
 {
-	int slot;
+	long unsigned int slot;
 
 	for (slot = 0; slot < maxprocs; slot++)
 		if (childpids[slot] == pid)
@@ -782,22 +783,22 @@
 prompt(void)
 {
 	regex_t cre;
-	size_t rsize;
+	size_t rsize = 0;
 	int match;
-	char *response;
+	char *response = NULL;
 	FILE *ttyfp;
 
 	if ((ttyfp = fopen(_PATH_TTY, "r")) == NULL)
 		return (2);	/* Indicate that the TTY failed to open. */
 	(void)fprintf(stderr, "?...");
 	(void)fflush(stderr);
-	if ((response = fgetln(ttyfp, &rsize)) == NULL ||
+	if (getline(&response, &rsize, ttyfp) < 0 ||
 	    regcomp(&cre, nl_langinfo(YESEXPR), REG_EXTENDED) != 0) {
 		(void)fclose(ttyfp);
 		return (0);
 	}
-	response[rsize - 1] = '\0';
 	match = regexec(&cre, response, 0, NULL, 0);
+	free(response);
 	(void)fclose(ttyfp);
 	regfree(&cre);
 	return (match == 0);
--- src.orig/gencat/gencat.c
+++ src.freebsd/gencat/gencat.c
@@ -84,6 +84,28 @@
 #include <string.h>
 #include <unistd.h>
 
+#define _NLS_MAGIC	0xff88ff89
+
+struct _nls_cat_hdr {
+	int32_t __magic;
+	int32_t __nsets;
+	int32_t __mem;
+	int32_t __msg_hdr_offset;
+	int32_t __msg_txt_offset;
+};
+
+struct _nls_set_hdr {
+	int32_t __setno;	/* set number: 0 < x <= NL_SETMAX */
+	int32_t __nmsgs;	/* number of messages in the set  */
+	int32_t __index;	/* index of first msg_hdr in msg_hdr table */
+};
+
+struct _nls_msg_hdr {
+	int32_t __msgno;	/* msg number: 0 < x <= NL_MSGMAX */
+	int32_t __msglen;
+	int32_t __offset;
+};
+
 struct _msgT {
 	long    msgId;
 	char   *str;
--- src.orig/grep/file.c
+++ src.freebsd/grep/file.c
@@ -40,6 +40,7 @@
 #include <err.h>
 #include <errno.h>
 #include <fcntl.h>
+#include <limits.h>
 #include <stddef.h>
 #include <stdlib.h>
 #include <string.h>
@@ -49,6 +50,10 @@
 
 #include "grep.h"
 
+#ifndef OFF_MAX
+#define OFF_MAX ((off_t)(((1ULL << (sizeof(off_t) * CHAR_BIT - 2)) - 1) * 2 + 1))
+#endif
+
 #define	MAXBUFSIZ	(32 * 1024)
 #define	LNBUFBUMP	80
 
@@ -188,7 +193,7 @@
 		if (fstat(f->fd, &st) == -1 || !S_ISREG(st.st_mode))
 			filebehave = FILE_STDIO;
 		else {
-			int flags = MAP_PRIVATE | MAP_NOCORE | MAP_NOSYNC;
+			int flags = MAP_PRIVATE;
 #ifdef MAP_PREFAULT_READ
 			flags |= MAP_PREFAULT_READ;
 #endif
--- src.orig/grep/grep.c
+++ src.freebsd/grep/grep.c
@@ -64,7 +64,7 @@
 
 /* Flags passed to regcomp() and regexec() */
 int		 cflags = REG_NOSUB | REG_NEWLINE;
-int		 eflags = REG_STARTEND;
+int		 eflags = 0;
 
 bool		 matchall;
 
--- src.orig/grep/grep.h
+++ src.freebsd/grep/grep.h
@@ -30,12 +30,10 @@
  * SUCH DAMAGE.
  */
 
-#include <bzlib.h>
 #include <limits.h>
 #include <regex.h>
 #include <stdbool.h>
 #include <stdio.h>
-#include <zlib.h>
 
 extern const char		*errstr[];
 
--- src.orig/grep/util.c
+++ src.freebsd/grep/util.c
@@ -466,6 +466,30 @@
 
 #define iswword(x)	(iswalnum((x)) || (x) == L'_')
 
+#ifndef REG_STARTEND
+static int regexec_startend(
+    const regex_t *restrict preg, char *restrict str, size_t nmatch,
+    regmatch_t pmatch[restrict], int eflags
+) {
+	regoff_t so = pmatch[0].rm_so;
+	regoff_t eo = pmatch[0].rm_eo;
+	char old = str[eo];
+	str[eo] = '\0';
+	int ret = regexec(preg, str + so, nmatch, pmatch, eflags);
+	str[eo] = old;
+	pmatch[0].rm_so += so;
+	pmatch[0].rm_eo += so;
+	return ret;
+}
+#else
+static int regexec_startend(
+    const regex_t *restrict preg, const char *restrict str, size_t nmatch,
+    regmatch_t pmatch[restrict], int eflags
+) {
+	return regexec(preg, str, nmatch, pmatch, eflags | REG_STARTEND);
+}
+#endif
+
 /*
  * Processes a line comparing it with the specified patterns.  Each pattern
  * is looped to be compared along with the full string, saving each and every
@@ -533,7 +557,7 @@
 				r = litexec(&pattern[i], pc->ln.dat, 1, &pmatch);
 			else
 #endif
-			r = regexec(&r_pattern[i], pc->ln.dat, 1, &pmatch,
+			r = regexec_startend(&r_pattern[i], pc->ln.dat, 1, &pmatch,
 			    leflags);
 			if (r != 0)
 				continue;
--- src.orig/gzip/gzip.c
+++ src.freebsd/gzip/gzip.c
@@ -48,13 +48,21 @@
  *	- make bzip2/compress -v/-t/-l support work as well as possible
  */
 
-#include <sys/endian.h>
+static inline unsigned le32dec(const void *s) {
+	const unsigned char *p = (const unsigned char *)s;
+	return (((unsigned)p[3] << 24) | (p[2] << 16) | (p[1] << 8) | p[0]);
+}
+
+#define nitems(x) (sizeof((x)) / sizeof((x)[0]))
+
 #include <sys/param.h>
 #include <sys/stat.h>
 #include <sys/time.h>
+#include <sys/types.h>
 
 #include <inttypes.h>
 #include <unistd.h>
+#include <signal.h>
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
@@ -367,7 +375,7 @@
 			break;
 		case 'V':
 			display_version();
-			/* NOTREACHED */
+			break; /* NOTREACHED */
 		case 'a':
 			fprintf(stderr, "%s: option --ascii ignored on this system\n", progname);
 			break;
@@ -379,7 +387,7 @@
 			break;
 		case 'L':
 			display_license();
-			/* NOT REACHED */
+			break; /* NOT REACHED */
 		case 'N':
 			nflag = 0;
 			Nflag = 1;
@@ -1100,9 +1108,11 @@
 	if (futimens(fd, times) < 0)
 		maybe_warn("couldn't futimens: %s", file);
 
+#if 0
 	/* only try flags if they exist already */
         if (sb.st_flags != 0 && fchflags(fd, sb.st_flags) < 0)
 		maybe_warn("couldn't fchflags: %s", file);
+#endif
 }
 
 /* what sort of file is this? */
--- src.orig/gzip/unxz.c
+++ src.freebsd/gzip/unxz.c
@@ -36,6 +36,7 @@
 #include <stdio.h>
 #include <unistd.h>
 #include <lzma.h>
+#include <sys/stat.h>
 
 static off_t
 unxz(int i, int o, char *pre, size_t prelen, off_t *bytes_in)
@@ -80,7 +81,7 @@
 			switch (strm.avail_in) {
 			case (size_t)-1:
 				maybe_err("read failed");
-				/*NOTREACHED*/
+				break; /*NOTREACHED*/
 			case 0:
 				action = LZMA_FINISH;
 				break;
--- src.orig/gzip/zuncompress.c
+++ src.freebsd/gzip/zuncompress.c
@@ -39,8 +39,13 @@
 
 /* This file is #included by gzip.c */
 
-static int	zread(void *, char *, int);
+static ssize_t
+zread(void *cookie, char *rbp, size_t num);
 
+#ifndef EFTYPE
+#define EFTYPE EINVAL
+#endif
+
 #define	tab_prefixof(i)	(zs->zs_codetab[i])
 #define	tab_suffixof(i)	((char_type *)(zs->zs_htab))[i]
 #define	de_stack	((char_type *)&tab_suffixof(1 << BITS))
@@ -173,6 +178,7 @@
 zdopen(int fd)
 {
 	struct s_zstate *zs;
+	cookie_io_functions_t zfuncs;
 
 	if ((zs = calloc(1, sizeof(struct s_zstate))) == NULL)
 		return (NULL);
@@ -200,7 +206,12 @@
 		return NULL;
 	}
 
-	return funopen(zs, zread, NULL, NULL, zclose);
+	zfuncs.read = zread;
+	zfuncs.write = NULL;
+	zfuncs.seek = NULL;
+	zfuncs.close = zclose;
+
+	return fopencookie(zs, "r", zfuncs);
 }
 
 /*
@@ -209,8 +220,8 @@
  * compressed file.  The tables used herein are shared with those of the
  * compress() routine.  See the definitions above.
  */
-static int
-zread(void *cookie, char *rbp, int num)
+static ssize_t
+zread(void *cookie, char *rbp, size_t num)
 {
 	u_int count, i;
 	struct s_zstate *zs;
--- src.orig/include/fts.h
+++ src.freebsd/include/fts.h
@@ -34,19 +34,25 @@
 #ifndef	_FTS_H_
 #define	_FTS_H_
 
-#include <sys/_types.h>
+#ifdef _CHIMERAUTILS_BUILD
+#include "config-compat.h"
+#endif
 
+#if !defined(_CHIMERAUTILS_BUILD) || !defined(HAVE_FTS_OPEN)
+
+#include <sys/types.h>
+
 typedef struct {
 	struct _ftsent *fts_cur;	/* current node */
 	struct _ftsent *fts_child;	/* linked list of children */
 	struct _ftsent **fts_array;	/* sort array */
-	__dev_t fts_dev;		/* starting device # */
+	dev_t fts_dev;		/* starting device # */
 	char *fts_path;			/* path for this descent */
 	int fts_rfd;			/* fd for root */
-	__size_t fts_pathlen;		/* sizeof(path) */
-	__size_t fts_nitems;		/* elements in the sort array */
+	size_t fts_pathlen;		/* sizeof(path) */
+	size_t fts_nitems;		/* elements in the sort array */
 	int (*fts_compar)		/* compare function */
-	    (const struct _ftsent * const *, const struct _ftsent * const *);
+	    (const struct _ftsent **, const struct _ftsent **);
 
 #define	FTS_COMFOLLOW	0x001		/* follow command line symlinks */
 #define	FTS_LOGICAL	0x002		/* logical walk */
@@ -55,7 +61,9 @@
 #define	FTS_PHYSICAL	0x010		/* physical walk */
 #define	FTS_SEEDOT	0x020		/* return dot and dot-dot */
 #define	FTS_XDEV	0x040		/* don't cross devices */
+#if 0
 #define	FTS_WHITEOUT	0x080		/* return whiteout information */
+#endif
 #define	FTS_OPTIONMASK	0x0ff		/* valid user option mask */
 
 #define	FTS_NAMEONLY	0x100		/* (private) child names only */
@@ -75,12 +83,12 @@
 	char *fts_path;			/* root path */
 	int fts_errno;			/* errno for this node */
 	int fts_symfd;			/* fd for symlink */
-	__size_t fts_pathlen;		/* strlen(fts_path) */
-	__size_t fts_namelen;		/* strlen(fts_name) */
+	size_t fts_pathlen;		/* strlen(fts_path) */
+	size_t fts_namelen;		/* strlen(fts_name) */
 
-	__ino_t fts_ino;		/* inode */
-	__dev_t fts_dev;		/* device */
-	__nlink_t fts_nlink;		/* link count */
+	ino_t fts_ino;		/* inode */
+	dev_t fts_dev;		/* device */
+	nlink_t fts_nlink;		/* link count */
 
 #define	FTS_ROOTPARENTLEVEL	-1
 #define	FTS_ROOTLEVEL		 0
@@ -99,12 +107,16 @@
 #define	FTS_NSOK	11		/* no stat(2) requested */
 #define	FTS_SL		12		/* symbolic link */
 #define	FTS_SLNONE	13		/* symbolic link without target */
+#if 0
 #define	FTS_W		14		/* whiteout object */
+#endif
 	int fts_info;			/* user status for FTSENT structure */
 
 #define	FTS_DONTCHDIR	 0x01		/* don't chdir .. to the parent */
 #define	FTS_SYMFOLLOW	 0x02		/* followed a symlink to get here */
+#if 0
 #define	FTS_ISW		 0x04		/* this is a whiteout object */
+#endif
 	unsigned fts_flags;		/* private flags for FTSENT structure */
 
 #define	FTS_AGAIN	 1		/* read node again */
@@ -118,9 +130,10 @@
 	FTS *fts_fts;			/* back pointer to main FTS */
 } FTSENT;
 
-#include <sys/cdefs.h>
+#ifdef __cplusplus
+extern "C" {
+#endif
 
-__BEGIN_DECLS
 FTSENT	*fts_children(FTS *, int);
 int	 fts_close(FTS *);
 void	*fts_get_clientptr(FTS *);
@@ -128,10 +141,17 @@
 FTS	*fts_get_stream(FTSENT *);
 #define	 fts_get_stream(ftsent)	((ftsent)->fts_fts)
 FTS	*fts_open(char * const *, int,
-	    int (*)(const FTSENT * const *, const FTSENT * const *));
+	    int (*)(const FTSENT **, const FTSENT **));
 FTSENT	*fts_read(FTS *);
 int	 fts_set(FTS *, FTSENT *, int);
 void	 fts_set_clientptr(FTS *, void *);
-__END_DECLS
+
+#ifdef __cplusplus
+}
+#endif
+
+#else
+#  include_next <fts.h>
+#endif
 
 #endif /* !_FTS_H_ */
--- src.orig/include/rpmatch.h
+++ src.freebsd/include/rpmatch.h
@@ -0,0 +1,24 @@
+#ifndef _RPMATCH_H_
+#define _RPMATCH_H_
+
+#ifdef _CHIMERAUTILS_BUILD
+#include "config-compat.h"
+#endif
+
+#if !defined(_CHIMERAUTILS_BUILD) || !defined(HAVE_RPMATCH)
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern int rpmatch(const char *response);
+
+#ifdef __cplusplus
+}
+#endif
+
+#else
+#  include <stdlib.h>
+#endif
+
+#endif
--- src.orig/jot/jot.c
+++ src.freebsd/jot/jot.c
@@ -48,6 +48,7 @@
  */
 
 #include <sys/capsicum.h>
+#include <sys/random.h>
 #include <capsicum_helpers.h>
 #include <ctype.h>
 #include <err.h>
@@ -198,9 +199,11 @@
 		break;
 	case 0:
 		usage();
+		break;
 	default:
 		errx(1, "too many arguments.  What do you mean by %s?",
 		    argv[4]);
+		break;
 	}
 	getformat();
 
@@ -319,8 +322,12 @@
 		for (i = 1; i <= reps || infinity; i++) {
 			if (use_random)
 				y = random() / divisor;
-			else
-				y = arc4random() / divisor;
+			else {
+				uint32_t yv;
+				if (getrandom(&yv, sizeof(yv), 0) < 0)
+					err(1, "getrandom");
+				y = yv / divisor;
+			}
 			if (putdata(y * x + begin, !(reps - i)))
 				errx(1, "range error in conversion");
 		}
@@ -477,27 +484,31 @@
 				intdata = true;
 				break;
 			}
+			goto fmt_broken;
 		case 'O': case 'U':
 			if (!longdata) {
 				intdata = nosign = true;
 				break;
 			}
+			goto fmt_broken;
 		case 'c':
 			if (!(intdata | longdata)) {
 				chardata = true;
 				break;
 			}
+			goto fmt_broken;
 		case 'h': case 'n': case 'p': case 'q': case 's': case 'L':
 		case '$': case '*':
 			goto fmt_broken;
 		case 'f': case 'e': case 'g': case 'E': case 'G':
 			if (!longdata)
 				break;
-			/* FALLTHROUGH */
+			goto fmt_broken;
 		default:
 fmt_broken:
 			*++p = '\0';
 			errx(1, "illegal or unsupported format '%s'", p2);
+			break;
 			/* NOTREACHED */
 		}
 		while (*++p)
--- src.orig/libfetch/common.c
+++ src.freebsd/libfetch/common.c
@@ -135,10 +135,7 @@
 	{ SOCKS5_ERR_BAD_PORT,		FETCH_ABORT,	"SOCKS5: Bad port" }
 };
 
-/* End-of-Line */
-static const char ENDL[2] = "\r\n";
 
-
 /*** Error-reporting functions ***********************************************/
 
 /*
@@ -176,8 +173,12 @@
 	case EPERM:
 	case EACCES:
 	case EROFS:
+#ifdef EAUTH
 	case EAUTH:
+#endif
+#ifdef ENEEDAUTH
 	case ENEEDAUTH:
+#endif
 		fetchLastErrCode = FETCH_AUTH;
 		break;
 	case ENOENT:
@@ -278,13 +279,11 @@
 fetch_reopen(int sd)
 {
 	conn_t *conn;
-	int opt = 1;
 
 	/* allocate and fill connection structure */
 	if ((conn = calloc(1, sizeof(*conn))) == NULL)
 		return (NULL);
 	fcntl(sd, F_SETFD, FD_CLOEXEC);
-	setsockopt(sd, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof opt);
 	conn->sd = sd;
 	++conn->ref;
 	return (conn);
@@ -408,15 +407,16 @@
 	 * Largest FQDN (256) + one byte size (1) +
 	 * Port (2)
 	 */
-	unsigned char buf[BUFF_SIZE];
+	char buf[BUFF_SIZE];
 	unsigned char *ptr;
+	ptrdiff_t dif;
 	int ret = 1;
 
 	if (verbose)
 		fetch_info("Initializing SOCKS5 connection: %s:%d", host, port);
 
 	/* Connection initialization */
-	ptr = buf;
+	ptr = (unsigned char *)buf;
 	*ptr++ = SOCKS_VERSION_5;
 	*ptr++ = SOCKS_CONNECTION;
 	*ptr++ = SOCKS_RSV;
@@ -432,7 +432,7 @@
 		goto fail;
 	}
 
-	ptr = buf;
+	ptr = (unsigned char *)buf;
 	if (ptr[0] != SOCKS_VERSION_5) {
 		ret = SOCKS5_ERR_VER5_ONLY;
 		goto fail;
@@ -464,7 +464,8 @@
 	*ptr++ = port & 0x00ff;
 	*ptr++ = (port & 0xff00) >> 8;
 
-	if (fetch_write(conn, buf, ptr - buf) != ptr - buf) {
+	dif = ptr - (unsigned char *)buf;
+	if (fetch_write(conn, buf, dif) != dif) {
 		ret = SOCKS5_ERR_REQUEST;
 		goto fail;
 	}
@@ -475,7 +476,7 @@
 		goto fail;
 	}
 
-	ptr = buf;
+	ptr = (unsigned char *)buf;
 	if (*ptr++ != SOCKS_VERSION_5) {
 		ret = SOCKS5_ERR_NON_VER5_RESP;
 		goto fail;
@@ -702,6 +703,7 @@
 }
 
 #ifdef WITH_SSL
+#if 0
 /*
  * Convert characters A-Z to lowercase (intentionally avoid any locale
  * specific conversions).
@@ -1030,6 +1032,7 @@
 		GENERAL_NAMES_free(altnames);
 	return (ret);
 }
+#endif
 
 /*
  * Configure transport security layer based on environment.
@@ -1222,7 +1225,9 @@
 	if (getenv("SSL_NO_VERIFY_HOSTNAME") == NULL) {
 		if (verbose)
 			fetch_info("Verify hostname");
-		if (!fetch_ssl_verify_hname(conn->ssl_cert, URL->host)) {
+		if (X509_check_host(conn->ssl_cert, URL->host, strlen(URL->host),
+				X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS,
+				NULL) != 1) {
 			fprintf(stderr,
 			    "SSL certificate subject doesn't match host %s\n",
 			    URL->host);
@@ -1310,7 +1315,7 @@
 		timeout.tv_sec += fetchTimeout;
 	}
 
-	deltams = INFTIM;
+	deltams = -1;
 	memset(&pfd, 0, sizeof pfd);
 	pfd.fd = conn->sd;
 	pfd.events = POLLIN | POLLERR;
@@ -1420,27 +1425,12 @@
 	return (0);
 }
 
-
 /*
  * Write to a connection w/ timeout
  */
 ssize_t
 fetch_write(conn_t *conn, const char *buf, size_t len)
 {
-	struct iovec iov;
-
-	iov.iov_base = __DECONST(char *, buf);
-	iov.iov_len = len;
-	return fetch_writev(conn, &iov, 1);
-}
-
-/*
- * Write a vector to a connection w/ timeout
- * Note: can modify the iovec.
- */
-ssize_t
-fetch_writev(conn_t *conn, struct iovec *iov, int iovcnt)
-{
 	struct timeval now, timeout, delta;
 	struct pollfd pfd;
 	ssize_t wlen, total;
@@ -1455,7 +1445,7 @@
 	}
 
 	total = 0;
-	while (iovcnt > 0) {
+	while (len) {
 		while (fetchTimeout && pfd.revents == 0) {
 			gettimeofday(&now, NULL);
 			if (!timercmp(&timeout, &now, >)) {
@@ -1480,11 +1470,10 @@
 		errno = 0;
 #ifdef WITH_SSL
 		if (conn->ssl != NULL)
-			wlen = SSL_write(conn->ssl,
-			    iov->iov_base, iov->iov_len);
+			wlen = SSL_write(conn->ssl, buf, len);
 		else
 #endif
-			wlen = writev(conn->sd, iov, iovcnt);
+			wlen = send(conn->sd, buf, len, MSG_NOSIGNAL);
 		if (wlen == 0) {
 			/* we consider a short write a failure */
 			/* XXX perhaps we shouldn't in the SSL case */
@@ -1498,20 +1487,13 @@
 			return (-1);
 		}
 		total += wlen;
-		while (iovcnt > 0 && wlen >= (ssize_t)iov->iov_len) {
-			wlen -= iov->iov_len;
-			iov++;
-			iovcnt--;
-		}
-		if (iovcnt > 0) {
-			iov->iov_len -= wlen;
-			iov->iov_base = __DECONST(char *, iov->iov_base) + wlen;
-		}
+		buf += wlen;
+		len -= wlen;
 	}
 	return (total);
 }
 
-
+#if 0
 /*
  * Write a line of text to a connection w/ timeout
  */
@@ -1534,6 +1516,7 @@
 		return (-1);
 	return (0);
 }
+#endif
 
 
 /*
--- src.orig/libfetch/common.h
+++ src.freebsd/libfetch/common.h
@@ -44,6 +44,10 @@
 #include <openssl/err.h>
 #endif
 
+#ifndef IPPORT_MAX
+# define IPPORT_MAX 65535
+#endif
+
 /* Connection */
 typedef struct fetchconn conn_t;
 struct fetchconn {
@@ -100,9 +104,6 @@
 #define SOCKS_COMMAND_NOT_SUPPORTED	0x07
 #define SOCKS_ADDRESS_NOT_SUPPORTED	0x08
 
-/* for fetch_writev */
-struct iovec;
-
 void		 fetch_seterr(struct fetcherr *, int);
 void		 fetch_syserr(void);
 void		 fetch_info(const char *, ...) __printflike(1, 2);
@@ -123,8 +124,6 @@
 ssize_t		 fetch_read(conn_t *, char *, size_t);
 int		 fetch_getln(conn_t *);
 ssize_t		 fetch_write(conn_t *, const char *, size_t);
-ssize_t		 fetch_writev(conn_t *, struct iovec *, int);
-int		 fetch_putln(conn_t *, const char *, size_t);
 int		 fetch_close(conn_t *);
 int		 fetch_add_entry(struct url_ent **, int *, int *,
 		     const char *, struct url_stat *);
--- src.orig/libfetch/ftp.c
+++ src.freebsd/libfetch/ftp.c
@@ -77,6 +77,10 @@
 #include "common.h"
 #include "ftperr.h"
 
+#ifndef MAXLOGNAME
+#define MAXLOGNAME LOGIN_NAME_MAX
+#endif
+
 #define FTP_ANONYMOUS_USER	"anonymous"
 
 #define FTP_CONNECTION_ALREADY_OPEN	125
@@ -133,7 +137,9 @@
 	sin4->sin_addr.s_addr = addr;
 	sin4->sin_port = port;
 	sin4->sin_family = AF_INET;
+#ifdef HAVE_SA_LEN
 	sin4->sin_len = sizeof(struct sockaddr_in);
+#endif
 }
 
 /*
@@ -176,7 +182,7 @@
  * Send a command and check reply
  */
 static int
-ftp_cmd(conn_t *conn, const char *fmt, ...)
+ftp_cmdf(conn_t *conn, const char *fmt, ...)
 {
 	va_list ap;
 	size_t len;
@@ -193,7 +199,7 @@
 		return (-1);
 	}
 
-	r = fetch_putln(conn, msg, len);
+	r = fetch_write(conn, msg, len);
 	free(msg);
 
 	if (r == -1) {
@@ -204,6 +210,8 @@
 	return (ftp_chkerr(conn));
 }
 
+#define ftp_cmd(conn, fmt, ...) ftp_cmdf(conn, fmt "\r\n", ## __VA_ARGS__)
+
 /*
  * Return a pointer to the filename part of a path
  */
@@ -380,9 +388,10 @@
 	case 'A':
 		break;
 	case 'd':
-		type = 'D';
 	case 'D':
+		type = 'D';
 		/* can't handle yet */
+		return (FTP_PROTOCOL_ERROR);
 	default:
 		return (FTP_PROTOCOL_ERROR);
 	}
@@ -483,16 +492,16 @@
 	int	 err;		/* Error code */
 };
 
-static int	 ftp_readfn(void *, char *, int);
-static int	 ftp_writefn(void *, const char *, int);
-static fpos_t	 ftp_seekfn(void *, fpos_t, int);
+static ssize_t	 ftp_readfn(void *, char *, size_t);
+static ssize_t	 ftp_writefn(void *, const char *, size_t);
+static int	 ftp_seekfn(void *, off_t *, int);
 static int	 ftp_closefn(void *);
 
-static int
-ftp_readfn(void *v, char *buf, int len)
+static ssize_t
+ftp_readfn(void *v, char *buf, size_t len)
 {
 	struct ftpio *io;
-	int r;
+	ssize_t r;
 
 	io = (struct ftpio *)v;
 	if (io == NULL) {
@@ -521,11 +530,11 @@
 	return (-1);
 }
 
-static int
-ftp_writefn(void *v, const char *buf, int len)
+static ssize_t
+ftp_writefn(void *v, const char *buf, size_t len)
 {
 	struct ftpio *io;
-	int w;
+	ssize_t w;
 
 	io = (struct ftpio *)v;
 	if (io == NULL) {
@@ -548,8 +557,8 @@
 	return (-1);
 }
 
-static fpos_t
-ftp_seekfn(void *v, fpos_t pos __unused, int whence __unused)
+static int
+ftp_seekfn(void *v, off_t *pos __unused, int whence __unused)
 {
 	struct ftpio *io;
 
@@ -596,6 +605,7 @@
 {
 	struct ftpio *io;
 	FILE *f;
+	cookie_io_functions_t iof;
 
 	if (cconn == NULL || dconn == NULL)
 		return (NULL);
@@ -605,7 +615,11 @@
 	io->dconn = dconn;
 	io->dir = mode;
 	io->eof = io->err = 0;
-	f = funopen(io, ftp_readfn, ftp_writefn, ftp_seekfn, ftp_closefn);
+	iof.read = ftp_readfn;
+	iof.write = ftp_writefn;
+	iof.seek = ftp_seekfn;
+	iof.close = ftp_closefn;
+	f = fopencookie(io, "w+", iof);
 	if (f == NULL)
 		free(io);
 	return (f);
@@ -624,14 +638,19 @@
 	const char *bindaddr;
 	const char *filename;
 	int filenamelen, type;
-	int low, pasv, verbose;
+#if defined(IPV6_PORTRANGE) || defined(IP_PORTRANGE)
+	int low;
+#endif
+	int pasv, verbose;
 	int e, sd = -1;
 	socklen_t l;
 	char *s;
 	FILE *df;
 
 	/* check flags */
+#if defined(IPV6_PORTRANGE) || defined(IP_PORTRANGE)
 	low = CHECK_FLAG('l');
+#endif
 	pasv = CHECK_FLAG('p') || !CHECK_FLAG('P');
 	verbose = CHECK_FLAG('v');
 
@@ -772,7 +791,7 @@
 		if (bindaddr != NULL && *bindaddr != '\0' &&
 		    (e = fetch_bind(sd, sa.ss_family, bindaddr)) != 0)
 			goto ouch;
-		if (connect(sd, (struct sockaddr *)&sa, sa.ss_len) == -1)
+		if (connect(sd, (struct sockaddr *)&sa, l) == -1)
 			goto sysouch;
 
 		/* make the server initiate the transfer */
@@ -785,7 +804,10 @@
 	} else {
 		u_int32_t a;
 		u_short p;
-		int arg, d;
+#if defined(IPV6_PORTRANGE) || defined(IP_PORTRANGE)
+		int arg;
+#endif
+		int d;
 		char *ap;
 		char hname[INET6_ADDRSTRLEN];
 
@@ -801,15 +823,17 @@
 			break;
 		case AF_INET:
 			((struct sockaddr_in *)&sa)->sin_port = 0;
+#ifdef IP_PORTRANGE
 			arg = low ? IP_PORTRANGE_DEFAULT : IP_PORTRANGE_HIGH;
 			if (setsockopt(sd, IPPROTO_IP, IP_PORTRANGE,
 				(char *)&arg, sizeof(arg)) == -1)
 				goto sysouch;
+#endif
 			break;
 		}
 		if (verbose)
 			fetch_info("binding data socket");
-		if (bind(sd, (struct sockaddr *)&sa, sa.ss_len) == -1)
+		if (bind(sd, (struct sockaddr *)&sa, l) == -1)
 			goto sysouch;
 		if (listen(sd, 1) == -1)
 			goto sysouch;
@@ -832,7 +856,7 @@
 			e = -1;
 			sin6 = (struct sockaddr_in6 *)&sa;
 			sin6->sin6_scope_id = 0;
-			if (getnameinfo((struct sockaddr *)&sa, sa.ss_len,
+			if (getnameinfo((struct sockaddr *)&sa, l,
 				hname, sizeof(hname),
 				NULL, 0, NI_NUMERICHOST) == 0) {
 				e = ftp_cmd(conn, "EPRT |%d|%s|%d|", 2, hname,
--- src.orig/libfetch/gen_errors.sh
+++ src.freebsd/libfetch/gen_errors.sh
@@ -0,0 +1,12 @@
+#!/bin/sh
+
+ERRTYPE=$1
+ERRLIST=$2
+ERRTYPE_U=$(echo $ERRTYPE|tr '[:lower:]' '[:upper:]')
+
+echo "static struct fetcherr ${ERRTYPE}_errlist[] = {"
+cat "$ERRLIST" | grep -v "^#" | sort | while read NUM CAT STRING; do
+    echo "    {${NUM}, FETCH_${CAT}, \"${STRING}\"},"
+done
+echo "    {-1, FETCH_UNKNOWN, \"Unknown ${ERRTYPE_U} error\"}"
+echo "};"
--- src.orig/libfetch/http.c
+++ src.freebsd/libfetch/http.c
@@ -82,7 +82,7 @@
 #include <openssl/md5.h>
 #define MD5Init(c) MD5_Init(c)
 #define MD5Update(c, data, len) MD5_Update(c, data, len)
-#define MD5Final(md, c) MD5_Final(md, c)
+#define MD5Final(md, c) MD5_Final((unsigned char *)md, c)
 #else
 #include <md5.h>
 #endif
@@ -267,8 +267,8 @@
 /*
  * Read function
  */
-static int
-http_readfn(void *v, char *buf, int len)
+static ssize_t
+http_readfn(void *v, char *buf, size_t len)
 {
 	struct httpio *io = (struct httpio *)v;
 	int rlen;
@@ -290,7 +290,7 @@
 	}
 
 	rlen = io->buflen - io->bufpos;
-	if (len < rlen)
+	if (rlen > 0 && len < (size_t)rlen)
 		rlen = len;
 	memcpy(buf, io->buf + io->bufpos, rlen);
 	io->bufpos += rlen;
@@ -300,8 +300,8 @@
 /*
  * Write function
  */
-static int
-http_writefn(void *v, const char *buf, int len)
+static ssize_t
+http_writefn(void *v, const char *buf, size_t len)
 {
 	struct httpio *io = (struct httpio *)v;
 
@@ -332,6 +332,7 @@
 {
 	struct httpio *io;
 	FILE *f;
+	cookie_io_functions_t iof;
 
 	if ((io = calloc(1, sizeof(*io))) == NULL) {
 		fetch_syserr();
@@ -339,7 +340,11 @@
 	}
 	io->conn = conn;
 	io->chunked = chunked;
-	f = funopen(io, http_readfn, http_writefn, NULL, http_closefn);
+	iof.read = http_readfn;
+	iof.write = http_writefn;
+	iof.seek = NULL;
+	iof.close = http_closefn;
+	f = fopencookie(io, "w+", iof);
 	if (f == NULL) {
 		fetch_syserr();
 		free(io);
@@ -387,7 +392,7 @@
  * Send a formatted line; optionally echo to terminal
  */
 static int
-http_cmd(conn_t *conn, const char *fmt, ...)
+http_cmdf(conn_t *conn, const char *fmt, ...)
 {
 	va_list ap;
 	size_t len;
@@ -404,7 +409,7 @@
 		return (-1);
 	}
 
-	r = fetch_putln(conn, msg, len);
+	r = fetch_write(conn, msg, len);
 	free(msg);
 
 	if (r == -1) {
@@ -415,6 +420,8 @@
 	return (0);
 }
 
+#define http_cmd(conn, fmt, ...) http_cmdf(conn, fmt "\r\n", ## __VA_ARGS__)
+
 /*
  * Get and parse status line
  */
@@ -1478,13 +1485,17 @@
 	if (strcmp(URL->scheme, SCHEME_HTTPS) == 0 &&
 	    fetch_ssl(conn, URL, verbose) == -1) {
 		/* grrr */
+#ifdef EAUTH
 		errno = EAUTH;
+#else
+		errno = EPERM;
+#endif
 		fetch_syserr();
 		goto ouch;
 	}
 
 	val = 1;
-	setsockopt(conn->sd, IPPROTO_TCP, TCP_NOPUSH, &val, sizeof(val));
+	setsockopt(conn->sd, IPPROTO_TCP, TCP_CORK, &val, sizeof(val));
 
 	clean_http_headerbuf(&headerbuf);
 	return (conn);
@@ -1788,7 +1799,7 @@
 		 * options to force the pending data to be written.
 		 */
 		val = 0;
-		setsockopt(conn->sd, IPPROTO_TCP, TCP_NOPUSH, &val,
+		setsockopt(conn->sd, IPPROTO_TCP, TCP_CORK, &val,
 			   sizeof(val));
 		val = 1;
 		setsockopt(conn->sd, IPPROTO_TCP, TCP_NODELAY, &val,
--- src.orig/libmp/mpasbn.c
+++ src.freebsd/libmp/mpasbn.c
@@ -91,7 +91,7 @@
 } while (0)
 
 static void _bnerr(const char *);
-static MINT *_dtom(const char *, const char *);
+/*static MINT *_dtom(const char *, const char *);*/
 static MINT *_itom(const char *, short);
 static void _madd(const char *, const MINT *, const MINT *, MINT *);
 static int _mcmpa(const char *, const MINT *, const MINT *);
@@ -118,6 +118,7 @@
 	MPERRX(("%s: %s", msg, ERR_reason_error_string(ERR_get_error())));
 }
 
+#if 0
 /*
  * Convert a decimal string to an MINT.
  */
@@ -135,6 +136,7 @@
 	BN_ERRCHECK(msg, BN_dec2bn(&mp->bn, s));
 	return (mp);
 }
+#endif
 
 /*
  * Compute the greatest common divisor of mp1 and mp2; result goes in rmp.
@@ -277,6 +279,7 @@
 	_mfree("mfree", mp);
 }
 
+#if 0
 /*
  * Read an integer from standard input and stick the result in mp.
  * The input is treated to be in base 10.  This must be the silliest
@@ -304,6 +307,7 @@
 	_mfree("min", rmp);
 	free(nline);
 }
+#endif
 
 /*
  * Print the value of mp to standard output in base 10.  See blurb
--- src.orig/m4/eval.c
+++ src.freebsd/m4/eval.c
@@ -409,7 +409,7 @@
 
 			temp = xstrdup(argv[2]);
 
-			fd = mkstemp(temp);
+			fd = compat_mkstemp(temp);
 			if (fd == -1)
 				err(1,
 	    "%s at line %lu: couldn't make temp file %s",
@@ -843,7 +843,7 @@
 	if (outfile[n] == NULL) {
 		char fname[] = _PATH_DIVNAME;
 
-		if ((fd = mkstemp(fname)) == -1 ||
+		if ((fd = compat_mkstemp(fname)) == -1 ||
 		    unlink(fname) == -1 ||
 		    (outfile[n] = fdopen(fd, "w+")) == NULL)
 			err(1, "%s: cannot divert", fname);
--- src.orig/m4/parser.y
+++ src.freebsd/m4/parser.y
@@ -18,6 +18,7 @@
 
 #include <math.h>
 #include <stdint.h>
+#include <stdlib.h>
 #define YYSTYPE	int32_t
 extern int32_t end_result;
 extern int yylex(void);
--- src.orig/miscutils/calendar/calendar.1
+++ src.freebsd/miscutils/calendar/calendar.1
@@ -263,9 +263,9 @@
 .It Pa ~/.calendar/nomail
 do not send mail if this file exists.
 .It Pa /usr/share/calendar
-system wide location of calendar files provided as part of the base system.
+system wide location of calendar files.
 .It Pa /usr/local/share/calendar
-system wide location for calendar files provided by a port or package.
+alternate system wide location for calendar files.
 .El
 .Pp
 The order of precedence in searches for a calendar file is:
@@ -273,7 +273,7 @@
 Files of similar names are ignored in lower precedence locations.
 .Pp
 The following default calendar files are provided by the
-deskutils/calendar-data port.
+chimerautils-calendar-data package.
 .Pp
 .Bl -tag -width calendar.southafrica -compact
 .It Pa calendar.all
@@ -292,10 +292,6 @@
 Calendar of events in Croatia.
 .It Pa calendar.dutch
 Calendar of events in the Netherlands.
-.It Pa calendar.freebsd
-Birthdays of
-.Fx
-committers.
 .It Pa calendar.french
 Calendar of events in France.
 .It Pa calendar.german
--- src.orig/miscutils/calendar/calendar.c
+++ src.freebsd/miscutils/calendar/calendar.c
@@ -46,7 +46,6 @@
 #include <err.h>
 #include <errno.h>
 #include <locale.h>
-#include <login_cap.h>
 #include <langinfo.h>
 #include <pwd.h>
 #include <stdio.h>
@@ -220,12 +219,6 @@
 			if (pid < 0)
 				err(1, "fork");
 			if (pid == 0) {
-				login_cap_t *lc;
-
-				lc = login_getpwclass(pw);
-				if (setusercontext(lc, pw, pw->pw_uid,
-				    LOGIN_SETALL & ~LOGIN_SETLOGIN) != 0)
-					errx(1, "setusercontext");
 				setenv("HOME", pw->pw_dir, 1);
 				cal();
 				exit(0);
--- src.orig/miscutils/calendar/day.c
+++ src.freebsd/miscutils/calendar/day.c
@@ -35,7 +35,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <time.h>
+#include <time_bsd.h>
 
 #include "calendar.h"
 
@@ -63,7 +63,7 @@
 	localtime_r(&time2, tp2);
 	year2 = 1900 + tp2->tm_year;
 
-	strftime(dayname, sizeof(dayname) - 1, "%A, %d %B %Y", tp1);
+	strftime_bsd(dayname, sizeof(dayname) - 1, "%A, %d %B %Y", tp1);
 
 	setnnames();
 }
--- src.orig/miscutils/calendar/events.c
+++ src.freebsd/miscutils/calendar/events.c
@@ -34,6 +34,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <time_bsd.h>
 #ifdef WITH_ICONV
 #include <iconv.h>
 #include <errno.h>
@@ -202,8 +203,11 @@
 	char dbuf[80];
 	static int d_first;
 
-	d_first = (*nl_langinfo(D_MD_ORDER) == 'd');
+	d_first = 0;
+	if (strlen(nl_langinfo(D_FMT)) >= 2 && nl_langinfo(D_FMT)[1] == 'd')
+		d_first = 1;
 
+
 	while (walkthrough_dates(&e) != 0) {
 		if (e) {
 #ifdef DEBUG
@@ -214,7 +218,7 @@
 			tm.tm_mday = e->day;
 			tm.tm_mon = e->month - 1;
 			tm.tm_year = e->year - 1900;
-			(void)strftime(dbuf, sizeof(dbuf), d_first ? "%e %b" : "%b %e", &tm);
+			(void)strftime_bsd(dbuf, sizeof(dbuf), d_first ? "%e %b" : "%b %e", &tm);
 		}
 
 		/*
--- src.orig/miscutils/calendar/io.c
+++ src.freebsd/miscutils/calendar/io.c
@@ -121,9 +121,6 @@
 	char *home = getenv("HOME");
 	unsigned int i;
 	int fd;
-	struct stat sb;
-	static bool warned = false;
-	static char calendarhome[MAXPATHLEN];
 
 	if (home == NULL || *home == '\0') {
 		warnx("Cannot get home directory");
@@ -164,29 +161,18 @@
 	}
 
 	for (i = 0; i < nitems(calendarHomes); i++) {
-		if (snprintf(calendarhome, sizeof (calendarhome), calendarHomes[i],
-			getlocalbase()) >= (int)sizeof (calendarhome))
+		if (chdir(calendarHomes[i]) != 0)
 			continue;
 
-		if (chdir(calendarhome) != 0)
-			continue;
-
 		if ((fp = fopen(file, "r")) != NULL) {
 			cal_home = home;
-			cal_dir = calendarhome;
+			cal_dir = calendarHomes[i];
 			cal_file = file;
 			return (fp);
 		}
 	}
 
 	warnx("can't open calendar file \"%s\"", file);
-	if (!warned) {
-		snprintf(path, sizeof(path), _PATH_INCLUDE_LOCAL, getlocalbase());
-		if (stat(path, &sb) != 0) {
-			warnx("calendar data files now provided by calendar-data pkg.");
-			warned = true;
-		}
-	}
 
 	return (NULL);
 }
--- src.orig/miscutils/calendar/locale.c
+++ src.freebsd/miscutils/calendar/locale.c
@@ -35,7 +35,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <time.h>
+#include <time_bsd.h>
 
 #include "calendar.h"
 
@@ -79,7 +79,7 @@
 	memset(&tm, 0, sizeof(struct tm));
 	for (i = 0; i < 7; i++) {
 		tm.tm_wday = i;
-		strftime(buf, sizeof(buf), "%a", &tm);
+		strftime_bsd(buf, sizeof(buf), "%a", &tm);
 		for (l = strlen(buf);
 		     l > 0 && isspace((unsigned char)buf[l - 1]);
 		     l--)
@@ -91,7 +91,7 @@
 			errx(1, "cannot allocate memory");
 		ndays[i].len = strlen(buf);
 
-		strftime(buf, sizeof(buf), "%A", &tm);
+		strftime_bsd(buf, sizeof(buf), "%A", &tm);
 		for (l = strlen(buf);
 		     l > 0 && isspace((unsigned char)buf[l - 1]);
 		     l--)
@@ -107,7 +107,7 @@
 	memset(&tm, 0, sizeof(struct tm));
 	for (i = 0; i < 12; i++) {
 		tm.tm_mon = i;
-		strftime(buf, sizeof(buf), "%b", &tm);
+		strftime_bsd(buf, sizeof(buf), "%b", &tm);
 		for (l = strlen(buf);
 		     l > 0 && isspace((unsigned char)buf[l - 1]);
 		     l--)
@@ -119,7 +119,7 @@
 			errx(1, "cannot allocate memory");
 		nmonths[i].len = strlen(buf);
 
-		strftime(buf, sizeof(buf), "%B", &tm);
+		strftime_bsd(buf, sizeof(buf), "%B", &tm);
 		for (l = strlen(buf);
 		     l > 0 && isspace((unsigned char)buf[l - 1]);
 		     l--)
--- src.orig/miscutils/calendar/pathnames.h
+++ src.freebsd/miscutils/calendar/pathnames.h
@@ -34,4 +34,4 @@
 #include <paths.h>
 
 #define	_PATH_INCLUDE	"/usr/share/calendar"
-#define	_PATH_INCLUDE_LOCAL	"%s/share/calendar"
+#define	_PATH_INCLUDE_LOCAL	"/usr/local/share/calendar"
--- src.orig/miscutils/col/col.c
+++ src.freebsd/miscutils/col/col.c
@@ -50,6 +50,7 @@
 #include <capsicum_helpers.h>
 #include <err.h>
 #include <errno.h>
+#include <limits.h>
 #include <locale.h>
 #include <stdio.h>
 #include <stdlib.h>
--- src.orig/miscutils/hexdump/conv.c
+++ src.freebsd/miscutils/hexdump/conv.c
@@ -102,7 +102,7 @@
 	if (odmode && MB_CUR_MAX > 1) {
 		oclen = 0;
 retry:
-		clen = mbrtowc(&wc, p, bufsize, &pr->mbstate);
+		clen = mbrtowc(&wc, (const char *)p, bufsize, &pr->mbstate);
 		if (clen == 0)
 			clen = 1;
 		else if (clen == (size_t)-1 || (clen == (size_t)-2 &&
--- src.orig/miscutils/hexdump/display.c
+++ src.freebsd/miscutils/hexdump/display.c
@@ -37,9 +37,9 @@
 #include <sys/cdefs.h>
 #include <sys/param.h>
 #include <sys/capsicum.h>
-#include <sys/conf.h>
 #include <sys/ioctl.h>
 #include <sys/stat.h>
+#include <sys/types.h>
 
 #include <capsicum_helpers.h>
 #include <ctype.h>
@@ -105,7 +105,7 @@
 		for (pr = endfu->nextpr; pr; pr = pr->nextpr)
 			switch(pr->flags) {
 			case F_ADDRESS:
-				(void)printf(pr->fmt, (quad_t)eaddress);
+				(void)printf(pr->fmt, (long long)eaddress);
 				break;
 			case F_TEXT:
 				(void)printf("%s", pr->fmt);
@@ -129,7 +129,7 @@
 
 	switch(pr->flags) {
 	case F_ADDRESS:
-		(void)printf(pr->fmt, (quad_t)address);
+		(void)printf(pr->fmt, (long long)address);
 		break;
 	case F_BPAD:
 		(void)printf(pr->fmt, "");
@@ -162,15 +162,15 @@
 	case F_INT:
 		switch(pr->bcnt) {
 		case 1:
-			(void)printf(pr->fmt, (quad_t)(signed char)*bp);
+			(void)printf(pr->fmt, (long long)(signed char)*bp);
 			break;
 		case 2:
 			bcopy(bp, &s2, sizeof(s2));
-			(void)printf(pr->fmt, (quad_t)s2);
+			(void)printf(pr->fmt, (long long)s2);
 			break;
 		case 4:
 			bcopy(bp, &s4, sizeof(s4));
-			(void)printf(pr->fmt, (quad_t)s4);
+			(void)printf(pr->fmt, (long long)s4);
 			break;
 		case 8:
 			bcopy(bp, &s8, sizeof(s8));
@@ -193,15 +193,15 @@
 	case F_UINT:
 		switch(pr->bcnt) {
 		case 1:
-			(void)printf(pr->fmt, (u_quad_t)*bp);
+			(void)printf(pr->fmt, (unsigned long long)*bp);
 			break;
 		case 2:
 			bcopy(bp, &u2, sizeof(u2));
-			(void)printf(pr->fmt, (u_quad_t)u2);
+			(void)printf(pr->fmt, (unsigned long long)u2);
 			break;
 		case 4:
 			bcopy(bp, &u4, sizeof(u4));
-			(void)printf(pr->fmt, (u_quad_t)u4);
+			(void)printf(pr->fmt, (unsigned long long)u4);
 			break;
 		case 8:
 			bcopy(bp, &u8, sizeof(u8));
@@ -391,7 +391,6 @@
 void
 doskip(const char *fname, int statok)
 {
-	int type;
 	struct stat sb;
 
 	if (statok) {
@@ -408,16 +407,8 @@
 		return;
 	}
 	if (S_ISCHR(sb.st_mode) || S_ISBLK(sb.st_mode)) {
-		if (ioctl(fileno(stdin), FIODTYPE, &type))
-			err(1, "%s", fname);
-		/*
-		 * Most tape drives don't support seeking,
-		 * yet fseek() would succeed.
-		 */
-		if (type & D_TAPE) {
-			noseek();
-			return;
-		}
+		noseek();
+		return;
 	}
 	if (fseeko(stdin, skip, SEEK_SET)) {
 		noseek();
--- src.orig/miscutils/hexdump/parse.c
+++ src.freebsd/miscutils/hexdump/parse.c
@@ -50,7 +50,7 @@
 void
 addfile(const char *name)
 {
-	unsigned char *p;
+	char *p;
 	FILE *fp;
 	int ch;
 	char buf[2048 + 1];
@@ -75,7 +75,7 @@
 void
 add(const char *fmt)
 {
-	unsigned const char *p, *savep;
+	const char *p, *savep;
 	static FS **nextfs;
 	FS *tfs;
 	FU *tfu, **nextfu;
@@ -151,7 +151,7 @@
 {
 	FU *fu;
 	int bcnt, cursize;
-	unsigned char *fmt;
+	char *fmt;
 	int prec;
 
 	/* figure out the data block size needed for each format unit */
@@ -208,8 +208,8 @@
 	enum { NOTOKAY, USEBCNT, USEPREC } sokay;
 	PR *pr, **nextpr;
 	FU *fu;
-	unsigned char *p1, *p2, *fmtp;
-	char savech, cs[3];
+	char *p1, *p2, *fmtp;
+	char savech, cs[4];
 	int nconv, prec;
 
 	prec = 0;
@@ -288,9 +288,10 @@
 				goto isint;
 			case 'o': case 'u': case 'x': case 'X':
 				pr->flags = F_UINT;
-isint:				cs[2] = '\0';
-				cs[1] = cs[0];
-				cs[0] = 'q';
+isint:				cs[3] = '\0';
+				cs[2] = cs[0];
+				cs[1] = 'l';
+				cs[0] = 'l';
 				switch(fu->bcnt) {
 				case 0: case 4:
 					pr->bcnt = 4;
@@ -335,6 +336,7 @@
 				switch(sokay) {
 				case NOTOKAY:
 					badsfmt();
+					return;
 				case USEBCNT:
 					pr->bcnt = fu->bcnt;
 					break;
@@ -355,9 +357,10 @@
 					++p2;
 					switch(p1[2]) {
 					case 'd': case 'o': case'x':
-						cs[0] = 'q';
-						cs[1] = p1[2];
-						cs[2] = '\0';
+						cs[0] = 'l';
+						cs[1] = 'l';
+						cs[2] = p1[2];
+						cs[3] = '\0';
 						break;
 					default:
 						p1[3] = '\0';
--- src.orig/miscutils/kill/kill.c
+++ src.freebsd/miscutils/kill/kill.c
@@ -60,7 +60,6 @@
 
 static void nosig(const char *);
 static void printsignals(FILE *);
-static int signame_to_signum(const char *);
 static void usage(void) __dead2;
 
 int
@@ -70,6 +69,7 @@
 	pid_t pid;
 	int errors, numsig, ret;
 	char *ep;
+	const char *sign;
 
 	if (argc < 2)
 		usage();
@@ -89,9 +89,13 @@
 				errx(2, "illegal signal number: %s", *argv);
 			if (numsig >= 128)
 				numsig -= 128;
-			if (numsig <= 0 || numsig >= sys_nsig)
+			if (numsig <= 0 || numsig >= NSIG)
 				nosig(*argv);
-			printf("%s\n", sys_signame[numsig]);
+			sign = signum_to_signame(numsig);
+			if (!sign)
+				printf("%d\n", numsig);
+			else
+				printf("%s\n", sign);
 			return (0);
 		}
 		printsignals(stdout);
@@ -155,20 +159,6 @@
 	return (errors);
 }
 
-static int
-signame_to_signum(const char *sig)
-{
-	int n;
-
-	if (strncasecmp(sig, "SIG", 3) == 0)
-		sig += 3;
-	for (n = 1; n < sys_nsig; n++) {
-		if (!strcasecmp(sys_signame[n], sig))
-			return (n);
-	}
-	return (-1);
-}
-
 static void
 nosig(const char *name)
 {
@@ -187,13 +177,13 @@
 {
 	int n;
 
-	for (n = 1; n < sys_nsig; n++) {
-		(void)fprintf(fp, "%s", sys_signame[n]);
-		if (n == (sys_nsig / 2) || n == (sys_nsig - 1))
-			(void)fprintf(fp, "\n");
-		else
-			(void)fprintf(fp, " ");
+	for (n = 1; n <= NSIG; n++) {
+		const char *sign = signum_to_signame(n);
+		if (!sign) break;
+		if (n > 1) fprintf(fp, " ");
+		fprintf(fp, "%s", sign);
 	}
+	fprintf(fp, "\n");
 }
 
 static void
--- src.orig/miscutils/logger/logger.c
+++ src.freebsd/miscutils/logger/logger.c
@@ -347,8 +347,22 @@
 			errx(1, "address family mismatch");
 			
 		if (ss_src[res->ai_family]) {
+			socklen_t alen;
+			switch (res->ai_family) {
+			case AF_INET:
+				alen = sizeof(struct sockaddr_in);
+				break;
+#ifdef INET6
+			case AF_INET6:
+				alen = sizeof(struct sockaddr_in6);
+				break;
+#endif
+			default:
+				/* should be unreachable */
+				errx(1, "invalid address family");
+			}
 			error = bind(s, sstosa(ss_src[res->ai_family]),
-				    ss_src[res->ai_family]->ss_len);
+				    alen);
 			if (error < 0)
 				err(1, "bind");
 		}
--- src.orig/miscutils/look/look.c
+++ src.freebsd/miscutils/look/look.c
@@ -80,12 +80,12 @@
 
 static int dflag, fflag;
 
-static char	*binary_search(wchar_t *, unsigned char *, unsigned char *);
-static int	 compare(wchar_t *, unsigned char *, unsigned char *);
-static char	*linear_search(wchar_t *, unsigned char *, unsigned char *);
-static int	 look(wchar_t *, unsigned char *, unsigned char *);
+static char	*binary_search(wchar_t *, char *, char *);
+static int	 compare(wchar_t *, char *, char *);
+static char	*linear_search(wchar_t *, char *, char *);
+static int	 look(wchar_t *, char *, char *);
 static wchar_t	*prepkey(const char *, wchar_t);
-static void	 print_from(wchar_t *, unsigned char *, unsigned char *);
+static void	 print_from(wchar_t *, char *, char *);
 
 static void usage(void) __dead2;
 
@@ -103,8 +103,8 @@
 	struct stat sb;
 	int ch, fd, match;
 	wchar_t termchar;
-	unsigned char *back, *front;
-	unsigned const char *file;
+	char *back, *front;
+	const char *file;
 	wchar_t *key;
 
 	(void) setlocale(LC_CTYPE, "");
@@ -147,7 +147,7 @@
 	do {
 		if ((fd = open(file, O_RDONLY, 0)) < 0 || fstat(fd, &sb))
 			err(2, "%s", file);
-		if ((uintmax_t)sb.st_size > (uintmax_t)SIZE_T_MAX)
+		if ((uintmax_t)sb.st_size > (uintmax_t)SIZE_MAX)
 			errx(2, "%s: %s", file, strerror(EFBIG));
 		if (sb.st_size == 0) {
 			close(fd);
@@ -195,7 +195,7 @@
 }
 
 static int
-look(wchar_t *string, unsigned char *front, unsigned char *back)
+look(wchar_t *string, char *front, char *back)
 {
 
 	front = binary_search(string, front, back);
@@ -249,9 +249,9 @@
 	while (p < back && *p++ != '\n');
 
 static char *
-binary_search(wchar_t *string, unsigned char *front, unsigned char *back)
+binary_search(wchar_t *string, char *front, char *back)
 {
-	unsigned char *p;
+	char *p;
 
 	p = front + (back - front) / 2;
 	SKIP_PAST_NEWLINE(p, back);
@@ -283,7 +283,7 @@
  *	o front is before or at the first line to be printed.
  */
 static char *
-linear_search(wchar_t *string, unsigned char *front, unsigned char *back)
+linear_search(wchar_t *string, char *front, char *back)
 {
 	while (front < back) {
 		switch (compare(string, front, back)) {
@@ -303,7 +303,7 @@
  * Print as many lines as match string, starting at front.
  */
 static void
-print_from(wchar_t *string, unsigned char *front, unsigned char *back)
+print_from(wchar_t *string, char *front, char *back)
 {
 	for (; front < back && compare(string, front, back) == EQUAL; ++front) {
 		for (; front < back && *front != '\n'; ++front)
@@ -328,7 +328,7 @@
  * "back" terminated).
  */
 static int
-compare(wchar_t *s1, unsigned char *s2, unsigned char *back)
+compare(wchar_t *s1, char *s2, char *back)
 {
 	wchar_t ch1, ch2;
 	size_t len2;
--- src.orig/miscutils/ncal/ncal.c
+++ src.freebsd/miscutils/ncal/ncal.c
@@ -38,7 +38,7 @@
 #include <string.h>
 #include <stdbool.h>
 #include <sysexits.h>
-#include <time.h>
+#include <time_bsd.h>
 #include <unistd.h>
 #include <wchar.h>
 #include <wctype.h>
@@ -551,8 +551,11 @@
 	char    buf[MAX_WIDTH];
 	static int d_first = -1;
 
-	if (d_first < 0)
-		d_first = (*nl_langinfo(D_MD_ORDER) == 'd');
+	if (d_first < 0) {
+		d_first = 0;
+		if (strlen(nl_langinfo(D_FMT)) >= 2 && nl_langinfo(D_FMT)[1] == 'd')
+			d_first = 1;
+	}
 	/* force orthodox easter for years before 1583 */
 	if (y < 1583)
 		orthodox = 1;
@@ -569,7 +572,7 @@
 	tm.tm_year = dt.y - 1900;
 	tm.tm_mon  = dt.m - 1;
 	tm.tm_mday = dt.d;
-	strftime(buf, sizeof(buf), d_first ? "%e %B %Y" : "%B %e %Y",  &tm);
+	strftime_bsd(buf, sizeof(buf), d_first ? "%e %B %Y" : "%B %e %Y",  &tm);
 	printf("%s\n", buf);
 }
 
@@ -634,12 +637,12 @@
 
 		/* Empty line between two rows of months */
 		if (m != m1)
-			printf("\n");
+			wprintf(L"\n");
 
 		/* Year at the top. */
 		if (printyearheader && M2Y(m) != prevyear) {
 			sprintf(s, "%d", M2Y(m));
-			printf("%s\n", center(t, s, mpl * mw));
+			wprintf(L"%s\n", center(t, s, mpl * mw));
 			prevyear = M2Y(m);
 		}
 
@@ -653,7 +656,7 @@
 				    L"%-ls %d", year[i].name, M2Y(m + i));
 				wprintf(L"%-*ls  ", mw, wcenter(ws1, ws, mw));
 			}
-		printf("\n");
+		wprintf(L"\n");
 
 		/* Day of the week names. */
 		for (i = 0; i < count; i++) {
@@ -666,15 +669,15 @@
 				wdss, wds.names[flag_monday ? 5 : 4],
 				wdss, wds.names[flag_monday ? 6 : 5]);
 		}
-		printf("\n");
+		wprintf(L"\n");
 
 		/* And the days of the month. */
 		for (i = 0; i != 6; i++) {
 			for (j = 0; j < count; j++)
-				printf("%-*s  ",
+				wprintf(L"%-*s  ",
 				    MW(mw, year[j].extralen[i]),
 					year[j].lines[i]+1);
-			printf("\n");
+			wprintf(L"\n");
 		}
 
 		m += mpl;
@@ -724,12 +727,12 @@
 
 		/* Empty line between two rows of months. */
 		if (m != m1)
-			printf("\n");
+			wprintf(L"\n");
 
 		/* Year at the top. */
 		if (printyearheader && M2Y(m) != prevyear) {
 			sprintf(s, "%d", M2Y(m));
-			printf("%s\n", center(t, s, mpl * mw));
+			wprintf(L"%s\n", center(t, s, mpl * mw));
 			prevyear = M2Y(m);
 		}
 
@@ -741,7 +744,7 @@
 			else
 				wprintf(L"%-ls %-*d", year[i].name,
 				    mw - wcslen(year[i].name) - 1, M2Y(m + i));
-		printf("\n");
+		wprintf(L"\n");
 
 		/* And the days of the month. */
 		for (i = 0; i != 7; i++) {
@@ -750,18 +753,18 @@
 
 			/* Full months */
 			for (j = 0; j < count; j++)
-				printf("%-*s",
+				wprintf(L"%-*s",
 				    MW(mw, year[j].extralen[i]),
 					year[j].lines[i]);
-			printf("\n");
+			wprintf(L"\n");
 		}
 
 		/* Week numbers. */
 		if (flag_weeks) {
-			printf("  ");
+			wprintf(L"  ");
 			for (i = 0; i < count; i++)
-				printf("%-*s", mw, year[i].weeks);
-			printf("\n");
+				wprintf(L"%-*s", mw, year[i].weeks);
+			wprintf(L"\n");
 		}
 
 		m += mpl;
@@ -1067,9 +1070,12 @@
 center(char *s, char *t, int w)
 {
 	char blanks[MAX_WIDTH];
+	int nblank;
 
 	memset(blanks, ' ', sizeof(blanks));
-	sprintf(s, "%.*s%s", (int)(w - strlen(t)) / 2, blanks, t);
+	nblank = (int)(w - strlen(t)) / 2;
+	memcpy(s, blanks, nblank);
+	sprintf(s + nblank, "%s", t);
 	return (s);
 }
 
@@ -1110,7 +1116,7 @@
 		*y = ny;
 		return (0);
 	}
-	if (strptime(s, "%B", &tm) != NULL || strptime(s, "%b", &tm) != NULL) {
+	if (strptime_bsd(s, "%B", &tm) != NULL || strptime_bsd(s, "%b", &tm) != NULL) {
 		*m = tm.tm_mon + 1;
 		return (0);
 	}
--- src.orig/miscutils/rev/rev.c
+++ src.freebsd/miscutils/rev/rev.c
@@ -55,6 +55,46 @@
 
 static void usage(void) __dead2;
 
+#define BUF_PIECE 1024
+
+static wchar_t *get_wln(FILE *f, size_t *len, wchar_t **sbuf, size_t *blen) {
+	wchar_t *wptr;
+	size_t wlen;
+
+	wptr = fgetws(*sbuf, *blen, f);
+	if (wptr) {
+		wlen = wcslen(wptr);
+		if (wptr[wlen - 1] == '\n' || feof(f)) {
+			*len = wlen;
+			return wptr;
+		}
+	} else {
+		return NULL;
+	}
+
+	for (;;) {
+		wchar_t *nptr;
+		*blen = wlen + BUF_PIECE;
+		*sbuf = realloc(*sbuf, *blen * sizeof(wchar_t));
+		if (!*sbuf) err(1, "realloc");
+
+		nptr = fgetws(*sbuf + wlen, BUF_PIECE, f);
+		if (!nptr) {
+			if (feof(f))
+				break;
+			return NULL;
+		}
+
+		wlen += wcslen(nptr);
+		if ((*sbuf)[wlen - 1] == '\n' || feof(f)) {
+			break;
+		}
+	}
+
+	*len = wlen;
+	return *sbuf;
+}
+
 int
 main(int argc, char *argv[])
 {
@@ -63,7 +103,11 @@
 	FILE *fp;
 	size_t len;
 	int ch, rval;
+	size_t bufl = BUF_PIECE;
+	wchar_t *buf = malloc(bufl * sizeof(wchar_t));
 
+	if (!buf) err(1, "malloc");
+
 	setlocale(LC_ALL, "");
 
 	while ((ch = getopt(argc, argv, "")) != -1)
@@ -89,7 +133,7 @@
 			}
 			filename = *argv++;
 		}
-		while ((p = fgetwln(fp, &len)) != NULL) {
+		while ((p = get_wln(fp, &len, &buf, &bufl)) != NULL) {
 			if (p[len - 1] == '\n')
 				--len;
 			for (t = p + len - 1; t >= p; --t)
@@ -103,6 +147,7 @@
 		}
 		(void)fclose(fp);
 	} while(*argv);
+	free(buf);
 	exit(rval);
 }
 
--- src.orig/miscutils/script/script.1
+++ src.freebsd/miscutils/script/script.1
@@ -92,13 +92,6 @@
 .Xr mkfifo 1
 and another user may watch the live session using a utility like
 .Xr cat 1 .
-.It Fl f
-Create
-.Ar file.filemon
-or
-.Pa typescript.filemon
-using
-.Xr filemon 4 .
 .It Fl k
 Log keys sent to the program as well as output.
 .It Fl p
@@ -258,8 +251,7 @@
 for the
 .Em history
 mechanism
-.Pc ,
-.Xr filemon 4
+.Pc
 .Sh HISTORY
 The
 .Nm
--- src.orig/miscutils/script/script.c
+++ src.freebsd/miscutils/script/script.c
@@ -30,7 +30,7 @@
  * SUCH DAMAGE.
  */
 
-#include <sys/param.h>
+#include <sys/cdefs.h>
 #ifndef lint
 static const char copyright[] =
 "@(#) Copyright (c) 1980, 1992, 1993\n\
@@ -40,14 +40,13 @@
 static const char sccsid[] = "@(#)script.c	8.1 (Berkeley) 6/6/93";
 #endif
 
+#include <sys/param.h>
 #include <sys/wait.h>
 #include <sys/stat.h>
 #include <sys/ioctl.h>
 #include <sys/time.h>
 #include <sys/queue.h>
 #include <sys/uio.h>
-#include <sys/endian.h>
-#include <dev/filemon/filemon.h>
 
 #include <assert.h>
 #include <err.h>
@@ -61,6 +60,10 @@
 #include <string.h>
 #include <termios.h>
 #include <unistd.h>
+#include <time_bsd.h>
+#include <pty.h>
+#include <utmp.h>
+#include <byteswap.h>
 
 #define DEF_BUF 65536
 
@@ -83,7 +86,7 @@
 static int child;
 static const char *fname;
 static char *fmfname;
-static int fflg, qflg, ttyflg;
+static int qflg, ttyflg;
 static int usesleep, rawout, showexit;
 static TAILQ_HEAD(, buf_elm) obuf_list = TAILQ_HEAD_INITIALIZER(obuf_list);
 static volatile sig_atomic_t doresize;
@@ -121,14 +124,12 @@
 	ssize_t cc;
 	int aflg, Fflg, kflg, pflg, wflg, ch, k, n, fcm;
 	int flushtime, readstdin;
-	int fm_fd, fm_log;
 
 	aflg = Fflg = kflg = pflg = wflg = 0;
 	doresize = 0;
 	usesleep = 1;
 	rawout = 0;
 	flushtime = 30;
-	fm_fd = -1;
 	showexit = 0;
 
 	/*
@@ -140,7 +141,7 @@
 	sigemptyset(&selmask);
 	pselmask = NULL;
 
-	while ((ch = getopt(argc, argv, "adeFfkpqrT:t:w")) != -1)
+	while ((ch = getopt(argc, argv, "adeFkpqrT:t:w")) != -1)
 		switch (ch) {
 		case 'a':
 			aflg = 1;
@@ -154,9 +155,6 @@
 		case 'F':
 			Fflg = 1;
 			break;
-		case 'f':
-			fflg = 1;
-			break;
 		case 'k':
 			kflg = 1;
 			break;
@@ -199,20 +197,6 @@
 	if ((fscript = fopen(fname, pflg ? "r" : aflg ? "a" : "w")) == NULL)
 		err(1, "%s", fname);
 
-	if (fflg) {
-		asprintf(&fmfname, "%s.filemon", fname);
-		if (!fmfname)
-			err(1, "%s.filemon", fname);
-		if ((fm_fd = open("/dev/filemon", O_RDWR | O_CLOEXEC)) == -1)
-			err(1, "open(\"/dev/filemon\", O_RDWR)");
-		if ((fm_log = open(fmfname,
-		    O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC,
-		    S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
-			err(1, "open(%s)", fmfname);
-		if (ioctl(fm_fd, FILEMON_SET_FD, &fm_log) < 0)
-			err(1, "Cannot set filemon log file descriptor");
-	}
-
 	if (pflg)
 		playback(fscript);
 
@@ -253,10 +237,6 @@
 			}
 		}
 		fflush(fscript);
-		if (fflg) {
-			(void)printf("Filemon started, output file is %s\n",
-			    fmfname);
-		}
 	}
 	if (ttyflg) {
 		rtt = tt;
@@ -265,22 +245,12 @@
 		(void)tcsetattr(STDIN_FILENO, TCSAFLUSH, &rtt);
 	}
 
-	assert(fflg ? fm_fd >= 0 : fm_fd < 0);
-
 	child = fork();
 	if (child < 0) {
 		warn("fork");
 		done(1);
 	}
 	if (child == 0) {
-		if (fflg) {
-			int pid;
-
-			pid = getpid();
-			if (ioctl(fm_fd, FILEMON_SET_PID, &pid) < 0)
-				err(1, "Cannot set filemon PID");
-		}
-
 		doshell(argv);
 	}
 	close(slave);
@@ -408,7 +378,7 @@
 usage(void)
 {
 	(void)fprintf(stderr,
-	    "usage: script [-aeFfkpqrw] [-t time] [file [command ...]]\n");
+	    "usage: script [-aeFkpqrw] [-t time] [file [command ...]]\n");
 	(void)fprintf(stderr,
 	    "       script -p [-deq] [-T fmt] [file]\n");
 	exit(1);
@@ -473,10 +443,6 @@
 			    ctime(&tvec));
 		}
 		(void)printf("\nScript done, output file is %s\n", fname);
-		if (fflg) {
-			(void)printf("Filemon done, output file is %s\n",
-			    fmfname);
-		}
 	}
 	(void)fclose(fscript);
 	(void)close(master);
@@ -523,10 +489,10 @@
 
 #define swapstamp(stamp) do { \
 	if (stamp.scr_direction > 0xff) { \
-		stamp.scr_len = bswap64(stamp.scr_len); \
-		stamp.scr_sec = bswap64(stamp.scr_sec); \
-		stamp.scr_usec = bswap32(stamp.scr_usec); \
-		stamp.scr_direction = bswap32(stamp.scr_direction); \
+		stamp.scr_len = bswap_64(stamp.scr_len); \
+		stamp.scr_sec = bswap_64(stamp.scr_sec); \
+		stamp.scr_usec = bswap_32(stamp.scr_usec); \
+		stamp.scr_direction = bswap_32(stamp.scr_direction); \
 	} \
 } while (0/*CONSTCOND*/)
 
@@ -622,7 +588,7 @@
 				if (stamp.scr_len == 0)
 					continue;
 				if (tclock - lclock > 0) {
-				    l = strftime(buf, sizeof buf, tstamp_fmt,
+				    l = strftime_bsd(buf, sizeof buf, tstamp_fmt,
 					localtime(&tclock));
 				    (void)write(STDOUT_FILENO, buf, l);
 				}
--- src.orig/miscutils/time/time.1
+++ src.freebsd/miscutils/time/time.1
@@ -35,7 +35,7 @@
 .Nd time command execution
 .Sh SYNOPSIS
 .Nm
-.Op Fl al
+.Op Fl a
 .Op Fl h | Fl p
 .Op Fl o Ar file
 .Ar utility Op Ar argument ...
@@ -69,10 +69,6 @@
 Print times in a human friendly format.
 Times are printed in minutes, hours,
 etc.\& as appropriate.
-.It Fl l
-The contents of the
-.Em rusage
-structure are printed as well.
 .It Fl o Ar file
 Write the output to
 .Ar file
@@ -98,7 +94,7 @@
 If
 .Nm
 receives a
-.Dv SIGINFO
+.Dv SIGUSR1
 (see the status argument for
 .Xr stty 1 )
 signal, the current time the given command is running will be written to the
@@ -161,33 +157,15 @@
 Time the
 .Xr sleep 1
 command and show the results in a human friendly format.
-Show the contents of the
-.Em rusage
-structure too:
 .Bd -literal -offset indent
-$ /usr/bin/time -l -h -p sleep 5
+$ /usr/bin/time -h -p sleep 5
 real 5.01
 user 0.00
 sys 0.00
-         0  maximum resident set size
-         0  average shared memory size
-         0  average unshared data size
-         0  average unshared stack size
-        80  page reclaims
-         0  page faults
-         0  swaps
-         1  block input operations
-         0  block output operations
-         0  messages sent
-         0  messages received
-         0  signals received
-         3  voluntary context switches
-         0  involuntary context switches
 .Ed
 .Sh SEE ALSO
 .Xr builtin 1 ,
 .Xr csh 1 ,
-.Xr getrusage 2 ,
 .Xr wait 2
 .Sh STANDARDS
 The
--- src.orig/miscutils/time/time.c
+++ src.freebsd/miscutils/time/time.c
@@ -41,10 +41,9 @@
 #endif
 #endif /* not lint */
 
+#include <sys/cdefs.h>
 #include <sys/types.h>
 #include <sys/resource.h>
-#include <sys/signal.h>
-#include <sys/sysctl.h>
 #include <sys/time.h>
 #include <sys/wait.h>
 
@@ -59,7 +58,6 @@
 #include <time.h>
 #include <unistd.h>
 
-static int getstathz(void);
 static void humantime(FILE *, long, long);
 static void showtime(FILE *, struct timespec *, struct timespec *,
     struct rusage *);
@@ -74,20 +72,21 @@
 int
 main(int argc, char **argv)
 {
-	int aflag, ch, lflag, status;
+	int aflag, ch, status;
 	int exitonsig;
 	pid_t pid;
 	struct rlimit rl;
 	struct rusage ru;
 	struct timespec after;
+	struct sigaction sa = { .sa_handler = siginfo, .sa_flags = 0 };
 	char *ofn = NULL;
 	FILE *out = stderr;
 
 	(void) setlocale(LC_NUMERIC, "");
 	decimal_point = localeconv()->decimal_point[0];
 
-	aflag = hflag = lflag = pflag = 0;
-	while ((ch = getopt(argc, argv, "ahlo:p")) != -1)
+	aflag = hflag = pflag = 0;
+	while ((ch = getopt(argc, argv, "aho:p")) != -1)
 		switch((char)ch) {
 		case 'a':
 			aflag = 1;
@@ -95,9 +94,6 @@
 		case 'h':
 			hflag = 1;
 			break;
-		case 'l':
-			lflag = 1;
-			break;
 		case 'o':
 			ofn = optarg;
 			break;
@@ -134,8 +130,8 @@
 	(void)signal(SIGINT, SIG_IGN);
 	(void)signal(SIGQUIT, SIG_IGN);
 	siginfo_recvd = 0;
-	(void)signal(SIGINFO, siginfo);
-	(void)siginterrupt(SIGINFO, 1);
+	sa.sa_handler = siginfo;
+	(void)sigaction(SIGINFO, &sa, NULL);
 	while (wait4(pid, &status, 0, &ru) != pid) {
 		if (siginfo_recvd) {
 			siginfo_recvd = 0;
@@ -151,6 +147,7 @@
 		warnx("command terminated abnormally");
 	exitonsig = WIFSIGNALED(status) ? WTERMSIG(status) : 0;
 	showtime(out, &before_ts, &after, &ru);
+#if 0
 	if (lflag) {
 		int hz = getstathz();
 		u_long ticks;
@@ -194,6 +191,7 @@
 		fprintf(out, "%10ld  %s\n",
 			ru.ru_nivcsw, "involuntary context switches");
 	}
+#endif
 	/*
 	 * If the child has exited on a signal, exit on the same
 	 * signal, too, in order to reproduce the child's exit status.
@@ -220,6 +218,7 @@
 	exit(1);
 }
 
+#if 0
 /*
  * Return the frequency of the kernel's statistics clock.
  */
@@ -237,6 +236,7 @@
 		err(1, "sysctl kern.clockrate");
 	return clockrate.stathz;
 }
+#endif
 
 static void
 humantime(FILE *out, long sec, long centisec)
--- src.orig/miscutils/ul/ul.c
+++ src.freebsd/miscutils/ul/ul.c
@@ -41,6 +41,7 @@
 #endif
 #endif /* not lint */
 
+#include <sys/cdefs.h>
 #include <err.h>
 #include <locale.h>
 #include <stdio.h>
--- src.orig/miscutils/wall/ttymsg.c
+++ src.freebsd/miscutils/wall/ttymsg.c
@@ -34,6 +34,7 @@
 static const char sccsid[] = "@(#)ttymsg.c	8.2 (Berkeley) 11/16/93";
 #endif
 
+#include <sys/param.h>
 #include <sys/types.h>
 #include <sys/uio.h>
 #include <dirent.h>
@@ -65,6 +66,7 @@
 	static char errbuf[1024];
 	char *p;
 	int forked;
+	sigset_t set;
 
 	forked = 0;
 	if (iovcnt > (int)(sizeof(localiov) / sizeof(localiov[0])))
@@ -140,7 +142,8 @@
 			/* wait at most tmout seconds */
 			(void) signal(SIGALRM, SIG_DFL);
 			(void) signal(SIGTERM, SIG_DFL); /* XXX */
-			(void) sigsetmask(0);
+			sigemptyset(&set);
+			sigprocmask(SIG_SETMASK, &set, 0);
 			(void) alarm((u_int)tmout);
 			(void) fcntl(fd, F_SETFL, 0);	/* clear O_NONBLOCK */
 			continue;
--- src.orig/miscutils/wall/wall.c
+++ src.freebsd/miscutils/wall/wall.c
@@ -45,7 +45,9 @@
  * is entitled "Mechanisms for Broadcast and Selective Broadcast".
  */
 
+#include <sys/cdefs.h>
 #include <sys/param.h>
+#include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/uio.h>
 
@@ -159,7 +161,7 @@
 					ingroup = 1;
 				else if ((grp = getgrgid(g->gid)) != NULL) {
 					for (np = grp->gr_mem; *np; np++) {
-						if (strcmp(*np, utmp->ut_user) == 0) {
+						if (strncmp(*np, utmp->ut_user, sizeof(utmp->ut_user)) == 0) {
 							ingroup = 1;
 							break;
 						}
--- src.orig/miscutils/whereis/pathnames.h
+++ src.freebsd/miscutils/whereis/pathnames.h
@@ -25,10 +25,13 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include "config-compat.h"
+
 /* Where to look for libexec */
-#define PATH_LIBEXEC "/usr/libexec"
+#define PATH_LIBEXEC LIBEXECDIR
 
 /* Where to look for sources. */
+#if 0
 #define PATH_SOURCES					\
 "/usr/src/bin:/usr/src/usr.bin:/usr/src/sbin:"		\
 "/usr/src/usr.sbin:/usr/src/libexec:"			\
@@ -39,12 +42,15 @@
 "/usr/src/secure/sbin:/usr/src/secure/usr.sbin:"	\
 "/usr/src/secure/libexec:/usr/src/crypto:"		\
 "/usr/src/games"
+#else
+#define PATH_SOURCES "/usr/src"
+#endif
 
 /* Each subdirectory of PATH_PORTS will be appended to PATH_SOURCES. */
 #define PATH_PORTS "/usr/ports"
 
 /* How to query the current manpath. */
-#define MANPATHCMD "manpath -q"
+#define MANPATHCMD "command -v man > /dev/null && man -w || :"
 
 /* How to obtain the location of manpages, and how to match this result. */
 #define MANWHEREISCMD "man -S1:8:6 -w %s 2>/dev/null"
--- src.orig/miscutils/whereis/whereis.1
+++ src.freebsd/miscutils/whereis/whereis.1
@@ -58,22 +58,15 @@
 .Ql ,v
 from a source code control system.
 .Pp
-The default path searched is the string returned by the
-.Xr sysctl 8
-utility for the
-.Dq user.cs_path
-string, with
-.Pa /usr/libexec
-and the current user's
+The default path searched is the standard utilities path, with
+the configured libexec directory and the current user's
 .Ev $PATH
 appended.
 Manual pages are searched by default along the
 .Ev $MANPATH .
 Program sources are located in a list of known standard places,
 including all the subdirectories of
-.Pa /usr/src
-and
-.Pa /usr/ports .
+.Pa /usr/src .
 .Pp
 The following options are available:
 .Bl -tag -width indent
@@ -151,8 +144,7 @@
 .Xr find 1 ,
 .Xr locate 1 ,
 .Xr man 1 ,
-.Xr which 1 ,
-.Xr sysctl 8
+.Xr which 1
 .Sh HISTORY
 The
 .Nm
--- src.orig/miscutils/whereis/whereis.c
+++ src.freebsd/miscutils/whereis/whereis.c
@@ -32,9 +32,9 @@
  * was pretty inferior in functionality.
  */
 
+#include <sys/cdefs.h>
 #include <sys/types.h>
 #include <sys/stat.h>
-#include <sys/sysctl.h>
 
 #include <dirent.h>
 #include <err.h>
@@ -46,6 +46,7 @@
 #include <string.h>
 #include <sysexits.h>
 #include <unistd.h>
+#include <paths.h>
 
 #include "pathnames.h"
 
@@ -251,14 +252,14 @@
 static void
 defaults(void)
 {
-	size_t s;
 	char *b, buf[BUFSIZ], *cp;
 	int nele;
 	FILE *p;
+#if 0
 	DIR *dir;
 	struct stat sb;
 	struct dirent *dirp;
-	const int oid[2] = {CTL_USER, USER_CS_PATH};
+#endif
 
 	/* default to -bms if none has been specified */
 	if (!opt_b && !opt_m && !opt_s)
@@ -267,12 +268,8 @@
 	/* -b defaults to default path + /usr/libexec +
 	 * user's path */
 	if (!bindirs) {
-		if (sysctl(oid, 2, NULL, &s, NULL, 0) == -1)
-			err(EX_OSERR, "sysctl(\"user.cs_path\")");
-		if ((b = malloc(s + 1)) == NULL)
+		if ((b = strdup(_PATH_STDPATH)) == NULL)
 			abort();
-		if (sysctl(oid, 2, b, &s, NULL, 0) == -1)
-			err(EX_OSERR, "sysctl(\"user.cs_path\")");
 		nele = 0;
 		decolonify(b, &bindirs, &nele);
 		bindirs = realloc(bindirs, (nele + 2) * sizeof(char *));
@@ -293,7 +290,7 @@
 	if (!mandirs) {
 		if ((p = popen(MANPATHCMD, "r")) == NULL)
 			err(EX_OSERR, "cannot execute manpath command");
-		if (fgets(buf, BUFSIZ - 1, p) == NULL ||
+		if ((fgets(buf, BUFSIZ - 1, p) == NULL && !feof(p)) ||
 		    pclose(p))
 			err(EX_OSERR, "error processing manpath results");
 		if ((b = strchr(buf, '\n')) != NULL)
@@ -312,7 +309,7 @@
 			abort();
 		nele = 0;
 		decolonify(b, &sourcedirs, &nele);
-
+#if 0
 		if (stat(PATH_PORTS, &sb) == -1) {
 			if (errno == ENOENT)
 				/* no /usr/ports, we are done */
@@ -350,7 +347,7 @@
 			    (dirp->d_name[0] >= 'A' && dirp->d_name[0] <= 'Z') ||
 			    strcmp(dirp->d_name, "distfiles") == 0)
 				continue;
-			if ((b = malloc(sizeof PATH_PORTS + 1 + dirp->d_namlen))
+			if ((b = malloc(sizeof PATH_PORTS + 1 + strlen(dirp->d_name)))
 			    == NULL)
 				abort();
 			strcpy(b, PATH_PORTS);
@@ -370,6 +367,7 @@
 			sourcedirs[nele] = NULL;
 		}
 		closedir(dir);
+#endif
 	}
 }
 
--- src.orig/miscutils/write/write.c
+++ src.freebsd/miscutils/write/write.c
@@ -47,8 +47,6 @@
 #include <sys/cdefs.h>
 #include <sys/param.h>
 #include <sys/capsicum.h>
-#include <sys/filio.h>
-#include <sys/signal.h>
 #include <sys/stat.h>
 #include <sys/time.h>
 
@@ -56,13 +54,16 @@
 #include <ctype.h>
 #include <err.h>
 #include <errno.h>
+#include <fcntl.h>
 #include <locale.h>
 #include <paths.h>
 #include <pwd.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <signal.h>
 #include <unistd.h>
+#include <time.h>
 #include <utmpx.h>
 #include <wchar.h>
 #include <wctype.h>
@@ -78,7 +79,7 @@
 int
 main(int argc, char **argv)
 {
-	unsigned long cmds[] = { TIOCGETA, TIOCGWINSZ, FIODGNAME };
+	unsigned long cmds[] = { 0 };
 	cap_rights_t rights;
 	struct passwd *pwd;
 	time_t atime;
@@ -201,10 +202,11 @@
 {
 	struct utmpx lu, *u;
 
-	strncpy(lu.ut_line, tty, sizeof lu.ut_line);
+	strncpy(lu.ut_line, tty, sizeof lu.ut_line - 1);
+	lu.ut_line[sizeof lu.ut_line - 1] = '\0';
 	while ((u = getutxline(&lu)) != NULL)
 		if (u->ut_type == USER_PROCESS &&
-		    strcmp(user, u->ut_user) == 0) {
+		    strncmp(user, u->ut_user, sizeof(u->ut_user)) == 0) {
 			endutxent();
 			return(0);
 		}
@@ -236,13 +238,13 @@
 
 	while ((u = getutxent()) != NULL)
 		if (u->ut_type == USER_PROCESS &&
-		    strcmp(user, u->ut_user) == 0) {
+		    strncmp(user, u->ut_user, sizeof(u->ut_user)) == 0) {
 			++nloggedttys;
 			if (term_chk(devfd, u->ut_line, &msgsok, &atime, 0))
 				continue;	/* bad term? skip */
 			if (myuid && !msgsok)
 				continue;	/* skip ttys with msgs off */
-			if (strcmp(u->ut_line, mytty) == 0) {
+			if (strncmp(u->ut_line, mytty, sizeof(u->ut_line)) == 0) {
 				user_is_me = 1;
 				continue;	/* don't write to yourself */
 			}
@@ -301,10 +303,9 @@
 	fd = openat(devfd, tty, O_WRONLY);
 	if (fd < 0)
 		err(1, "openat(%s%s)", _PATH_DEV, tty);
-	fclose(stdout);
-	stdout = fdopen(fd, "w");
-	if (stdout == NULL)
+	if (dup2(fd, STDOUT_FILENO) < 0)
 		err(1, "%s%s", _PATH_DEV, tty);
+	close(fd);
 
 	(void)signal(SIGINT, done);
 	(void)signal(SIGHUP, done);
--- src.orig/netcat/nc.1
+++ src.freebsd/netcat/nc.1
@@ -36,11 +36,9 @@
 .Sh SYNOPSIS
 .Nm nc
 .Bk -words
-.Op Fl 46DdEFhklMNnrStUuvz
-.Op Fl e Ar IPsec_policy
+.Op Fl 46DdFhklNnrStUuvz
 .Op Fl I Ar length
 .Op Fl i Ar interval
-.Op Fl -no-tcpopt
 .Op Fl -sctp
 .Op Fl O Ar length
 .Op Fl P Ar proxy_username
@@ -48,7 +46,6 @@
 .Op Fl s Ar source
 .Op Fl T Ar toskeyword
 .Op Fl -tun Ar tundev
-.Op Fl V Ar rtable
 .Op Fl w Ar timeout
 .Op Fl X Ar proxy_protocol
 .Oo Xo
@@ -108,20 +105,6 @@
 Enable debugging on the socket.
 .It Fl d
 Do not attempt to read from stdin.
-.It Fl E
-Shortcut for
-.Qo
-.Li "-e 'in ipsec esp/transport//require'"
-.Li "-e 'out ipsec esp/transport//require'" 
-.Qc ,
-which enables IPsec ESP transport mode in both
-directions.
-.It Fl e
-If IPsec support is available, then one can specify the IPsec policies
-to be used using the syntax described in
-.Xr ipsec_set_policy 3 .
-This flag can be specified up to two times, as typically one policy for
-each direction is needed.
 .It Fl F
 Pass the first connected socket using
 .Xr sendmsg 2
@@ -172,12 +155,6 @@
 Additionally, any timeouts specified with the
 .Fl w
 option are ignored.
-.It Fl M
-Collect per-connection TCP statistics using the
-.Xr stats 3
-framework and print them in JSON format to
-.Xr stderr 4
-after the connection is closed.
 .It Fl N
 .Xr shutdown 2
 the network socket after EOF on the input.
@@ -185,10 +162,6 @@
 .It Fl n
 Do not do any DNS or service lookups on any specified addresses,
 hostnames or ports.
-.It Fl -no-tcpopt
-Disables the use of TCP options on the socket, by setting the boolean
-TCP_NOOPT
-socket option.
 .It Fl -sctp
 Use SCTP instead of the default option of TCP.
 .It Fl O Ar length
@@ -263,10 +236,6 @@
 unless the
 .Fl s
 flag is given.
-.It Fl V Ar rtable
-Set the routing table
-.Pq Dq FIB
-to be used.
 .It Fl v
 Have
 .Nm
@@ -478,16 +447,6 @@
 .Pp
 .Dl $ nc -s 10.1.2.3 host.example.com 42
 .Pp
-Open a TCP connection to port 42 of host.example.com using IPsec ESP for
-incoming and outgoing traffic.
-.Pp
-.Dl $ nc -E host.example.com 42
-.Pp
-Open a TCP connection to port 42 of host.example.com using IPsec ESP for
-outgoing traffic only.
-.Pp
-.Dl $ nc -e 'out ipsec esp/transport//require' host.example.com 42
-.Pp
 Create and listen on a
 .Ux Ns -domain
 stream socket:
@@ -515,7 +474,6 @@
 .Ex -std
 .Sh SEE ALSO
 .Xr cat 1 ,
-.Xr setfib 1 ,
 .Xr ssh 1 ,
 .Xr tcp 4
 .Sh AUTHORS
--- src.orig/netcat/netcat.c
+++ src.freebsd/netcat/netcat.c
@@ -35,17 +35,12 @@
 
 #include <errno.h>
 #include <stdio.h>
-#include <sys/arb.h>
-#include <sys/limits.h>
 #include <sys/types.h>
-#include <sys/sbuf.h>
 #include <sys/socket.h>
-#include <sys/sysctl.h>
-#include <sys/qmath.h>
-#include <sys/stats.h>
 #include <sys/time.h>
 #include <sys/uio.h>
 #include <sys/un.h>
+#include <sys/random.h>
 
 #include <netinet/in.h>
 #ifdef IPSEC
@@ -68,6 +63,45 @@
 #include <unistd.h>
 #include "atomicio.h"
 
+#ifndef IPTOS_LOWDELAY
+# define IPTOS_LOWDELAY 0x10
+# define IPTOS_THROUGHPUT 0x08
+# define IPTOS_RELIABILITY 0x04
+# define IPTOS_LOWCOST 0x02
+# define IPTOS_MINCOST IPTOS_LOWCOST
+#endif /* IPTOS_LOWDELAY */
+
+# ifndef IPTOS_DSCP_AF11
+# define	IPTOS_DSCP_AF11		0x28
+# define	IPTOS_DSCP_AF12		0x30
+# define	IPTOS_DSCP_AF13		0x38
+# define	IPTOS_DSCP_AF21		0x48
+# define	IPTOS_DSCP_AF22		0x50
+# define	IPTOS_DSCP_AF23		0x58
+# define	IPTOS_DSCP_AF31		0x68
+# define	IPTOS_DSCP_AF32		0x70
+# define	IPTOS_DSCP_AF33		0x78
+# define	IPTOS_DSCP_AF41		0x88
+# define	IPTOS_DSCP_AF42		0x90
+# define	IPTOS_DSCP_AF43		0x98
+# define	IPTOS_DSCP_EF		0xb8
+#endif /* IPTOS_DSCP_AF11 */
+
+#ifndef IPTOS_DSCP_CS0
+# define	IPTOS_DSCP_CS0		0x00
+# define	IPTOS_DSCP_CS1		0x20
+# define	IPTOS_DSCP_CS2		0x40
+# define	IPTOS_DSCP_CS3		0x60
+# define	IPTOS_DSCP_CS4		0x80
+# define	IPTOS_DSCP_CS5		0xa0
+# define	IPTOS_DSCP_CS6		0xc0
+# define	IPTOS_DSCP_CS7		0xe0
+#endif /* IPTOS_DSCP_CS0 */
+
+#ifndef IPTOS_DSCP_EF
+# define	IPTOS_DSCP_EF		0xb8
+#endif /* IPTOS_DSCP_EF */
+
 #ifndef SUN_LEN
 #define SUN_LEN(su) \
 	(sizeof(*(su)) - sizeof((su)->sun_path) + strlen((su)->sun_path))
@@ -89,10 +123,8 @@
 unsigned int iflag;				/* Interval Flag */
 int	kflag;					/* More than one connect */
 int	lflag;					/* Bind to local port */
-int	FreeBSD_Mflag;				/* Measure using stats(3) */
 int	Nflag;					/* shutdown() network socket */
 int	nflag;					/* Don't do name look up */
-int	FreeBSD_Oflag;				/* Do not use TCP options */
 int	FreeBSD_sctp;				/* Use SCTP */
 char   *Pflag;					/* Proxy username */
 char   *pflag;					/* Localport flag */
@@ -108,7 +140,6 @@
 int	Oflag;					/* TCP send buffer size */
 int	Sflag;					/* TCP MD5 signature option */
 int	Tflag = -1;				/* IP Type of Service */
-int	rtableid = -1;
 
 int timeout = -1;
 int family = AF_UNSPEC;
@@ -130,8 +161,6 @@
 int	unix_bind(char *);
 int	unix_connect(char *);
 int	unix_listen(char *);
-void	FreeBSD_stats_setup(int);
-void	FreeBSD_stats_print(int);
 void	set_common_sockopts(int, int);
 int	map_tos(char *, int *);
 void	report_connect(const struct sockaddr *, socklen_t);
@@ -152,9 +181,7 @@
 int
 main(int argc, char *argv[])
 {
-	int ch, s, ret, socksv, ipsec_count;
-	int numfibs;
-	size_t intsize = sizeof(int);
+	int ch, s, ret, socksv;
 	char *host, *uport;
 	struct addrinfo hints;
 	struct servent *sv;
@@ -165,14 +192,12 @@
 	struct addrinfo proxyhints;
 	char unix_dg_tmp_socket_buf[UNIX_DG_TMP_SOCKET_SIZE];
 	struct option longopts[] = {
-		{ "no-tcpopt",	no_argument,	&FreeBSD_Oflag,	1 },
 		{ "sctp",	no_argument,	&FreeBSD_sctp,	1 },
 		{ "tun",	required_argument,	NULL,	FREEBSD_TUN },
 		{ NULL,		0,		NULL,		0 }
 	};
 
 	ret = 1;
-	ipsec_count = 0;
 	s = 0;
 	socksv = 5;
 	host = NULL;
@@ -182,7 +207,7 @@
 	signal(SIGPIPE, SIG_IGN);
 
 	while ((ch = getopt_long(argc, argv,
-	    "46DdEe:FhI:i:klMNnoO:P:p:rSs:tT:UuV:vw:X:x:z",
+	    "46DdFhI:i:klNnoO:P:p:rSs:tT:Uuvw:X:x:z",
 	    longopts, NULL)) != -1) {
 		switch (ch) {
 		case '4':
@@ -239,13 +264,6 @@
 		case 'l':
 			lflag = 1;
 			break;
-		case 'M':
-#ifndef WITH_STATS
-			errx(1, "-M requires stats(3) support");
-#else
-			FreeBSD_Mflag = 1;
-#endif
-			break;
 		case 'N':
 			Nflag = 1;
 			break;
@@ -273,14 +291,6 @@
 		case 'u':
 			uflag = 1;
 			break;
-		case 'V':
-			if (sysctlbyname("net.fibs", &numfibs, &intsize, NULL, 0) == -1)
-				errx(1, "Multiple FIBS not supported");
-			rtableid = (int)strtonum(optarg, 0,
-			    numfibs - 1, &errstr);
-			if (errstr)
-				errx(1, "rtable %s: %s", errstr, optarg);
-			break;
 		case 'v':
 			vflag = 1;
 			break;
@@ -495,9 +505,6 @@
 				}
 				if (vflag)
 					report_connect((struct sockaddr *)&cliaddr, len);
-
-				if (FreeBSD_Mflag)
-					FreeBSD_stats_setup(connfd);
 				readwrite(connfd);
 				close(connfd);
 			}
@@ -681,7 +688,7 @@
 remote_connect(const char *host, const char *port, struct addrinfo hints)
 {
 	struct addrinfo *res, *res0;
-	int s, error, on = 1;
+	int s, error;
 
 	if ((error = getaddrinfo(host, port, &hints, &res)))
 		errx(1, "getaddrinfo: %s", gai_strerror(error));
@@ -692,16 +699,10 @@
 		    res0->ai_protocol)) < 0)
 			continue;
 
-		if (rtableid >= 0 && (setsockopt(s, SOL_SOCKET, SO_SETFIB,
-		    &rtableid, sizeof(rtableid)) == -1))
-			err(1, "setsockopt SO_SETFIB");
-
 		/* Bind to a local port or source address if specified. */
 		if (sflag || pflag) {
 			struct addrinfo ahints, *ares;
 
-			/* try IP_BINDANY, but don't insist */
-			setsockopt(s, IPPROTO_IP, IP_BINDANY, &on, sizeof(on));
 			memset(&ahints, 0, sizeof(struct addrinfo));
 			ahints.ai_family = res0->ai_family;
 			ahints.ai_socktype = uflag ? SOCK_DGRAM : SOCK_STREAM;
@@ -738,7 +739,7 @@
 {
 	struct pollfd pfd;
 	socklen_t optlen;
-	int flags, optval;
+	int flags = 0, optval;
 	int ret;
 
 	if (timeout != -1) {
@@ -801,20 +802,10 @@
 		    res0->ai_protocol)) < 0)
 			continue;
 
-		if (rtableid >= 0 && (setsockopt(s, SOL_SOCKET, SO_SETFIB,
-		    &rtableid, sizeof(rtableid)) == -1))
-			err(1, "setsockopt SO_SETFIB");
-
 		ret = setsockopt(s, SOL_SOCKET, SO_REUSEPORT, &x, sizeof(x));
 		if (ret == -1)
 			err(1, NULL);
 
-		if (FreeBSD_Oflag) {
-			if (setsockopt(s, IPPROTO_TCP, TCP_NOOPT,
-			    &FreeBSD_Oflag, sizeof(FreeBSD_Oflag)) == -1)
-				err(1, "disable TCP options");
-		}
-
 		set_common_sockopts(s, res0->ai_family);
 
 		if (bind(s, (struct sockaddr *)res0->ai_addr,
@@ -850,7 +841,6 @@
 	unsigned char stdinbuf[BUFSIZE];
 	size_t stdinbufpos = 0;
 	int n, num_fds;
-	int stats_printed = 0;
 	ssize_t ret;
 
 	/* don't read from stdin if requested */
@@ -877,23 +867,17 @@
 		/* both inputs are gone, buffers are empty, we are done */
 		if (pfd[POLL_STDIN].fd == -1 && pfd[POLL_NETIN].fd == -1
 		    && stdinbufpos == 0 && netinbufpos == 0) {
-			if (FreeBSD_Mflag && !stats_printed)
-				FreeBSD_stats_print(net_fd);
 			close(net_fd);
 			return;
 		}
 		/* both outputs are gone, we can't continue */
 		if (pfd[POLL_NETOUT].fd == -1 && pfd[POLL_STDOUT].fd == -1) {
-			if (FreeBSD_Mflag && !stats_printed)
-				FreeBSD_stats_print(net_fd);
 			close(net_fd);
 			return;
 		}
 		/* listen and net in gone, queues empty, done */
 		if (lflag && pfd[POLL_NETIN].fd == -1
 		    && stdinbufpos == 0 && netinbufpos == 0) {
-			if (FreeBSD_Mflag && !stats_printed)
-				FreeBSD_stats_print(net_fd);
 			close(net_fd);
 			return;
 		}
@@ -915,8 +899,6 @@
 
 		/* timeout happened */
 		if (num_fds == 0) {
-			if (FreeBSD_Mflag)
-				FreeBSD_stats_print(net_fd);
 			return;
 		}
 
@@ -1021,10 +1003,6 @@
 		/* stdin gone and queue empty? */
 		if (pfd[POLL_STDIN].fd == -1 && stdinbufpos == 0) {
 			if (pfd[POLL_NETOUT].fd != -1 && Nflag) {
-				if (FreeBSD_Mflag) {
-					FreeBSD_stats_print(net_fd);
-					stats_printed = 1;
-				}
 				shutdown(pfd[POLL_NETOUT].fd, SHUT_WR);
 			}
 			pfd[POLL_NETOUT].fd = -1;
@@ -1209,7 +1187,9 @@
 			char *c;
 
 			for (x = 0; x <= (hi - lo); x++) {
-				y = (arc4random() & 0xFFFF) % (hi - lo);
+				if (getrandom(&y, sizeof(y), 0) < 0)
+					err(1, "getrandom");
+				y = (y & 0xFFFF) % (hi - lo);
 				c = portlist[x];
 				portlist[x] = portlist[y];
 				portlist[y] = c;
@@ -1243,7 +1223,7 @@
 	}
 	return (ret);
 }
-
+#if 0
 void
 FreeBSD_stats_setup(int s)
 {
@@ -1304,7 +1284,7 @@
 	fprintf(stderr, "%s\n", sbuf_data(sb));
 #endif
 }
-
+#endif
 void
 set_common_sockopts(int s, int af)
 {
@@ -1344,13 +1324,6 @@
 		    &Oflag, sizeof(Oflag)) == -1)
 			err(1, "set TCP send buffer size");
 	}
-	if (FreeBSD_Oflag) {
-		if (setsockopt(s, IPPROTO_TCP, TCP_NOOPT,
-		    &FreeBSD_Oflag, sizeof(FreeBSD_Oflag)) == -1)
-			err(1, "disable TCP options");
-	}
-	if (FreeBSD_Mflag)
-		FreeBSD_stats_setup(s);
 #ifdef IPSEC
 	if (ipsec_policy[0] != NULL)
 		add_ipsec_policy(s, af, ipsec_policy[0]);
--- src.orig/netcat/socks.c
+++ src.freebsd/netcat/socks.c
@@ -38,7 +38,7 @@
 #include <string.h>
 #include <unistd.h>
 #include <resolv.h>
-#include <readpassphrase.h>
+#include <libutil.h>
 #include "atomicio.h"
 
 #define SOCKS_PORT	"1080"
@@ -113,11 +113,12 @@
 getproxypass(const char *proxyuser, const char *proxyhost)
 {
 	char prompt[512];
-	static char pw[256];
+	const char *pw;
 
 	snprintf(prompt, sizeof(prompt), "Proxy password for %s@%s: ",
 	   proxyuser, proxyhost);
-	if (readpassphrase(prompt, pw, sizeof(pw), RPP_REQUIRE_TTY) == NULL)
+	/* deprecated but CBA to write a replacement at the moment */
+	if ((pw = getpass(prompt)) == NULL)
 		errx(1, "Unable to read proxy passphrase");
 	return (pw);
 }
@@ -272,38 +273,38 @@
 
 		/* Try to be sane about numeric IPv6 addresses */
 		if (strchr(host, ':') != NULL) {
-			r = snprintf(buf, sizeof(buf),
+			r = snprintf((char *)buf, sizeof(buf),
 			    "CONNECT [%s]:%d HTTP/1.0\r\n",
 			    host, ntohs(serverport));
 		} else {
-			r = snprintf(buf, sizeof(buf),
+			r = snprintf((char *)buf, sizeof(buf),
 			    "CONNECT %s:%d HTTP/1.0\r\n",
 			    host, ntohs(serverport));
 		}
 		if (r == -1 || (size_t)r >= sizeof(buf))
 			errx(1, "hostname too long");
-		r = strlen(buf);
+		r = strlen((char *)buf);
 
 		cnt = atomicio(vwrite, proxyfd, buf, r);
-		if (cnt != r)
+		if (cnt != (size_t)r)
 			err(1, "write failed (%zu/%d)", cnt, r);
 
 		if (authretry > 1) {
 			char resp[1024];
 
 			proxypass = getproxypass(proxyuser, proxyhost);
-			r = snprintf(buf, sizeof(buf), "%s:%s",
+			r = snprintf((char *)buf, sizeof(buf), "%s:%s",
 			    proxyuser, proxypass);
 			if (r == -1 || (size_t)r >= sizeof(buf) ||
-			    b64_ntop(buf, strlen(buf), resp,
+			    compat_b64_ntop(buf, strlen((char *)buf), resp,
 			    sizeof(resp)) == -1)
 				errx(1, "Proxy username/password too long");
-			r = snprintf(buf, sizeof(buf), "Proxy-Authorization: "
+			r = snprintf((char *)buf, sizeof(buf), "Proxy-Authorization: "
 			    "Basic %s\r\n", resp);
 			if (r == -1 || (size_t)r >= sizeof(buf))
 				errx(1, "Proxy auth response too long");
-			r = strlen(buf);
-			if ((cnt = atomicio(vwrite, proxyfd, buf, r)) != r)
+			r = strlen((char *)buf);
+			if ((cnt = atomicio(vwrite, proxyfd, buf, r)) != (size_t)r)
 				err(1, "write failed (%zu/%d)", cnt, r);
 		}
 
@@ -312,22 +313,22 @@
 			err(1, "write failed (%zu/2)", cnt);
 
 		/* Read status reply */
-		proxy_read_line(proxyfd, buf, sizeof(buf));
+		proxy_read_line(proxyfd, (char *)buf, sizeof(buf));
 		if (proxyuser != NULL &&
-		    strncmp(buf, "HTTP/1.0 407 ", 12) == 0) {
+		    strncmp((char *)buf, "HTTP/1.0 407 ", 12) == 0) {
 			if (authretry > 1) {
 				fprintf(stderr, "Proxy authentication "
 				    "failed\n");
 			}
 			close(proxyfd);
 			goto again;
-		} else if (strncmp(buf, "HTTP/1.0 200 ", 12) != 0 &&
-		    strncmp(buf, "HTTP/1.1 200 ", 12) != 0)
+		} else if (strncmp((char *)buf, "HTTP/1.0 200 ", 12) != 0 &&
+		    strncmp((char *)buf, "HTTP/1.1 200 ", 12) != 0)
 			errx(1, "Proxy error: \"%s\"", buf);
 
 		/* Headers continue until we hit an empty line */
 		for (r = 0; r < HTTP_MAXHDRS; r++) {
-			proxy_read_line(proxyfd, buf, sizeof(buf));
+			proxy_read_line(proxyfd, (char *)buf, sizeof(buf));
 			if (*buf == '\0')
 				break;
 		}
--- src.orig/nvi/cl/cl_funcs.c
+++ src.freebsd/nvi/cl/cl_funcs.c
@@ -146,7 +146,7 @@
 			if (clp->smcup != NULL)
 				(void)tputs(clp->smcup, 1, cl_putchar);
 		}
-	} else
+	} else {
 		if (clp->ti_te != TE_SENT) {
 			clp->ti_te = TE_SENT;
 			if (clp->rmcup == NULL)
@@ -154,6 +154,7 @@
 			if (clp->rmcup != NULL)
 				(void)tputs(clp->rmcup, 1, cl_putchar);
 			(void)fflush(stdout);
+		}
 		}
 		(void)fflush(stdout);
 		break;
--- src.orig/nvi/common/exf.c
+++ src.freebsd/nvi/common/exf.c
@@ -178,7 +178,7 @@
 			msgq(sp, M_SYSERR, NULL);
 			goto err;
 		}
-		if ((fd = mkstemp(tname)) == -1 || fstat(fd, &sb)) {
+		if ((fd = compat_mkstemp(tname)) == -1 || fstat(fd, &sb)) {
 			free(tname);
 			msgq(sp, M_SYSERR,
 			    "237|Unable to create temporary file");
--- src.orig/nvi/common/log.c
+++ src.freebsd/nvi/common/log.c
@@ -22,6 +22,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <stddef.h>
 
 #include "common.h"
 
@@ -81,7 +82,7 @@
 	char    data[sizeof(u_char) /* type */ + sizeof(recno_t)];
 	CHAR_T  str[1];
 } log_t;
-#define CHAR_T_OFFSET ((char *)(((log_t*)0)->str) - (char *)0)
+#define CHAR_T_OFFSET offsetof(log_t, str)
 
 /*
  * log_init --
@@ -520,6 +521,7 @@
 				sp->rptlchange = lno;
 				++sp->rptlines[L_CHANGED];
 			}
+			/* FALLTHROUGH */
 		case LOG_MARK:
 			memmove(&lm, p + sizeof(u_char), sizeof(LMARK));
 			m.lno = lm.lno;
--- src.orig/nvi/common/main.c
+++ src.freebsd/nvi/common/main.c
@@ -27,7 +27,6 @@
 #include "../vi/vi.h"
 #include "pathnames.h"
 
-static void	 attach(GS *);
 static int	 v_obsolete(char *[]);
 
 /*
--- src.orig/nvi/common/options.c
+++ src.freebsd/nvi/common/options.c
@@ -315,15 +315,24 @@
 	argv[1] = &b;
 
 	/* Set numeric and string default values. */
-#define	OI(indx, str) do {						\
-	a.len = STRLEN(str);						\
-	if ((CHAR_T*)str != b2)	  /* GCC puts strings in text-space. */	\
-		(void)MEMCPY(b2, str, a.len+1);				\
+#define	OI_BASE(indx) do {						\
 	if (opts_set(sp, argv, NULL)) {					\
 		 optindx = indx;					\
 		goto err;						\
 	}								\
 } while (0)
+
+#define OI(indx, str) do { \
+	a.len = STRLEN(str); \
+	MEMCPY(b2, str, a.len + 1); \
+	OI_BASE(indx); \
+} while(0)
+
+#define OIB(indx) do { \
+	a.len = STRLEN(b2); \
+	OI_BASE(indx); \
+} while(0)
+
 	/*
 	 * Indirect global options to global space.  Specifically, set up
 	 * terminal, lines, columns first, they're used by other options.
@@ -345,7 +354,7 @@
 	/* Initialize string values. */
 	(void)SPRINTF(b2, SIZE(b2),
 	    L("cdpath=%s"), (s = getenv("CDPATH")) == NULL ? ":" : s);
-	OI(O_CDPATH, b2);
+	OIB(O_CDPATH);
 	OI(O_CEDIT, L("cedit=\033"));
 
 	/*
@@ -357,30 +366,30 @@
 	 */
 	(void)SPRINTF(b2, SIZE(b2),
 	    L("directory=%s"), (s = getenv("TMPDIR")) == NULL ? _PATH_TMP : s);
-	OI(O_TMPDIR, b2);
+	OIB(O_TMPDIR);
 	OI(O_ESCAPETIME, L("escapetime=6"));
 	OI(O_FILEC, L("filec=\t"));
 	OI(O_KEYTIME, L("keytime=6"));
 	OI(O_MATCHCHARS, L("matchchars=()[]{}"));
 	OI(O_MATCHTIME, L("matchtime=7"));
 	(void)SPRINTF(b2, SIZE(b2), L("msgcat=%s"), _PATH_MSGCAT);
-	OI(O_MSGCAT, b2);
+	OIB(O_MSGCAT);
 	OI(O_REPORT, L("report=5"));
 	OI(O_PARAGRAPHS, L("paragraphs=IPLPPPQPP LIpplpipbp"));
 	(void)SPRINTF(b2, SIZE(b2), L("path=%s"), "");
-	OI(O_PATH, b2);
+	OIB(O_PATH);
 	(void)SPRINTF(b2, SIZE(b2), L("recdir=%s"), NVI_PATH_PRESERVE);
-	OI(O_RECDIR, b2);
+	OIB(O_RECDIR);
 	OI(O_SECTIONS, L("sections=NHSHH HUnhsh"));
 	(void)SPRINTF(b2, SIZE(b2),
 	    L("shell=%s"), (s = getenv("SHELL")) == NULL ? _PATH_BSHELL : s);
-	OI(O_SHELL, b2);
+	OIB(O_SHELL);
 	OI(O_SHELLMETA, L("shellmeta=~{[*?$`'\"\\"));
 	OI(O_SHIFTWIDTH, L("shiftwidth=8"));
 	OI(O_SIDESCROLL, L("sidescroll=16"));
 	OI(O_TABSTOP, L("tabstop=8"));
 	(void)SPRINTF(b2, SIZE(b2), L("tags=%s"), _PATH_TAGS);
-	OI(O_TAGS, b2);
+	OIB(O_TAGS);
 
 	/*
 	 * XXX
@@ -390,7 +399,7 @@
 	if ((v = (O_VAL(sp, O_LINES) - 1) / 2) == 0)
 		v = 1;
 	(void)SPRINTF(b2, SIZE(b2), L("scroll=%ld"), v);
-	OI(O_SCROLL, b2);
+	OIB(O_SCROLL);
 
 	/*
 	 * The default window option values are:
@@ -411,7 +420,7 @@
 		v = 1;
 
 	(void)SPRINTF(b2, SIZE(b2), L("window=%lu"), v);
-	OI(O_WINDOW, b2);
+	OIB(O_WINDOW);
 
 	/*
 	 * Set boolean default values, and copy all settings into the default
--- src.orig/nvi/common/recover.c
+++ src.freebsd/nvi/common/recover.c
@@ -33,6 +33,7 @@
 #include <string.h>
 #include <time.h>
 #include <unistd.h>
+#include <libutil.h>
 
 #include "../ex/version.h"
 #include "common.h"
@@ -811,7 +812,7 @@
 {
 	int fd;
 
-	if ((fd = mkstemp(path)) == -1)
+	if ((fd = compat_mkstemp(path)) == -1)
 		msgq_str(sp, M_SYSERR, dname, "%s");
 	return (fd);
 }
@@ -851,7 +852,7 @@
 	GET_SPACE_GOTOC(sp, bp, blen, (len + 2) / 3 * 4 + dlen + 2);
 	(void)memcpy(bp, dtype, dlen);
 	bp[dlen] = ';';
-	if ((xlen = b64_ntop((u_char *)src,
+	if ((xlen = compat_b64_ntop((u_char *)src,
 	    len, bp + dlen + 1, blen)) == -1)
 		goto err;
 	xlen += dlen + 1;
@@ -930,7 +931,7 @@
 	MALLOC(sp, data, dlen + len / 4 * 3 + 2);
 	if (data == NULL)
 		goto err;
-	if ((xlen = (b64_pton(p + dlen + 1,
+	if ((xlen = (compat_b64_pton(p + dlen + 1,
 	    (u_char *)data, len / 4 * 3 + 1))) == -1) {
 		free(data);
 		goto err;
--- src.orig/nvi/ex/ex_cscope.c
+++ src.freebsd/nvi/ex/ex_cscope.c
@@ -326,7 +326,7 @@
 		len = sb.st_size;
 		MALLOC_RET(sp, csc->pbuf, len + 1);
 		if ((fd = open(buf, O_RDONLY, 0)) < 0 ||
-		    read(fd, csc->pbuf, len) != len) {
+		    read(fd, csc->pbuf, len) != (ssize_t)len) {
 			 msgq_str(sp, M_SYSERR, buf, "%s");
 			 if (fd >= 0)
 				(void)close(fd);
--- src.orig/nvi/ex/ex_map.c
+++ src.freebsd/nvi/ex/ex_map.c
@@ -90,6 +90,8 @@
 			    "134|The %s character may not be remapped",
 			    KEY_NAME(sp, input[0]));
 			return (1);
+		default:
+			break;
 		}
 	return (seq_set(sp, NULL, 0, input, cmdp->argv[0]->len,
 	    cmdp->argv[1]->bp, cmdp->argv[1]->len, stype, SEQ_USERDEF));
--- src.orig/nvi/files/config.h.in
+++ src.freebsd/nvi/files/config.h.in
@@ -1,26 +1,26 @@
 /* Define when using wide characters */
-#cmakedefine USE_WIDECHAR
+#mesondefine USE_WIDECHAR
 
 /* Define when iconv can be used */
-#cmakedefine USE_ICONV
+#mesondefine USE_ICONV
 
 /* Define when the 2nd argument of iconv(3) is not const */
-#cmakedefine ICONV_TRADITIONAL
+#mesondefine ICONV_TRADITIONAL
 
 /* Define if you have <libutil.h> */
-#cmakedefine HAVE_LIBUTIL_H
+#mesondefine HAVE_LIBUTIL_H
 
 /* Define if you have <ncurses.h> */
-#cmakedefine HAVE_NCURSES_H
+#mesondefine HAVE_NCURSES_H
 
 /* Define if you have <ncursesw/ncurses.h> */
-#cmakedefine HAVE_NCURSESW_NCURSES_H
+#mesondefine HAVE_NCURSESW_NCURSES_H
 
 /* Define if you have <pty.h> */
-#cmakedefine HAVE_PTY_H
+#mesondefine HAVE_PTY_H
 
 /* Define if you have <term.h> */
-#cmakedefine HAVE_TERM_H
+#mesondefine HAVE_TERM_H
 
 /* Define if struct dirent has field d_namlen */
-#cmakedefine HAVE_DIRENT_D_NAMLEN
+#mesondefine HAVE_DIRENT_D_NAMLEN
--- src.orig/nvi/gen_ex_version_h.sh
+++ src.freebsd/nvi/gen_ex_version_h.sh
@@ -0,0 +1,2 @@
+#!/bin/sh
+exec sed -n 's/^.*version \([^)]*)\).*/\#define VI_VERSION "\1"/p' "$@"
--- src.orig/nvi/gen_extern_h.sh
+++ src.freebsd/nvi/gen_extern_h.sh
@@ -0,0 +1,39 @@
+#!/bin/sh
+
+do_sed() {
+    sed -n 's/^ \* PUBLIC: \(.*\)/\1/p' "$@"
+}
+
+try_sed() {
+    case "$1" in
+        */$2/*)
+            do_sed "$1"
+            return 0
+            ;;
+    esac
+    return 1
+}
+
+echo "#ifdef CL_IN_EX"
+
+while try_sed "$1" cl; do
+    shift
+done
+
+echo "#endif"
+echo "#ifdef EXP"
+
+while try_sed "$1" ex; do
+    shift
+done
+
+echo "#endif"
+echo "#ifdef V_ABS"
+
+while try_sed "$1" vi; do
+    shift
+done
+
+echo "#endif"
+
+do_sed "$@"
--- src.orig/nvi/vi/v_paragraph.c
+++ src.freebsd/nvi/vi/v_paragraph.c
@@ -47,7 +47,7 @@
 		continue;						\
 	for (lp = VIP(sp)->ps; *lp != '\0'; lp += 2)			\
 		if (lp[0] == p[1] &&					\
-		    (lp[1] == ' ' && len == 2 || lp[1] == p[2])) {	\
+		    ((lp[1] == ' ' && len == 2) || lp[1] == p[2])) {	\
 			if (!--cnt)					\
 				goto found;				\
 			if (pstate == P_INTEXT && !--cnt)		\
--- src.orig/nvi/vi/vs_refresh.c
+++ src.freebsd/nvi/vi/vs_refresh.c
@@ -575,7 +575,7 @@
 	 *
 	 * Walk through the map and find the current line.
 	 */
-slow:	for (smp = HMAP; smp->lno != LNO; ++smp);
+slow:	for (smp = HMAP; smp->lno != LNO; ++smp) {}
 
 	/*
 	 * 7e: Leftright scrolling adjustment.
--- src.orig/patch/backupfile.c
+++ src.freebsd/patch/backupfile.c
@@ -104,7 +104,7 @@
 	file_name_length = strlen(file);
 
 	while ((dp = readdir(dirp)) != NULL) {
-		if (dp->d_namlen <= file_name_length)
+		if (strlen(dp->d_name) <= file_name_length)
 			continue;
 
 		this_version = version_number(file, dp->d_name, file_name_length);
--- src.orig/patch/inp.c
+++ src.freebsd/patch/inp.c
@@ -34,6 +34,7 @@
 
 #include <ctype.h>
 #include <errno.h>
+#include <fcntl.h>
 #include <libgen.h>
 #include <paths.h>
 #include <spawn.h>
@@ -283,8 +284,9 @@
 plan_b(const char *filename)
 {
 	FILE	*ifp;
-	size_t	i, j, len, maxlen;
-	char	*lbuf = NULL, *p;
+	size_t	i, j, blen = 0, maxlen;
+	ssize_t len;
+	char	*p = NULL;
 	bool	found_revision = (revision == NULL);
 
 	using_plan_a = false;
@@ -295,26 +297,20 @@
 		pfatal("can't open file %s", TMPINNAME);
 	len = 0;
 	maxlen = 1;
-	while ((p = fgetln(ifp, &len)) != NULL) {
+	while ((len = getline(&p, &blen, ifp)) >= 0) {
 		if (p[len - 1] == '\n')
 			p[len - 1] = '\0';
 		else {
-			/* EOF without EOL, copy and add the NUL */
-			if ((lbuf = malloc(len + 1)) == NULL)
-				fatal("out of memory\n");
-			memcpy(lbuf, p, len);
-			lbuf[len] = '\0';
-			p = lbuf;
-
+			/* EOF without EOL */
 			last_line_missing_eol = true;
 			len++;
 		}
 		if (revision != NULL && !found_revision && rev_in_string(p))
 			found_revision = true;
-		if (len > maxlen)
+		if ((size_t)len > maxlen)
 			maxlen = len;   /* find longest line */
 	}
-	free(lbuf);
+	free(p);
 	if (ferror(ifp))
 		pfatal("can't read file %s", filename);
 
--- src.orig/patch/patch.c
+++ src.freebsd/patch/patch.c
@@ -174,25 +174,25 @@
 	i++;
 	if (asprintf(&TMPOUTNAME, "%.*s/patchoXXXXXXXXXX", i, tmpdir) == -1)
 		fatal("cannot allocate memory");
-	if ((fd = mkstemp(TMPOUTNAME)) < 0)
+	if ((fd = compat_mkstemp(TMPOUTNAME)) < 0)
 		pfatal("can't create %s", TMPOUTNAME);
 	close(fd);
 
 	if (asprintf(&TMPINNAME, "%.*s/patchiXXXXXXXXXX", i, tmpdir) == -1)
 		fatal("cannot allocate memory");
-	if ((fd = mkstemp(TMPINNAME)) < 0)
+	if ((fd = compat_mkstemp(TMPINNAME)) < 0)
 		pfatal("can't create %s", TMPINNAME);
 	close(fd);
 
 	if (asprintf(&TMPREJNAME, "%.*s/patchrXXXXXXXXXX", i, tmpdir) == -1)
 		fatal("cannot allocate memory");
-	if ((fd = mkstemp(TMPREJNAME)) < 0)
+	if ((fd = compat_mkstemp(TMPREJNAME)) < 0)
 		pfatal("can't create %s", TMPREJNAME);
 	close(fd);
 
 	if (asprintf(&TMPPATNAME, "%.*s/patchpXXXXXXXXXX", i, tmpdir) == -1)
 		fatal("cannot allocate memory");
-	if ((fd = mkstemp(TMPPATNAME)) < 0)
+	if ((fd = compat_mkstemp(TMPPATNAME)) < 0)
 		pfatal("can't create %s", TMPPATNAME);
 	close(fd);
 
@@ -561,7 +561,11 @@
 	Argv_last = Argv;
 	if (!Argc)
 		return;
+#ifdef __GLIBC__
+	optind = 0;
+#else
 	optreset = optind = 1;
+#endif
 	while ((ch = getopt_long(Argc, Argv, options, longopts, NULL)) != -1) {
 		switch (ch) {
 		case 'b':
--- src.orig/patch/pch.c
+++ src.freebsd/patch/pch.c
@@ -1213,14 +1213,15 @@
 size_t
 pgets(bool do_indent)
 {
-	char *line;
-	size_t len = 0;
+	char *line = NULL;
+	ssize_t len = 0;
+	size_t buflen = 0;
 	int indent = 0, skipped = 0;
 
-	line = fgetln(pfp, &len);
-	if (line != NULL) {
-		if (len + 1 > buf_size) {
-			while (len + 1 > buf_size)
+	if ((len = getline(&line, &buflen, pfp)) >= 0) {
+		char *linep = line;
+		if ((size_t)(len + 1) > buf_size) {
+			while ((size_t)(len + 1) > buf_size)
 				buf_size *= 2;
 			free(buf);
 			buf = malloc(buf_size);
@@ -1239,8 +1240,10 @@
 		}
 		memcpy(buf, line, len - skipped);
 		buf[len - skipped] = '\0';
+		line = linep;
 	}
-	return len;
+	free(line);
+	return (len > 0) ? len : 0;
 }
 
 
--- src.orig/sed/main.c
+++ src.freebsd/sed/main.c
@@ -260,7 +260,7 @@
 			state = ST_STRING;
 			goto again;
 		default:
-			__unreachable();
+			abort(); /* unreachable */
 		}
 	case ST_FILE:
 		if ((p = fgets(buf, n, f)) != NULL) {
--- src.orig/sed/process.c
+++ src.freebsd/sed/process.c
@@ -71,7 +71,7 @@
 static void		 do_tr(struct s_tr *);
 static void		 flush_appends(void);
 static void		 lputs(char *, size_t);
-static int		 regexec_e(regex_t *, const char *, int, int, size_t,
+static int		 regexec_e(regex_t *, char *, int, int, size_t,
 			     size_t);
 static void		 regsub(SPACE *, char *, char *);
 static int		 substitute(struct s_command *);
@@ -663,7 +663,7 @@
 }
 
 static int
-regexec_e(regex_t *preg, const char *string, int eflags, int nomatch,
+regexec_e(regex_t *preg, char *string, int eflags, int nomatch,
 	size_t start, size_t stop)
 {
 	int eval;
@@ -675,11 +675,23 @@
 		defpreg = preg;
 
 	/* Set anchors */
+#ifndef REG_STARTEND
+	char old = string[stop];
+	string[stop] = '\0';
+	eval = regexec(defpreg, string + start,
+	    nomatch ? 0 : maxnsub + 1, match, eflags);
+	string[stop] = old;
+	for (size_t i = 0; i <= (nomatch ? 0 : maxnsub); ++i) {
+		match[i].rm_so += start;
+		match[i].rm_eo += start;
+	}
+#else
 	match[0].rm_so = start;
 	match[0].rm_eo = stop;
 
 	eval = regexec(defpreg, string,
 	    nomatch ? 0 : maxnsub + 1, match, eflags | REG_STARTEND);
+#endif
 	switch(eval) {
 	case 0:
 		return (1);
--- src.orig/sh/arith_yacc.c
+++ src.freebsd/sh/arith_yacc.c
@@ -197,6 +197,7 @@
 		return ~primary(op, val, yylex(), noeval);
 	default:
 		yyerror("expecting primary");
+		return 0; /* unreachable */
 	}
 }
 
--- src.orig/sh/error.h
+++ src.freebsd/sh/error.h
@@ -82,12 +82,3 @@
 void warning(const char *, ...) __printflike(1, 2);
 void error(const char *, ...) __printf0like(1, 2) __dead2;
 void errorwithstatus(int, const char *, ...) __printf0like(2, 3) __dead2;
-
-
-/*
- * BSD setjmp saves the signal mask, which violates ANSI C and takes time,
- * so we use _setjmp instead.
- */
-
-#define setjmp(jmploc)	_setjmp(jmploc)
-#define longjmp(jmploc, val)	_longjmp(jmploc, val)
--- src.orig/sh/expand.c
+++ src.freebsd/sh/expand.c
@@ -643,7 +643,8 @@
 		}
 		error("%.*s: parameter %snot set", (int)(p - var - 1),
 		      var, (varflags & VSNUL) ? "null or " : "");
-
+		abort();
+		break;
 	default:
 		abort();
 	}
@@ -800,6 +801,7 @@
 		c = p - var - 1;
 		error("${%.*s%s}: Bad substitution", c, var,
 		    (c > 0 && *p != CTLENDVAR) ? "..." : "");
+		break; /* unreachable */
 
 	default:
 		abort();
@@ -1169,7 +1171,7 @@
 		if (dp->d_name[0] == '.' && ! matchdot)
 			continue;
 		if (patmatch(start, dp->d_name)) {
-			namlen = dp->d_namlen;
+			namlen = strlen(dp->d_name);
 			if (enddir + namlen + 1 > expdir_end)
 				continue;
 			memcpy(enddir, dp->d_name, namlen + 1);
--- src.orig/sh/histedit.c
+++ src.freebsd/sh/histedit.c
@@ -77,10 +77,14 @@
 static char *fc_replace(const char *, char *, char *);
 static int not_fcnumber(const char *);
 static int str_to_event(const char *, int);
-static int comparator(const void *, const void *, void *);
+#ifdef HAVE_FN_COMPLETE2
+static int comparator(const void *, const void *);
 static char **sh_matches(const char *, int, int);
 static const char *append_char_function(const char *);
 static unsigned char sh_complete(EditLine *, int);
+#else
+#define sh_complete _el_fn_complete
+#endif
 
 static const char *
 get_histfile(void)
@@ -114,7 +118,7 @@
 		INTON;
 		return;
 	}
-	fd = mkstemp(histtmpname);
+	fd = compat_mkstemp(histtmpname);
 	if (fd == -1 || (f = fdopen(fd, "w")) == NULL) {
 		free(histtmpname);
 		INTON;
@@ -384,7 +388,7 @@
 		int fd;
 		INTOFF;		/* easier */
 		sprintf(editfilestr, "%s/_shXXXXXX", _PATH_TMP);
-		if ((fd = mkstemp(editfilestr)) < 0)
+		if ((fd = compat_mkstemp(editfilestr)) < 0)
 			error("can't create temporary file %s", editfile);
 		editfile = editfilestr;
 		if ((efp = fdopen(fd, "w")) == NULL) {
@@ -579,17 +583,17 @@
 	return ret;
 }
 
+#ifdef HAVE_FN_COMPLETE2
+static size_t comp_curpos;
 /*
  * Comparator function for qsort(). The use of curpos here is to skip
  * characters that we already know to compare equal (common prefix).
  */
 static int
-comparator(const void *a, const void *b, void *thunk)
+comparator(const void *a, const void *b)
 {
-	size_t curpos = (intptr_t)thunk;
-
-	return (strcmp(*(char *const *)a + curpos,
-		*(char *const *)b + curpos));
+	return (strcmp(*(char *const *)a + comp_curpos,
+		*(char *const *)b + comp_curpos));
 }
 
 static char
@@ -666,7 +670,7 @@
 	for (const unsigned char *bp = builtincmd; *bp != 0; bp += 2 + bp[0]) {
 		if (curpos > bp[0] || memcmp(bp + 2, text, curpos) != 0)
 			continue;
-		rmatches = add_match(matches, ++i, &size, strndup(bp + 2, bp[0]));
+		rmatches = add_match(matches, ++i, &size, strndup((char *)bp + 2, bp[0]));
 		if (rmatches == NULL)
 			goto out;
 		matches = rmatches;
@@ -679,8 +683,8 @@
 	}
 	uniq = 1;
 	if (i > 1) {
-		qsort_s(matches + 1, i, sizeof(matches[0]), comparator,
-			(void *)(intptr_t)curpos);
+		comp_curpos = curpos;
+		qsort(matches + 1, i, sizeof(matches[0]), comparator);
 		for (size_t k = 2; k <= i; k++) {
 			const char *l = matches[uniq] + curpos;
 			const char *r = matches[k] + curpos;
@@ -758,6 +762,7 @@
 		L" \t\n\"\\'`@$><=;|&{(", NULL, append_char_function,
 		(size_t)100, NULL, &((int) {0}), NULL, NULL, FN_QUOTE_MATCH);
 }
+#endif
 
 #else
 #include "error.h"
--- src.orig/sh/input.c
+++ src.freebsd/sh/input.c
@@ -366,8 +366,7 @@
 	int fd2;
 	int oflags = O_RDONLY | O_CLOEXEC;
 
-	if (verify == 1 || (verify == -1 && verifyflag))
-		oflags |= O_VERIFY;
+	(void)verify;
 
 	INTOFF;
 	if ((fd = open(fname, oflags)) < 0) {
--- src.orig/sh/main.c
+++ src.freebsd/sh/main.c
@@ -146,19 +146,16 @@
 	INTON;
 	if (iflag)
 		chkmail(1);
-	if (argv[0] && argv[0][0] == '-') {
+	if (lflag) {
 		state = 1;
 		read_profile("/etc/profile");
 state1:
 		state = 2;
-		if (privileged == 0)
-			read_profile("${HOME-}/.profile");
-		else
-			read_profile("/etc/suid_profile");
+		read_profile("${HOME-}/.profile");
 	}
 state2:
 	state = 3;
-	if (!privileged && iflag) {
+	if (iflag) {
 		if ((shinit = lookupvar("ENV")) != NULL && *shinit != '\0') {
 			state = 3;
 			read_profile(shinit);
@@ -259,9 +256,6 @@
 	const char *expandedname;
 	int oflags = O_RDONLY | O_CLOEXEC;
 
-	if (verifyflag)
-		oflags |= O_VERIFY;
-
 	expandedname = expandstr(name);
 	if (expandedname == NULL)
 		return;
@@ -356,4 +350,5 @@
 		exitshell(number(argv[1]));
 	else
 		exitshell_savedstatus();
+	return 1; /* unreachable */
 }
--- src.orig/sh/memalloc.h
+++ src.freebsd/sh/memalloc.h
@@ -36,6 +36,9 @@
 
 #include <string.h>
 
+#define ALIGNBYTES (sizeof(void *) - 1)
+#define ALIGN(v) (((uintptr_t)(v) + ALIGNBYTES) & ~ALIGNBYTES)
+
 struct stackmark {
 	struct stack_block *stackp;
 	char *stacknxt;
--- src.orig/sh/miscbltin.c
+++ src.freebsd/sh/miscbltin.c
@@ -444,6 +444,13 @@
 	char	option;
 };
 
+/* linux */
+#ifndef RLIMIT_VMEM
+#ifdef RLIMIT_AS
+#define RLIMIT_VMEM RLIMIT_AS
+#endif
+#endif
+
 static const struct limits limits[] = {
 #ifdef RLIMIT_CPU
 	{ "cpu time",		"seconds",	RLIMIT_CPU,	   1, 't' },
@@ -475,7 +482,8 @@
 #ifdef RLIMIT_VMEM
 	{ "virtual mem size",	"kbytes",	RLIMIT_VMEM,	1024, 'v' },
 #endif
-#ifdef RLIMIT_SWAP
+#if 0
+#ifdef
 	{ "swap limit",		"kbytes",	RLIMIT_SWAP,	1024, 'w' },
 #endif
 #ifdef RLIMIT_SBSIZE
@@ -490,6 +498,23 @@
 #ifdef RLIMIT_UMTXP
 	{ "umtx shared locks",	(char *)0,	RLIMIT_UMTXP,	   1, 'o' },
 #endif
+#else
+#ifdef RLIMIT_LOCKS
+	{ "locks",		(char *)0,	RLIMIT_LOCKS,	   1, 'w' },
+#endif
+#ifdef RLIMIT_SIGPENDING
+	{ "pending signals",		(char *)0,	RLIMIT_SIGPENDING,	   1, 'i' },
+#endif
+#ifdef RLIMIT_MSGQUEUE
+	{ "POSIX msg queue",	"bytes",	RLIMIT_MSGQUEUE,	   1, 'q' },
+#endif
+#ifdef RLIMIT_NICE
+	{ "max nice",		(char *)0,	RLIMIT_NICE,	   1, 'e' },
+#endif
+#ifdef RLIMIT_RTPRIO
+	{ "rt priority",		(char *)0,	RLIMIT_RTPRIO,	   1, 'r' },
+#endif
+#endif
 #ifdef RLIMIT_PIPEBUF
 	{ "pipebuf",		(char *)0,	RLIMIT_PIPEBUF, 1024, 'y' },
 #endif
@@ -528,7 +553,7 @@
 	struct rlimit	limit;
 
 	what = 'f';
-	while ((optc = nextopt("HSatfdsmcnuvlbpwkoy")) != '\0')
+	while ((optc = nextopt("HSatfdsmcnuvlbpwkoreiqy")) != '\0')
 		switch (optc) {
 		case 'H':
 			how = HARD;
@@ -570,7 +595,8 @@
 				error("bad number");
 			uval *= l->factor;
 			val = (rlim_t)uval;
-			if (val < 0 || (uintmax_t)val != uval ||
+			/* posix says rlim_t is unsigned */
+			if (uval > ((rlim_t)~(rlim_t)0) ||
 			    val == RLIM_INFINITY)
 				error("bad number");
 		}
--- src.orig/sh/mkbuiltins
+++ src.freebsd/sh/mkbuiltins
@@ -33,13 +33,14 @@
 #
 #	@(#)mkbuiltins	8.2 (Berkeley) 5/4/95
 
-temp=`mktemp -t ka`
+temp=`mktemp`
 srcdir=$1
+dstdir=$2
 havejobs=0
 if grep '^#define[	 ]*JOBS[	 ]*1' $srcdir/shell.h > /dev/null
 then	havejobs=1
 fi
-exec > builtins.c
+exec > "${dstdir}/builtins.c"
 cat <<\!
 /*
  * This file was generated by the mkbuiltins program.
@@ -70,7 +71,7 @@
 	}}' $temp
 echo '};'
 
-exec > builtins.h
+exec > "${dstdir}/builtins.h"
 cat <<\!
 /*
  * This file was generated by the mkbuiltins program.
--- src.orig/sh/mknodes.c
+++ src.freebsd/sh/mknodes.c
@@ -95,7 +95,7 @@
 
 static void parsenode(void);
 static void parsefield(void);
-static void output(char *);
+static void output(char *, char *, char *);
 static void outsizes(FILE *);
 static void outfunc(FILE *, int);
 static void indent(int, FILE *);
@@ -111,7 +111,7 @@
 {
 	FILE *infp;
 
-	if (argc != 3)
+	if (argc != 5)
 		error("usage: mknodes file");
 	if ((infp = fopen(argv[1], "r")) == NULL)
 		error("Can't open %s: %s", argv[1], strerror(errno));
@@ -122,7 +122,7 @@
 			parsenode();
 	}
 	fclose(infp);
-	output(argv[2]);
+	output(argv[2], argv[3], argv[4]);
 	exit(0);
 }
 
@@ -212,7 +212,7 @@
 \n";
 
 static void
-output(char *file)
+output(char *file, char *nodesh, char *nodesc)
 {
 	FILE *hfile;
 	FILE *cfile;
@@ -224,9 +224,9 @@
 
 	if ((patfile = fopen(file, "r")) == NULL)
 		error("Can't open %s: %s", file, strerror(errno));
-	if ((hfile = fopen("nodes.h", "w")) == NULL)
+	if ((hfile = fopen(nodesh, "w")) == NULL)
 		error("Can't create nodes.h: %s", strerror(errno));
-	if ((cfile = fopen("nodes.c", "w")) == NULL)
+	if ((cfile = fopen(nodesc, "w")) == NULL)
 		error("Can't create nodes.c");
 	fputs(writer, hfile);
 	for (i = 0 ; i < ntypes ; i++)
--- src.orig/sh/mksyntax.c
+++ src.freebsd/sh/mksyntax.c
@@ -112,18 +112,23 @@
 static void output_type_macros(void);
 
 int
-main(int argc __unused, char **argv __unused)
+main(int argc, char **argv)
 {
 	int i;
 	char buf[80];
 	int pos;
 
+	if (argc <= 2) {
+		fprintf(stderr, "not enough arguments\n");
+		return 1;
+	}
+
 	/* Create output files */
-	if ((cfile = fopen("syntax.c", "w")) == NULL) {
+	if ((cfile = fopen(argv[2], "w")) == NULL) {
 		perror("syntax.c");
 		exit(2);
 	}
-	if ((hfile = fopen("syntax.h", "w")) == NULL) {
+	if ((hfile = fopen(argv[1], "w")) == NULL) {
 		perror("syntax.h");
 		exit(2);
 	}
--- src.orig/sh/mktokens
+++ src.freebsd/sh/mktokens
@@ -37,7 +37,8 @@
 # token marks the end of a list.  The third column is the name to print in
 # error messages.
 
-temp=`mktemp -t ka`
+temp=`mktemp`
+dstdir=$1
 cat > $temp <<\!
 TEOF	1	end of file
 TNL	0	newline
@@ -69,7 +70,7 @@
 TNOT	0	"!"
 !
 nl=`wc -l $temp`
-exec > token.h
+exec > "${dstdir}/token.h"
 awk '{print "#define " $1 " " NR-1}' $temp
 echo '
 /* Array indicating which tokens mark the end of a list */
--- src.orig/sh/myhistedit.h
+++ src.freebsd/sh/myhistedit.h
@@ -37,7 +37,22 @@
 extern EditLine *el;
 extern int displayhist;
 
-#include <filecomplete.h>
+#ifdef HAVE_FN_COMPLETE2
+#define FN_QUOTE_MATCH 1U
+/* while this is not a part of the public API in libedit, it is a part of
+ * its public ABI (in recent versions, older ones did not have it, which
+ * is why this is guarded here)
+ *
+ * i hope libedit will at very least play nice and not break it, as that
+ * could get ugly
+ */
+int fn_complete2(EditLine *,
+    char *(*)(const char *, int),
+    char **(*)(const char *, int, int),
+    const wchar_t *, const wchar_t *, const char *(*)(const char *), size_t,
+    int *, int *, int *, int *, unsigned int);
+char *fn_tilde_expand(const char *);
+#endif
 
 void histedit(void);
 void sethistsize(const char *);
--- src.orig/sh/options.c
+++ src.freebsd/sh/options.c
@@ -89,11 +89,11 @@
 	char *scriptname;
 
 	argptr = argv;
+	lflag = argptr[0] && argptr[0][0] == '-';
 	if (argc > 0)
 		argptr++;
 	for (i = 0; i < NOPTS; i++)
 		optval[i] = 2;
-	privileged = (getuid() != geteuid() || getgid() != getegid());
 	options(1);
 	if (*argptr == NULL && minusc == NULL)
 		sflag = 1;
@@ -196,6 +196,8 @@
 				if (q == NULL || minusc != NULL)
 					error("Bad -c option");
 				minusc = q;
+			} else if (c == 'l' && cmdline) {
+				lflag |= 1;
 			} else if (c == 'o') {
 				minus_o(*argptr, val);
 				if (*argptr)
@@ -282,12 +284,6 @@
 static void
 setoptionbyindex(int idx, int val)
 {
-	if (&optval[idx] == &privileged && !val && privileged) {
-		if (setgid(getgid()) == -1)
-			error("setgid");
-		if (setuid(getuid()) == -1)
-			error("setuid");
-	}
 	optval[idx] = val;
 	if (val) {
 		/* #%$ hack for ksh semantics */
--- src.orig/sh/options.h
+++ src.freebsd/sh/options.h
@@ -61,22 +61,22 @@
 #define	aflag optval[12]
 #define	bflag optval[13]
 #define	uflag optval[14]
-#define	privileged optval[15]
-#define	Tflag optval[16]
-#define	Pflag optval[17]
-#define	hflag optval[18]
-#define	nologflag optval[19]
-#define	pipefailflag optval[20]
-#define	verifyflag optval[21]
+#define	Tflag optval[15]
+#define	Pflag optval[16]
+#define	hflag optval[17]
+#define	nologflag optval[18]
+#define	pipefailflag optval[19]
 
-#define NSHORTOPTS	19
-#define NOPTS		22
+#define NSHORTOPTS	18
+#define NOPTS		20
 
+extern char lflag;
 extern char optval[NOPTS];
 extern const char optletter[NSHORTOPTS];
 #ifdef DEFINE_OPTIONS
+char lflag;
 char optval[NOPTS];
-const char optletter[NSHORTOPTS] = "efIimnsxvVECabupTPh";
+const char optletter[NSHORTOPTS] = "efIimnsxvVECabuTPh";
 static const unsigned char optname[] =
 	"\007errexit"
 	"\006noglob"
@@ -93,13 +93,11 @@
 	"\011allexport"
 	"\006notify"
 	"\007nounset"
-	"\012privileged"
 	"\012trapsasync"
 	"\010physical"
 	"\010trackall"
 	"\005nolog"
 	"\010pipefail"
-	"\006verify"
 ;
 #endif
 
--- src.orig/sh/output.c
+++ src.freebsd/sh/output.c
@@ -69,7 +69,7 @@
 #define MEM_OUT -2		/* output to dynamically allocated memory */
 #define OUTPUT_ERR 01		/* error occurred on output */
 
-static int doformat_wr(void *, const char *, int);
+static ssize_t doformat_wr(void *, const char *, size_t);
 
 struct output output = {NULL, NULL, NULL, OUTBUFSIZ, 1, 0};
 struct output errout = {NULL, NULL, NULL, 256, 2, 0};
@@ -316,8 +316,8 @@
 	INTON;
 }
 
-static int
-doformat_wr(void *cookie, const char *buf, int len)
+static ssize_t
+doformat_wr(void *cookie, const char *buf, size_t len)
 {
 	struct output *o;
 
@@ -327,12 +327,19 @@
 	return (len);
 }
 
+static cookie_io_functions_t func = {
+    .write = doformat_wr,
+    .read = NULL,
+    .seek = NULL,
+    .close = NULL
+};
+
 void
 doformat(struct output *dest, const char *f, va_list ap)
 {
 	FILE *fp;
 
-	if ((fp = fwopen(dest, doformat_wr)) != NULL) {
+	if ((fp = fopencookie(dest, "a", func)) != NULL) {
 		vfprintf(fp, f, ap);
 		fclose(fp);
 	}
@@ -341,7 +348,7 @@
 FILE *
 out1fp(void)
 {
-	return fwopen(out1, doformat_wr);
+	return fopencookie(out1, "a", func);
 }
 
 /*
--- src.orig/sh/parser.c
+++ src.freebsd/sh/parser.c
@@ -592,6 +592,9 @@
 	case TRP:
 		if (!redir)
 			synexpect(-1);
+		tokpushback++;
+		n1 = simplecmd(rpp, redir);
+		return n1;
 	case TWORD:
 		tokpushback++;
 		n1 = simplecmd(rpp, redir);
@@ -1092,7 +1095,6 @@
 	struct jmploc jmploc;
 	struct jmploc *const savehandler = handler;
 	size_t savelen;
-	int saveprompt;
 	const int bq_startlinno = plinno;
 	char *volatile ostr = NULL;
 	struct parsefile *const savetopfile = getcurrentfile();
@@ -1180,18 +1182,16 @@
 	(*nlpp)->next = NULL;
 
 	if (oldstyle) {
-		saveprompt = doprompt;
+		int saveprompt = doprompt;
 		doprompt = 0;
-	}
-
-	n = list(0);
-
-	if (oldstyle) {
+		n = list(0);
 		if (peektoken() != TEOF)
 			synexpect(-1);
 		doprompt = saveprompt;
-	} else
+	} else {
+		n = list(0);
 		consumetoken(TRP);
+	}
 
 	(*nlpp)->n = n;
         if (oldstyle) {
@@ -1240,12 +1240,13 @@
 readcstyleesc(char *out)
 {
 	int c, vc, i, n;
-	unsigned int v;
+	unsigned int v = 0;
 
 	c = pgetc();
 	switch (c) {
 	case '\0':
 		synerror("Unterminated quoted string");
+		return NULL; /* unreachable */
 	case '\n':
 		plinno++;
 		if (doprompt)
@@ -1989,7 +1990,7 @@
 static void
 getusername(char *name, size_t namelen)
 {
-	static char cached_name[MAXLOGNAME];
+	static char cached_name[LOGIN_NAME_MAX];
 	struct passwd *pw;
 	uid_t euid;
 
--- src.orig/sh/redir.c
+++ src.freebsd/sh/redir.c
@@ -173,7 +173,7 @@
 	struct stat sb;
 	int fd = redir->nfile.fd;
 	const char *fname;
-	int f;
+	int f = 0;
 	int e;
 
 	memory[fd] = 0;
--- src.orig/sh/sh.1
+++ src.freebsd/sh/sh.1
@@ -277,22 +277,6 @@
 to
 .Fl P
 (physical directory layout).
-.It Fl p Li privileged
-Turn on privileged mode.
-This mode is enabled on startup
-if either the effective user or group ID is not equal to the
-real user or group ID.
-Turning this mode off sets the
-effective user and group IDs to the real user and group IDs.
-When this mode is enabled for interactive shells, the file
-.Pa /etc/suid_profile
-is sourced instead of
-.Pa ~/.profile
-after
-.Pa /etc/profile
-is sourced, and the contents of the
-.Ev ENV
-variable are ignored.
 .It Fl s Li stdin
 Read commands from standard input (set automatically
 if no file arguments are present).
@@ -2662,7 +2646,7 @@
 For aliases the alias expansion is printed;
 for commands and tracked aliases
 the complete pathname of the command is printed.
-.It Ic ulimit Oo Fl HSabcdfklmnopstuvw Oc Op Ar limit
+.It Ic ulimit Oo Fl HSacedfilmnqrstuvw Oc Op Ar limit
 Set or display resource limits (see
 .Xr getrlimit 2 ) .
 If
@@ -2701,8 +2685,6 @@
 displayed or modified.
 They are mutually exclusive.
 .Bl -tag -width indent
-.It Fl b Ar sbsize
-The maximum size of socket buffer usage, in bytes.
 .It Fl c Ar coredumpsize
 The maximal size of core dump files, in 512-byte blocks.
 Setting
@@ -2710,13 +2692,12 @@
 to 0 prevents core dump files from being created.
 .It Fl d Ar datasize
 The maximal size of the data segment of a process, in kilobytes.
+.It Fl e Ar nice
+The nice value ceiling for the process.
 .It Fl f Ar filesize
 The maximal size of a file, in 512-byte blocks.
-.It Fl k Ar kqueues
-The maximal number of kqueues
-(see
-.Xr kqueue 2 )
-for this user ID.
+.It Fl i Ar sigpending
+The limit on the number of signals that may be queued.
 .It Fl l Ar lockedmem
 The maximal size of memory that can be locked by a process, in
 kilobytes.
@@ -2724,13 +2705,10 @@
 The maximal resident set size of a process, in kilobytes.
 .It Fl n Ar nofiles
 The maximal number of descriptors that could be opened by a process.
-.It Fl o Ar umtxp
-The maximal number of process-shared locks
-(see
-.Xr pthread 3 )
-for this user ID.
-.It Fl p Ar pseudoterminals
-The maximal number of pseudo-terminals for this user ID.
+.It Fl r Ar rtprio
+The ceiling on the real-time priority that may be set for the process.
+.It Fl q Ar msgqueue
+The limit on the number of bytes that may be allocated for POSIX message queus.
 .It Fl s Ar stacksize
 The maximal size of the stack segment, in kilobytes.
 .It Fl t Ar time
@@ -2739,9 +2717,12 @@
 The maximal number of simultaneous processes for this user ID.
 .It Fl v Ar virtualmem
 The maximal virtual size of a process, in kilobytes.
-.It Fl w Ar swapuse
-The maximum amount of swap space reserved or used for this user ID,
-in kilobytes.
+.It Fl w Ar locks
+The limit on the combined number of
+.Xr flock 2
+and
+.Xr fcntl 2
+locks.
 .El
 .It Ic umask Oo Fl S Oc Op Ar mask
 Set the file creation mask (see
--- src.orig/sh/trap.c
+++ src.freebsd/sh/trap.c
@@ -111,10 +111,11 @@
 
 		if (strncasecmp(sig, "SIG", 3) == 0)
 			sig += 3;
-		for (n = 1; n < sys_nsig; n++)
-			if (sys_signame[n] &&
-			    strcasecmp(sys_signame[n], sig) == 0)
+		for (n = 1; n < NSIG; n++) {
+			const char *sign = signum_to_signame(n);
+			if (sign && strcasecmp(sign, sig) == 0)
 				return (n);
+		}
 	}
 	return (-1);
 }
@@ -129,16 +130,17 @@
 	int n, outlen;
 
 	outlen = 0;
-	for (n = 1; n < sys_nsig; n++) {
-		if (sys_signame[n]) {
-			out1fmt("%s", sys_signame[n]);
-			outlen += strlen(sys_signame[n]);
+	for (n = 1; n < NSIG; n++) {
+		const char *sign = signum_to_signame(n);
+		if (sign) {
+			out1fmt("%s", sign);
+			outlen += strlen(sign);
 		} else {
 			out1fmt("%d", n);
 			outlen += 3;	/* good enough */
 		}
 		++outlen;
-		if (outlen > 71 || n == sys_nsig - 1) {
+		if (outlen > 71 || n == NSIG - 1) {
 			out1str("\n");
 			outlen = 0;
 		} else {
@@ -169,14 +171,15 @@
 	argv = argptr;
 
 	if (*argv == NULL) {
-		for (signo = 0 ; signo < sys_nsig ; signo++) {
+		for (signo = 0 ; signo < NSIG ; signo++) {
 			if (signo < NSIG && trap[signo] != NULL) {
+				const char *sign = signum_to_signame(signo);
 				out1str("trap -- ");
 				out1qstr(trap[signo]);
 				if (signo == 0) {
 					out1str(" EXIT\n");
-				} else if (sys_signame[signo]) {
-					out1fmt(" %s\n", sys_signame[signo]);
+				} else if (sign) {
+					out1fmt(" %s\n", sign);
 				} else {
 					out1fmt(" %d\n", signo);
 				}
--- src.orig/su/su.1
+++ src.freebsd/su/su.1
@@ -36,8 +36,7 @@
 .Sh SYNOPSIS
 .Nm
 .Op Fl
-.Op Fl c Ar class
-.Op Fl flms
+.Op Fl lm
 .Op Ar login Op Ar args
 .Sh DESCRIPTION
 The
@@ -50,17 +49,6 @@
 PAM is used to set the policy
 .Xr su 1
 will use.
-In particular, by default only users in the
-.Dq Li wheel
-group can switch to UID 0
-.Pq Dq Li root .
-This group requirement may be changed by modifying the
-.Dq Li pam_group
-section of
-.Pa /etc/pam.d/su .
-See
-.Xr pam_group 8
-for details on how to modify this setting.
 .Pp
 By default, the environment is unmodified with the exception of
 .Ev USER ,
@@ -77,24 +65,9 @@
 The invoked shell is the one belonging to the target login.
 This is the traditional behavior of
 .Nm .
-Resource limits and session priority applicable to the original user's
-login class (see
-.Xr login.conf 5 )
-are also normally retained unless the target login has a user ID of 0.
 .Pp
 The options are as follows:
 .Bl -tag -width Ds
-.It Fl c Ar class
-Use the settings of the specified login class.
-The login class must be defined in
-.Xr login.conf 5 .
-Only allowed for the super-user.
-.It Fl f
-If the invoked shell is
-.Xr csh 1 ,
-this option prevents it from reading the
-.Dq Pa .cshrc
-file.
 .It Fl l
 Simulate a full login.
 The environment is discarded except for
@@ -115,13 +88,9 @@
 .Dq Pa /bin:/usr/bin .
 .Ev TERM
 is imported from your current environment.
-Environment variables may be set or overridden from the login class
-capabilities database according to the class of the target login.
 The invoked shell is the target login's, and
 .Nm
 will change directory to the target login's home directory.
-Resource limits and session priority are modified to that for the
-target account's login class.
 .It Fl
 (no letter) The same as
 .Fl l .
@@ -135,14 +104,6 @@
 non-zero,
 .Nm
 will fail.
-.It Fl s
-Set the MAC label to the user's default label as part of the user
-credential setup.
-Setting the MAC label may fail if the MAC label of the invoking process
-is not sufficient to transition to the user's default MAC label.
-If the label cannot be set,
-.Nm
-will fail.
 .El
 .Pp
 The
@@ -218,15 +179,6 @@
 (Most shells expect the argument to
 .Fl c
 to be a single word).
-.It Li "su -m -c staff operator -c 'shutdown -p now'"
-Same as above, but the target command is run with the resource limits of
-the login class
-.Dq staff .
-Note: in this example, the first
-.Fl c
-option applies to
-.Nm
-while the second is an argument to the shell being invoked.
 .It Li "su -l foo"
 Simulate a login for user foo.
 .It Li "su - foo"
@@ -235,13 +187,10 @@
 Simulate a login for root.
 .El
 .Sh SEE ALSO
-.Xr csh 1 ,
 .Xr sh 1 ,
 .Xr group 5 ,
-.Xr login.conf 5 ,
 .Xr passwd 5 ,
-.Xr environ 7 ,
-.Xr pam_group 8
+.Xr environ 7
 .Sh HISTORY
 A
 .Nm
--- src.orig/su/su.c
+++ src.freebsd/su/su.c
@@ -71,6 +71,8 @@
 #endif /* not lint */
 #endif
 
+#include "config-compat.h"
+
 #include <sys/cdefs.h>
 #include <sys/param.h>
 #include <sys/time.h>
@@ -85,7 +87,6 @@
 #include <err.h>
 #include <errno.h>
 #include <grp.h>
-#include <login_cap.h>
 #include <paths.h>
 #include <pwd.h>
 #include <signal.h>
@@ -97,7 +98,13 @@
 #include <stdarg.h>
 
 #include <security/pam_appl.h>
-#include <security/openpam.h>
+#ifdef HAVE_PAM_MISC
+#  include <security/pam_misc.h>
+#  define PAM_CONV_FUNC misc_conv
+#else
+#  include <security/openpam.h>
+#  define PAM_CONV_FUNC openpam_ttyconv
+#endif
 
 #define PAM_END() do {							\
 	int local_ret;							\
@@ -150,18 +157,15 @@
 {
 	static char	*cleanenv;
 	struct passwd	*pwd = NULL;
-	struct pam_conv	conv = { openpam_ttyconv, NULL };
-	enum tristate	iscsh;
-	login_cap_t	*lc;
+	struct pam_conv	conv = { PAM_CONV_FUNC, NULL };
 	union {
 		const char	**a;
 		char		* const *b;
 	}		np;
 	uid_t		ruid;
 	pid_t		child_pid, child_pgrp, pid;
-	int		asme, ch, asthem, fastlogin, prio, i, retcode,
-			statusp, setmaclabel;
-	u_int		setwhat;
+	int		asme, ch, asthem, prio, i, retcode,
+			statusp;
 	char		*username, *class, shellbuf[MAXPATHLEN];
 	const char	*p, *user, *shell, *mytty, **nargv;
 	const void	*v;
@@ -173,17 +177,11 @@
 #endif
 
 	p = shell = class = cleanenv = NULL;
-	asme = asthem = fastlogin = statusp = 0;
+	asme = asthem = statusp = 0;
 	user = "root";
-	iscsh = UNSET;
-	setmaclabel = 0;
 
-	while ((ch = getopt(argc, argv, "-flmsc:")) != -1)
+	while ((ch = getopt(argc, argv, "lm")) != -1)
 		switch ((char)ch) {
-		case 'f':
-			fastlogin = 1;
-			break;
-		case '-':
 		case 'l':
 			asme = 0;
 			asthem = 1;
@@ -192,18 +190,18 @@
 			asme = 1;
 			asthem = 0;
 			break;
-		case 's':
-			setmaclabel = 1;
-			break;
-		case 'c':
-			class = optarg;
-			break;
 		case '?':
 		default:
 			usage();
 		/* NOTREACHED */
 		}
 
+	if (optind < argc && !strcmp(argv[optind], "-")) {
+		asme = 0;
+		asthem = 1;
+		++optind;
+	}
+
 	if (optind < argc)
 		user = argv[optind++];
 
@@ -224,7 +222,7 @@
 		errx(1, "Permission denied");
 	}
 #endif
-	if (strlen(user) > MAXLOGNAME - 1) {
+	if (strlen(user) > LOGIN_NAME_MAX - 1) {
 #ifdef USE_BSM_AUDIT
 		if (audit_submit(AUE_su, auid,
 		    EPERM, 1, "username too long: '%s'", user))
@@ -281,7 +279,6 @@
 		}
 		else {
 			shell = _PATH_BSHELL;
-			iscsh = NO;
 		}
 	}
 
@@ -359,6 +356,7 @@
 		errx(1, "Sorry");
 	}
 
+#if 0
 	/* get target login information */
 	if (class == NULL)
 		lc = login_getpwclass(pwd);
@@ -377,6 +375,7 @@
 		if (lc->lc_class == NULL || strcmp(class, lc->lc_class) != 0)
 			errx(1, "unknown class: %s", class);
 	}
+#endif
 
 	/* if asme and non-standard target shell, must be root */
 	if (asme) {
@@ -385,13 +384,11 @@
 	}
 	else if (pwd->pw_shell && *pwd->pw_shell) {
 		shell = pwd->pw_shell;
-		iscsh = UNSET;
 	}
 	else {
 		shell = _PATH_BSHELL;
-		iscsh = NO;
 	}
-
+#if 0
 	/* if we're forking a csh, we want to slightly muck the args */
 	if (iscsh == UNSET) {
 		p = strrchr(shell, '/');
@@ -401,14 +398,17 @@
 			p = shell;
 		iscsh = strcmp(p, "csh") ? (strcmp(p, "tcsh") ? NO : YES) : YES;
 	}
+#endif
 	setpriority(PRIO_PROCESS, 0, prio);
 
+#if 0
 	/*
 	 * PAM modules might add supplementary groups in pam_setcred(), so
 	 * initialize them first.
 	 */
 	if (setusercontext(lc, pwd, pwd->pw_uid, LOGIN_SETGROUP) < 0)
 		err(1, "setusercontext");
+#endif
 
 	retcode = pam_setcred(pamh, PAM_ESTABLISH_CRED);
 	if (retcode != PAM_SUCCESS) {
@@ -485,6 +485,7 @@
 		sigaction(SIGINT, &sa_int, NULL);
 		sigaction(SIGQUIT, &sa_quit, NULL);
 
+#if 0
 		/*
 		 * Set all user context except for: Environmental variables
 		 * Umask Login records (wtmp, etc) Path
@@ -505,6 +506,7 @@
 			setwhat &= ~(LOGIN_SETPRIORITY | LOGIN_SETRESOURCES);
 		if (setusercontext(lc, pwd, pwd->pw_uid, setwhat) < 0)
 			err(1, "setusercontext");
+#endif
 
 		if (!asme) {
 			if (asthem) {
@@ -525,11 +527,12 @@
 				environ_pam = pam_getenvlist(pamh);
 				if (environ_pam)
 					export_pam_environment();
-
+#if 0
 				/* set the su'd user's environment & umask */
 				setusercontext(lc, pwd, pwd->pw_uid,
 					LOGIN_SETPATH | LOGIN_SETUMASK |
 					LOGIN_SETENV);
+#endif
 				if (p)
 					setenv("TERM", p, 1);
 
@@ -538,6 +541,7 @@
 					errx(1, "no directory");
 			}
 		}
+#if 0
 		login_close(lc);
 
 		if (iscsh == YES) {
@@ -547,7 +551,8 @@
 				*np.a-- = "-m";
 		}
 		/* csh strips the first character... */
-		*np.a = asthem ? "-su" : iscsh == YES ? "_su" : "su";
+#endif
+		*np.a = asthem ? "-su" : "su";
 
 		if (ruid != 0)
 			syslog(LOG_NOTICE, "%s to %s%s", username, user,
@@ -609,7 +614,7 @@
 usage(void)
 {
 
-	fprintf(stderr, "usage: su [-] [-flms] [-c class] [login [args]]\n");
+	fprintf(stderr, "usage: su [-] [-lm] [login [args]]\n");
 	exit(1);
 	/* NOTREACHED */
 }
--- src.orig/telnet/libtelnet/auth.c
+++ src.freebsd/telnet/libtelnet/auth.c
@@ -394,7 +394,7 @@
 	if (data < _auth_send_data ||
 	    data > _auth_send_data + sizeof(_auth_send_data)) {
 		auth_send_cnt = (size_t)cnt > sizeof(_auth_send_data)
-					? sizeof(_auth_send_data)
+					? (int)sizeof(_auth_send_data)
 					: cnt;
 		memmove((void *)_auth_send_data, (void *)data, auth_send_cnt);
 		auth_send_data = _auth_send_data;
@@ -494,7 +494,7 @@
 void
 auth_name(unsigned char *data, int cnt)
 {
-	unsigned char savename[256];
+	char savename[256];
 
 	if (cnt < 1) {
 		if (auth_debug_mode)
@@ -545,7 +545,7 @@
 
 /* ARGSUSED */
 static void
-auth_intr(int sig __unused)
+auth_intr(int sig __attribute__((unused)))
 {
 	auth_finished(0, AUTH_REJECT);
 }
--- src.orig/telnet/libtelnet/enc_des.c
+++ src.freebsd/telnet/libtelnet/enc_des.c
@@ -116,7 +116,7 @@
 int fb64_keyid(int, unsigned char *, int *, struct fb *);
 
 void
-cfb64_init(int server __unused)
+cfb64_init(int server __attribute__((unused)))
 {
 	fb64_init(&fb[CFB]);
 	fb[CFB].fb_feed[4] = ENCTYPE_DES_CFB64;
@@ -125,7 +125,7 @@
 }
 
 void
-ofb64_init(int server __unused)
+ofb64_init(int server __attribute__((unused)))
 {
 	fb64_init(&fb[OFB]);
 	fb[OFB].fb_feed[4] = ENCTYPE_DES_OFB64;
@@ -165,7 +165,7 @@
 }
 
 static int
-fb64_start(struct fb *fbp, int dir, int server __unused)
+fb64_start(struct fb *fbp, int dir, int server __attribute__((unused)))
 {
 	size_t x;
 	unsigned char *p;
--- src.orig/telnet/libtelnet/encrypt.c
+++ src.freebsd/telnet/libtelnet/encrypt.c
@@ -604,7 +604,7 @@
  * Called when a ENCRYPT START command is received.
  */
 void
-encrypt_start(unsigned char *data __unused, int cnt __unused)
+encrypt_start(unsigned char *data __attribute__((unused)), int cnt __attribute__((unused)))
 {
 	Encryptions *ep;
 
@@ -682,7 +682,7 @@
  * can.
  */
 void
-encrypt_request_start(unsigned char *data __unused, int cnt __unused)
+encrypt_request_start(unsigned char *data __attribute__((unused)), int cnt __attribute__((unused)))
 {
 	if (encrypt_mode == 0)  {
 		if (Server)
@@ -747,7 +747,7 @@
 		return;
 	}
 
-	encrypt_send_keyid(dir, kp->keyid, kp->keylen, 0);
+	encrypt_send_keyid(dir, (const char *)kp->keyid, kp->keylen, 0);
 }
 
 void
--- src.orig/telnet/libtelnet/misc.c
+++ src.freebsd/telnet/libtelnet/misc.c
@@ -51,7 +51,7 @@
 int ConnectedCount = 0;
 
 #ifndef AUTHENTICATION
-#define undef1 __unused
+#define undef1 __attribute__((unused))
 #else
 #define undef1
 #endif
@@ -84,7 +84,7 @@
 
 /* ARGSUSED */
 void
-auth_encrypt_connect(int cnt __unused)
+auth_encrypt_connect(int cnt __attribute__((unused)))
 {
 }
 #endif	/* ENCRYPTION */
--- src.orig/telnet/libtelnet/pk.c
+++ src.freebsd/telnet/libtelnet/pk.c
@@ -40,6 +40,7 @@
  */
 
 #include <sys/time.h>
+#include <sys/random.h>
 #include <openssl/des.h>
 #include <fcntl.h>
 #include <stdio.h>
@@ -138,7 +139,15 @@
 static void
 getseed(char *seed, int seedsize)
 {
-	arc4random_buf(seed, seedsize);
+	for (;;) {
+		ssize_t rn = getrandom(seed, seedsize, GRND_RANDOM);
+		if (rn >= seedsize)
+			break;
+		else if (rn < 0)
+			continue;
+		seed += rn;
+		seedsize -= rn;
+	}
 }
 
 /*
@@ -219,7 +228,7 @@
 	memset(buf,0,sizeof(buf));
 	deslen = ((strlen(in) + 7)/8)*8;
 	DES_key_sched(key, &k);
-	DES_cbc_encrypt(in, buf, deslen, &k, &i, DES_ENCRYPT);
+	DES_cbc_encrypt((unsigned char *)in, (unsigned char *)buf, deslen, &k, &i, DES_ENCRYPT);
 	for (l=0,op=0;l<deslen;l++) {
 		out[op++] = hextab[(buf[l] & 0xf0) >> 4];
 		out[op++] = hextab[(buf[l] & 0x0f)];
@@ -251,6 +260,6 @@
 		buf[l] = n1*16 +n2;
 	}
 	DES_key_sched(key, &k);
-	DES_cbc_encrypt(buf, out, strlen(in) / 2, &k, &i, DES_DECRYPT);
+	DES_cbc_encrypt((unsigned char *)buf, (unsigned char *)out, strlen(in) / 2, &k, &i, DES_DECRYPT);
 	out[strlen(in)/2] = '\0';
 }
--- src.orig/telnet/libtelnet/sra.c
+++ src.freebsd/telnet/libtelnet/sra.c
@@ -37,7 +37,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <syslog.h>
-#include <ttyent.h>
 
 #ifndef NOPAM
 #include <security/pam_appl.h>
@@ -106,7 +105,7 @@
 }
 
 int
-sra_init(Authenticator *ap __unused, int server)
+sra_init(Authenticator *ap __attribute__((unused)), int server)
 {
 	if (server)
 		str_data[3] = TELQUAL_REPLY;
@@ -336,7 +335,7 @@
 }
 
 int
-sra_status(Authenticator *ap __unused, char *name, int level)
+sra_status(Authenticator *ap __attribute__((unused)), char *name, int level)
 {
 	if (level < AUTH_USER)
 		return(level);
@@ -409,6 +408,7 @@
 	}
 }
 
+#if 0
 static int
 isroot(const char *usr)
 {
@@ -426,11 +426,14 @@
 
 	return ((t = getttynam(ttyn)) && t->ty_status & TTY_SECURE);
 }
+#endif
 
 #ifdef NOPAM
 static int
 check_user(char *name, char *cred)
 {
+	(void)name; (void)cred;
+#if 0
 	char *cp;
 	char *xpasswd, *salt;
 
@@ -456,6 +459,7 @@
 		}
 		return(1);
 	}
+#endif
 	return(0);
 }
 #else
--- src.orig/telnet/telnet/commands.c
+++ src.freebsd/telnet/telnet/commands.c
@@ -34,9 +34,11 @@
 #endif
 
 #include <sys/param.h>
+#include <sys/types.h>
 #include <sys/un.h>
 #include <sys/file.h>
 #include <sys/socket.h>
+#include <sys/wait.h>
 #include <netinet/in.h>
 
 #include <assert.h>
@@ -78,6 +80,13 @@
 #define       MAXHOSTNAMELEN 256
 #endif
 
+#ifndef ALIGNBYTES
+#define ALIGNBYTES (sizeof(void *) - 1)
+#endif
+#ifndef ALIGN
+#define ALIGN(v) (((uintptr_t)(v) + ALIGNBYTES) & ~ALIGNBYTES)
+#endif
+
 typedef int (*intrtn_t)(int, char **);
 
 #ifdef	AUTHENTICATION
@@ -102,11 +111,11 @@
 #ifdef INET6
 static int switch_af(struct addrinfo **);
 #endif
-static int togglehelp(void);
+static int togglehelp(int);
 static int send_tncmd(void (*)(int, int), const char *, char *);
 static int setmod(int);
 static int clearmode(int);
-static int modehelp(void);
+static int modehelp(int);
 static int sourceroute(struct addrinfo *, char *, unsigned char **, int *, int *, int *);
 
 typedef struct {
@@ -122,6 +131,10 @@
 static char *margv[20];
 int quiet_mode;
 
+#if defined(__linux__) && !defined(__GLIBC__) && defined(INET6)
+#define INET6_NO_RTHDR
+#endif
+
 #ifdef OPIE
 #include <sys/wait.h>
 #define PATH_OPIEKEY	"/usr/bin/opiekey"
@@ -280,15 +293,15 @@
     const char	*help;		/* Help information (0 ==> no help) */
     int		needconnect;	/* Need to be connected */
     int		narg;		/* Number of arguments */
-    int		(*handler)(char *, ...); /* Routine to perform (for special ops) */
+    int		(*handler)(char *); /* Routine to perform (for special ops) */
     int		nbyte;		/* Number of bytes to send this command */
     int		what;		/* Character to be sent (<0 ==> special) */
 };
 
 
 static int
-	send_esc(void),
-	send_help(void),
+	send_esc(char *),
+	send_help(char *),
 	send_docmd(char *),
 	send_dontcmd(char *),
 	send_willcmd(char *),
@@ -301,7 +314,7 @@
     { "break",	NULL,				1, 0, NULL, 2, BREAK },
     { "ec",	"Send Telnet Erase Character",	1, 0, NULL, 2, EC },
     { "el",	"Send Telnet Erase Line",	1, 0, NULL, 2, EL },
-    { "escape",	"Send current escape character",1, 0, (int (*)(char *, ...))send_esc, 1, 0 },
+    { "escape",	"Send current escape character",1, 0, send_esc, 1, 0 },
     { "ga",	"Send Telnet 'Go Ahead' sequence", 1, 0, NULL, 2, GA },
     { "ip",	"Send Telnet Interrupt Process",1, 0, NULL, 2, IP },
     { "intp",	NULL,				1, 0, NULL, 2, IP },
@@ -312,14 +325,14 @@
     { "abort",	"Send Telnet 'Abort Process'",	1, 0, NULL, 2, ABORT },
     { "susp",	"Send Telnet 'Suspend Process'",1, 0, NULL, 2, SUSP },
     { "eof",	"Send Telnet End of File Character", 1, 0, NULL, 2, xEOF },
-    { "synch",	"Perform Telnet 'Synch operation'", 1, 0, (int (*)(char *, ...))dosynch, 2, 0 },
-    { "getstatus", "Send request for STATUS",	1, 0, (int (*)(char *, ...))get_status, 6, 0 },
-    { "?",	"Display send options",		0, 0, (int (*)(char *, ...))send_help, 0, 0 },
-    { "help",	NULL,				0, 0, (int (*)(char *, ...))send_help, 0, 0 },
-    { "do",	NULL,				0, 1, (int (*)(char *, ...))send_docmd, 3, 0 },
-    { "dont",	NULL,				0, 1, (int (*)(char *, ...))send_dontcmd, 3, 0 },
-    { "will",	NULL,				0, 1, (int (*)(char *, ...))send_willcmd, 3, 0 },
-    { "wont",	NULL,				0, 1, (int (*)(char *, ...))send_wontcmd, 3, 0 },
+    { "synch",	"Perform Telnet 'Synch operation'", 1, 0, dosynch, 2, 0 },
+    { "getstatus", "Send request for STATUS",	1, 0, get_status, 6, 0 },
+    { "?",	"Display send options",		0, 0, send_help, 0, 0 },
+    { "help",	NULL,				0, 0, send_help, 0, 0 },
+    { "do",	NULL,				0, 1, send_docmd, 3, 0 },
+    { "dont",	NULL,				0, 1, send_dontcmd, 3, 0 },
+    { "will",	NULL,				0, 1, send_willcmd, 3, 0 },
+    { "wont",	NULL,				0, 1, send_wontcmd, 3, 0 },
     { NULL,	NULL,				0, 0, NULL, 0, 0 }
 };
 
@@ -366,7 +379,7 @@
 	}
 	count += s->nbyte;
 	if ((void *)s->handler == (void *)send_help) {
-	    send_help();
+	    send_help(NULL);
 	    return 0;
 	}
 
@@ -396,8 +409,7 @@
 	}
 	if (s->handler) {
 	    count++;
-	    success += (*s->handler)((s->narg > 0) ? argv[i+1] : 0,
-				  (s->narg > 1) ? argv[i+2] : 0);
+	    success += (*s->handler)((s->narg > 0) ? argv[i+1] : 0);
 	    i += s->narg;
 	} else {
 	    NET2ADD(IAC, s->what);
@@ -408,8 +420,9 @@
 }
 
 static int
-send_esc(void)
+send_esc(char *name)
 {
+    (void)name;
     NETADD(escape);
     return 1;
 }
@@ -500,9 +513,10 @@
 }
 
 static int
-send_help(void)
+send_help(char *name)
 {
     struct sendlist *s;	/* pointer to current command */
+    (void)name;
     for (s = Sendlist; s->name; s++) {
 	if (s->help)
 	    printf("%-15s %s\n", s->name, s->help);
@@ -516,15 +530,17 @@
  */
 
 static int
-lclchars(void)
+lclchars(int val)
 {
+    (void)val;
     donelclchars = 1;
     return 1;
 }
 
 static int
-togdebug(void)
+togdebug(int val)
 {
+    (void)val;
 #ifndef	NOT43
     if (net > 0 &&
 	(SetSockOpt(net, SOL_SOCKET, SO_DEBUG, telnet_debug)) < 0) {
@@ -542,8 +558,9 @@
 
 
 static int
-togcrlf(void)
+togcrlf(int val)
 {
+    (void)val;
     if (crlf) {
 	printf("Will send carriage returns as telnet <CR><LF>.\n");
     } else {
@@ -719,7 +736,7 @@
 		    0 },
     { "crlf",
 	"sending carriage returns as telnet <CR><LF>",
-	    (int (*)(int))togcrlf,
+	    togcrlf,
 		&crlf,
 		    0 },
     { "crmod",
@@ -729,13 +746,13 @@
 		    "map carriage return on output" },
     { "localchars",
 	"local recognition of certain control characters",
-	    (int (*)(int))lclchars,
+	    lclchars,
 		&localchars,
 		    "recognize certain control characters" },
     { " ", "", NULL, NULL, NULL },		/* empty line */
     { "debug",
 	"debugging",
-	    (int (*)(int))togdebug,
+	    togdebug,
 		&telnet_debug,
 		    "turn on socket level debugging" },
     { "netdata",
@@ -760,23 +777,24 @@
 		    "print hexadecimal representation of terminal traffic" },
     { "?",
 	NULL,
-	    (int (*)(int))togglehelp,
+	    togglehelp,
 		NULL,
 		    NULL },
     { NULL, NULL, NULL, NULL, NULL },
     { "help",
 	NULL,
-	    (int (*)(int))togglehelp,
+	    togglehelp,
 		NULL,
 		    NULL },
     { NULL, NULL, NULL, NULL, NULL }
 };
 
 static int
-togglehelp(void)
+togglehelp(int val)
 {
     struct togglelist *c;
 
+    (void)val;
     for (c = Togglelist; c->name; c++) {
 	if (c->help) {
 	    if (*c->help)
@@ -855,7 +873,7 @@
  */
 
 #ifdef	USE_TERMIO
-struct termio new_tc = { 0, 0, 0, 0, {}, 0, 0 };
+struct termio new_tc = {0};
 #endif
 
 struct setlist {
@@ -1055,8 +1073,9 @@
 extern int kludgelinemode;
 
 static int
-dokludgemode(void)
+dokludgemode(int val)
 {
+    (void)val;
     kludgelinemode = 1;
     send_wont(TELOPT_LINEMODE, 1);
     send_dont(TELOPT_SGA, 1);
@@ -1066,8 +1085,9 @@
 #endif
 
 static int
-dolinemode(void)
+dolinemode(int val)
 {
+    (void)val;
 #ifdef	KLUDGELINEMODE
     if (kludgelinemode)
 	send_dont(TELOPT_SGA, 1);
@@ -1078,8 +1098,9 @@
 }
 
 static int
-docharmode(void)
+docharmode(int val)
 {
+    (void)val;
 #ifdef	KLUDGELINEMODE
     if (kludgelinemode)
 	send_do(TELOPT_SGA, 1);
@@ -1131,11 +1152,11 @@
 };
 
 static struct modelist ModeList[] = {
-    { "character", "Disable LINEMODE option",	(int (*)(int))docharmode, 1, 0 },
+    { "character", "Disable LINEMODE option",	docharmode, 1, 0 },
 #ifdef	KLUDGELINEMODE
     { "",	"(or disable obsolete line-by-line mode)", NULL, 0, 0 },
 #endif
-    { "line",	"Enable LINEMODE option",	(int (*)(int))dolinemode, 1, 0 },
+    { "line",	"Enable LINEMODE option",	dolinemode, 1, 0 },
 #ifdef	KLUDGELINEMODE
     { "",	"(or enable obsolete line-by-line mode)", NULL, 0, 0 },
 #endif
@@ -1153,21 +1174,22 @@
     { "litecho", "Enable literal character echo", setmod, 1, MODE_LIT_ECHO },
     { "+litecho", 0,				setmod, 1, MODE_LIT_ECHO },
     { "-litecho", "Disable literal character echo", clearmode, 1, MODE_LIT_ECHO },
-    { "help",	0,				(int (*)(int))modehelp, 0, 0 },
+    { "help",	0,				modehelp, 0, 0 },
 #ifdef	KLUDGELINEMODE
-    { "kludgeline", 0,				(int (*)(int))dokludgemode, 1, 0 },
+    { "kludgeline", 0,				dokludgemode, 1, 0 },
 #endif
     { "", "", NULL, 0, 0 },
-    { "?",	"Print help information",	(int (*)(int))modehelp, 0, 0 },
+    { "?",	"Print help information",	modehelp, 0, 0 },
     { NULL, NULL, NULL, 0, 0 },
 };
 
 
 static int
-modehelp(void)
+modehelp(int val)
 {
     struct modelist *mt;
 
+    (void)val;
     printf("format is:  'mode Mode', where 'Mode' is one of:\n\n");
     for (mt = ModeList; mt->name; mt++) {
 	if (mt->help) {
@@ -1301,8 +1323,9 @@
 }
 
 static int
-togcrmod(void)
+togcrmod(int v, char **p)
 {
+    (void)v; (void)p;
     crmod = !crmod;
     printf("Deprecated usage - please use 'toggle crmod' in the future.\n");
     printf("%s map carriage return on output.\n", crmod ? "Will" : "Won't");
@@ -1311,8 +1334,9 @@
 }
 
 static int
-suspend(void)
+suspend(int v, char **p)
 {
+	(void)v; (void)p;
 #ifdef	SIGTSTP
     setcommandmode();
     {
@@ -1340,7 +1364,7 @@
 }
 
 static int
-shell(int argc, char *argv[] __unused)
+shell(int argc, char *argv[] __attribute__((unused)))
 {
     long oldrows, oldcols, newrows, newcols, err_;
 
@@ -1419,8 +1443,17 @@
 }
 
 static int
-logout(void)
+quitf(int v, char **p)
 {
+	(void)v; (void)p;
+	quit();
+	return -1;
+}
+
+static int
+logout(int v, char **p)
+{
+	(void)v; (void)p;
 	send_do(TELOPT_LOGOUT, 1);
 	(void) netflush();
 	return 1;
@@ -1438,24 +1471,30 @@
 	int	arg;
 };
 
-static void slc_help(void);
+static void slc_help(int);
 
+static void slc_mode_exportf(int v) {
+    (void)v;
+    slc_mode_export();
+}
+
 struct slclist SlcList[] = {
     { "export",	"Use local special character definitions",
-						(void (*)(int))slc_mode_export,	0 },
+						slc_mode_exportf,	0 },
     { "import",	"Use remote special character definitions",
 						slc_mode_import,	1 },
     { "check",	"Verify remote special character definitions",
 						slc_mode_import,	0 },
-    { "help",	NULL,				(void (*)(int))slc_help,		0 },
-    { "?",	"Print help information",	(void (*)(int))slc_help,		0 },
+    { "help",	NULL,				slc_help,		0 },
+    { "?",	"Print help information",	slc_help,		0 },
     { NULL, NULL, NULL, 0 },
 };
 
 static void
-slc_help(void)
+slc_help(int v)
 {
     struct slclist *c;
+    (void)v;
 
     for (c = SlcList; c->name; c++) {
 	if (c->help) {
@@ -1507,49 +1546,54 @@
 struct envlist {
 	const char	*name;
 	const char	*help;
-	void	(*handler)(unsigned char *, unsigned char *);
+	void	(*handler)(char *, char *);
 	int	narg;
 };
 
-extern struct env_lst *
-	env_define(const unsigned char *, unsigned char *);
-extern void
-	env_undefine(unsigned char *),
-	env_export(const unsigned char *),
-	env_unexport(const unsigned char *),
-	env_send(unsigned char *),
+static struct env_lst *
+	env_define(const char *, char *);
+static void
+	env_undefine(char *, char *),
+	env_export(char *, char *),
+	env_unexport(char *, char *),
+	env_send(char *, char *),
 #if defined(OLD_ENVIRON) && defined(ENV_HACK)
-	env_varval(unsigned char *),
+	env_varval(char *, char *),
 #endif
-	env_list(void);
+	env_list(char *, char *);
 static void
-	env_help(void);
+	env_help(char *, char *);
 
+static void envf_define(char *a, char *b) {
+    env_define(a, b);
+}
+
 struct envlist EnvList[] = {
     { "define",	"Define an environment variable",
-						(void (*)(unsigned char *, unsigned char *))env_define,	2 },
+						envf_define,	2 },
     { "undefine", "Undefine an environment variable",
-						(void (*)(unsigned char *, unsigned char *))env_undefine,	1 },
+						env_undefine,	1 },
     { "export",	"Mark an environment variable for automatic export",
-						(void (*)(unsigned char *, unsigned char *))env_export,	1 },
+						env_export,	1 },
     { "unexport", "Don't mark an environment variable for automatic export",
-						(void (*)(unsigned char *, unsigned char *))env_unexport,	1 },
-    { "send",	"Send an environment variable", (void (*)(unsigned char *, unsigned char *))env_send,	1 },
+						env_unexport,	1 },
+    { "send",	"Send an environment variable", env_send,	1 },
     { "list",	"List the current environment variables",
-						(void (*)(unsigned char *, unsigned char *))env_list,	0 },
+						env_list,	0 },
 #if defined(OLD_ENVIRON) && defined(ENV_HACK)
     { "varval", "Reverse VAR and VALUE (auto, right, wrong, status)",
-						(void (*)(unsigned char *, unsigned char *))env_varval,    1 },
+						env_varval,    1 },
 #endif
-    { "help",	NULL,				(void (*)(unsigned char *, unsigned char *))env_help,		0 },
-    { "?",	"Print help information",	(void (*)(unsigned char *, unsigned char *))env_help,		0 },
+    { "help",	NULL,				env_help,		0 },
+    { "?",	"Print help information",	env_help,		0 },
     { NULL, NULL, NULL, 0 },
 };
 
 static void
-env_help(void)
+env_help(char *var, char *val)
 {
     struct envlist *c;
+    (void)var; (void)val;
 
     for (c = EnvList; c->name; c++) {
 	if (c->help) {
@@ -1603,8 +1647,8 @@
 struct env_lst {
 	struct env_lst *next;	/* pointer to next structure */
 	struct env_lst *prev;	/* pointer to previous structure */
-	unsigned char *var;	/* pointer to variable name */
-	unsigned char *value;	/* pointer to variable value */
+	char *var;	/* pointer to variable name */
+	char *value;	/* pointer to variable value */
 	int export;		/* 1 -> export with default list of variables */
 	int welldefined;	/* A well defined variable */
 };
@@ -1612,7 +1656,7 @@
 struct env_lst envlisthead;
 
 static struct env_lst *
-env_find(const unsigned char *var)
+env_find(const char *var)
 {
 	struct env_lst *ep;
 
@@ -1633,8 +1677,7 @@
 	for (epp = environ; *epp; epp++) {
 		if ((cp = strchr(*epp, '='))) {
 			*cp = '\0';
-			ep = env_define((unsigned char *)*epp,
-					(unsigned char *)cp+1);
+			ep = env_define(*epp, cp+1);
 			ep->export = 0;
 			*cp = '=';
 		}
@@ -1655,7 +1698,7 @@
 		asprintf(&cp, "%s%s", hbuf, cp2);
 		assert(cp != NULL);
 		free(ep->value);
-		ep->value = (unsigned char *)cp;
+		ep->value = cp;
 	}
 	/*
 	 * If USER is not defined, but LOGNAME is, then add
@@ -1664,14 +1707,14 @@
 	 */
 	if ((env_find("USER") == NULL) && (ep = env_find("LOGNAME"))) {
 		env_define("USER", ep->value);
-		env_unexport("USER");
+		env_unexport("USER", NULL);
 	}
-	env_export("DISPLAY");
-	env_export("PRINTER");
+	env_export("DISPLAY", NULL);
+	env_export("PRINTER", NULL);
 }
 
-struct env_lst *
-env_define(const unsigned char *var, unsigned char *value)
+static struct env_lst *
+env_define(const char *var, char *value)
 {
 	struct env_lst *ep;
 
@@ -1695,10 +1738,11 @@
 	return(ep);
 }
 
-void
-env_undefine(unsigned char *var)
+static void
+env_undefine(char *var, char *val)
 {
 	struct env_lst *ep;
+	(void)val;
 
 	if ((ep = env_find(var))) {
 		ep->prev->next = ep->next;
@@ -1712,28 +1756,31 @@
 	}
 }
 
-void
-env_export(const unsigned char *var)
+static void
+env_export(char *var, char *val)
 {
 	struct env_lst *ep;
+	(void)val;
 
 	if ((ep = env_find(var)))
 		ep->export = 1;
 }
 
-void
-env_unexport(const unsigned char *var)
+static void
+env_unexport(char *var, char *val)
 {
 	struct env_lst *ep;
+	(void)val;
 
 	if ((ep = env_find(var)))
 		ep->export = 0;
 }
 
-void
-env_send(unsigned char *var)
+static void
+env_send(char *var, char *val)
 {
 	struct env_lst *ep;
+	(void)val;
 
 	if (my_state_is_wont(TELOPT_NEW_ENVIRON)
 #ifdef	OLD_ENVIRON
@@ -1752,14 +1799,15 @@
 		return;
 	}
 	env_opt_start_info();
-	env_opt_add(ep->var);
+	env_opt_add((unsigned char *)ep->var);
 	env_opt_end(0);
 }
 
-void
-env_list(void)
+static void
+env_list(char *var, char *val)
 {
 	struct env_lst *ep;
+	(void)var; (void)val;
 
 	for (ep = envlisthead.next; ep; ep = ep->next) {
 		printf("%c %-20s %s\n", ep->export ? '*' : ' ',
@@ -1779,7 +1827,7 @@
 	if (nep) {
 		while ((nep = nep->next)) {
 			if (nep->export && (nep->welldefined == welldefined))
-				return(nep->var);
+				return (unsigned char *)(nep->var);
 		}
 	}
 	return(NULL);
@@ -1790,22 +1838,23 @@
 {
 	struct env_lst *ep;
 
-	if ((ep = env_find(var)))
-		return(ep->value);
+	if ((ep = env_find((char *)var)))
+		return (unsigned char *)(ep->value);
 	return(NULL);
 }
 
 #if defined(OLD_ENVIRON) && defined(ENV_HACK)
-void
-env_varval(unsigned char *what)
+static void
+env_varval(char *what, char *val)
 {
 	extern int old_env_var, old_env_value, env_auto;
-	int len = strlen((char *)what);
+	int len = strlen(what);
+	(void)val;
 
 	if (len == 0)
 		goto unknown;
 
-	if (strncasecmp((char *)what, "status", len) == 0) {
+	if (strncasecmp(what, "status", len) == 0) {
 		if (env_auto)
 			printf("%s%s", "VAR and VALUE are/will be ",
 					"determined automatically\n");
@@ -1813,15 +1862,15 @@
 			printf("VAR and VALUE set to correct definitions\n");
 		else
 			printf("VAR and VALUE definitions are reversed\n");
-	} else if (strncasecmp((char *)what, "auto", len) == 0) {
+	} else if (strncasecmp(what, "auto", len) == 0) {
 		env_auto = 1;
 		old_env_var = OLD_ENV_VALUE;
 		old_env_value = OLD_ENV_VAR;
-	} else if (strncasecmp((char *)what, "right", len) == 0) {
+	} else if (strncasecmp(what, "right", len) == 0) {
 		env_auto = 0;
 		old_env_var = OLD_ENV_VAR;
 		old_env_value = OLD_ENV_VALUE;
-	} else if (strncasecmp((char *)what, "wrong", len) == 0) {
+	} else if (strncasecmp(what, "wrong", len) == 0) {
 		env_auto = 0;
 		old_env_var = OLD_ENV_VALUE;
 		old_env_value = OLD_ENV_VAR;
@@ -1851,15 +1900,24 @@
 static int
 	auth_help(void);
 
+static int auth_statusf(char *p) {
+    (void)p;
+    return auth_status();
+}
+static int auth_helpf(char *p) {
+    (void)p;
+    return auth_help();
+}
+
 struct authlist AuthList[] = {
     { "status",	"Display current status of authentication information",
-						(int (*)(char *))auth_status,	0 },
+						auth_statusf,	0 },
     { "disable", "Disable an authentication type ('auth disable ?' for more)",
 						auth_disable,	1 },
     { "enable", "Enable an authentication type ('auth enable ?' for more)",
 						auth_enable,	1 },
-    { "help",	NULL,				(int (*)(char *))auth_help,		0 },
-    { "?",	"Print help information",	(int (*)(char *))auth_help,		0 },
+    { "help",	NULL,				auth_helpf,		0 },
+    { "?",	"Print help information",	auth_helpf,		0 },
     { NULL, NULL, NULL, 0 },
 };
 
@@ -1941,6 +1999,39 @@
 static int
 	EncryptHelp(void);
 
+static int EncryptStartf(char *a, char *b) {
+    (void)b;
+    return EncryptStart(a);
+}
+static int EncryptStartInputf(char *a, char *b) {
+    (void)a; (void)b;
+    return EncryptStartInput();
+}
+static int EncryptStartOutputf(char *a, char *b) {
+    (void)a; (void)b;
+    return EncryptStartOutput();
+}
+static int EncryptStopf(char *a, char *b) {
+    (void)b;
+    return EncryptStop(a);
+}
+static int EncryptStopInputf(char *a, char *b) {
+    (void)a; (void)b;
+    return EncryptStopInput();
+}
+static int EncryptStopOutputf(char *a, char *b) {
+    (void)a; (void)b;
+    return EncryptStopOutput();
+}
+static int EncryptStatusf(char *a, char *b) {
+    (void)a; (void)b;
+    return EncryptStatus();
+}
+static int EncryptHelpf(char *a, char *b) {
+    (void)a; (void)b;
+    return EncryptHelp();
+}
+
 struct encryptlist EncryptList[] = {
     { "enable", "Enable encryption. ('encrypt enable ?' for more)",
 						EncryptEnable, 1, 1, 2 },
@@ -1949,22 +2040,22 @@
     { "type", "Set encryption type. ('encrypt type ?' for more)",
 						EncryptType, 0, 1, 1 },
     { "start", "Start encryption. ('encrypt start ?' for more)",
-						(int (*)(char *, char *))EncryptStart, 1, 0, 1 },
+						EncryptStartf, 1, 0, 1 },
     { "stop", "Stop encryption. ('encrypt stop ?' for more)",
-						(int (*)(char *, char *))EncryptStop, 1, 0, 1 },
+						EncryptStopf, 1, 0, 1 },
     { "input", "Start encrypting the input stream",
-						(int (*)(char *, char *))EncryptStartInput, 1, 0, 0 },
+						EncryptStartInputf, 1, 0, 0 },
     { "-input", "Stop encrypting the input stream",
-						(int (*)(char *, char *))EncryptStopInput, 1, 0, 0 },
+						EncryptStopInputf, 1, 0, 0 },
     { "output", "Start encrypting the output stream",
-						(int (*)(char *, char *))EncryptStartOutput, 1, 0, 0 },
+						EncryptStartOutputf, 1, 0, 0 },
     { "-output", "Stop encrypting the output stream",
-						(int (*)(char *, char *))EncryptStopOutput, 1, 0, 0 },
+						EncryptStopOutputf, 1, 0, 0 },
 
     { "status",	"Display current status of authentication information",
-						(int (*)(char *, char *))EncryptStatus,	0, 0, 0 },
-    { "help",	NULL,				(int (*)(char *, char *))EncryptHelp,	0, 0, 0 },
-    { "?",	"Print help information",	(int (*)(char *, char *))EncryptHelp,	0, 0, 0 },
+						EncryptStatusf,	0, 0, 0 },
+    { "help",	NULL,				EncryptHelpf,	0, 0, 0 },
+    { "?",	"Print help information",	EncryptHelpf,	0, 0, 0 },
     { NULL, NULL, NULL, 0, 0, 0 },
 };
 
@@ -2170,7 +2261,7 @@
 {
     unsigned char *srp = 0;
     int proto, opt;
-    int srlen;
+    int srlen = 0;
     int srcroute = 0, result;
     char *cmd, *hostp = 0, *portp = 0, *user = 0;
     char *src_addr = NULL;
@@ -2263,7 +2354,8 @@
 	hostname = hostp;
 	memset(&su, 0, sizeof su);
 	su.sun_family = AF_UNIX;
-	strncpy(su.sun_path, hostp, sizeof su.sun_path);
+	strncpy(su.sun_path, hostp, sizeof su.sun_path - 1);
+	su.sun_path[sizeof su.sun_path - 1] = '\0';
 	if (!quiet_mode)
 	    printf("Trying %s...\n", hostp);
 	net = socket(PF_UNIX, SOCK_STREAM, 0);
@@ -2325,7 +2417,7 @@
         int gni_err = 1;
 
 	if (doaddrlookup)
-	    gni_err = getnameinfo(res->ai_addr, res->ai_addr->sa_len,
+	    gni_err = getnameinfo(res->ai_addr, res->ai_addrlen,
 				  _hostname, sizeof(_hostname) - 1, NULL, 0,
 				  NI_NAMEREQD);
 	if (gni_err != 0)
@@ -2445,13 +2537,16 @@
 
 	if (connect(net, res->ai_addr, res->ai_addrlen) < 0) {
 	    struct addrinfo *next;
+	    const char *addr;
 
 	    next = res->ai_next;
 	    /* If already an af failed, only try same af. */
-	    if (af_error != 0)
-		while (next != NULL && next->ai_family != res->ai_family)
-		    next = next->ai_next;
-	    warn("connect to address %s", sockaddr_ntop(res->ai_addr));
+	    if (af_error != 0) {
+			while (next != NULL && next->ai_family != res->ai_family)
+			    next = next->ai_next;
+		}
+		addr = sockaddr_ntop(res->ai_addr);
+	    warn("connect to address %s", addr ? addr : "(null)");
 	    if (next != NULL) {
 		res = next;
 		(void) NetClose(net);
@@ -2488,7 +2583,7 @@
     }
     if (user) {
 	env_define("USER", user);
-	env_export("USER");
+	env_export("USER", NULL);
     }
     (void) call(status, "status", "notmuch", 0);
     telnet(user); 
@@ -2537,12 +2632,12 @@
 
 static Command cmdtab[] = {
 	{ "close",	closehelp,	bye,		1 },
-	{ "logout",	logouthelp,	(int (*)(int, char **))logout,		1 },
+	{ "logout",	logouthelp,	logout,		1 },
 	{ "display",	displayhelp,	display,	0 },
 	{ "mode",	modestring,	modecmd,	0 },
 	{ "telnet",	openhelp,	tn,		0 },
 	{ "open",	openhelp,	tn,		0 },
-	{ "quit",	quithelp,	(int (*)(int, char **))quit,		0 },
+	{ "quit",	quithelp,	quitf,		0 },
 	{ "send",	sendhelp,	sendcmd,	0 },
 	{ "set",	sethelp,	setcmd,		0 },
 	{ "unset",	unsethelp,	unsetcmd,	0 },
@@ -2555,7 +2650,7 @@
 #ifdef	ENCRYPTION
 	{ "encrypt",	encrypthelp,	encrypt_cmd,	0 },
 #endif	/* ENCRYPTION */
-	{ "z",		zhelp,		(int (*)(int, char **))suspend,	0 },
+	{ "z",		zhelp,		suspend,	0 },
 	{ "!",		shellhelp,	shell,		1 },
 	{ "environ",	envhelp,	env_cmd,	0 },
 	{ "?",		helphelp,	help,		0 },
@@ -2571,7 +2666,7 @@
 static Command cmdtab2[] = {
 	{ "help",	0,		help,		0 },
 	{ "escape",	escapehelp,	setescape,	0 },
-	{ "crmod",	crmodhelp,	(int (*)(int, char **))togcrmod,	0 },
+	{ "crmod",	crmodhelp,	togcrmod,	0 },
 	{ NULL, NULL, NULL, 0 }
 };
 
@@ -2708,6 +2803,11 @@
 static char *rcname = 0;
 static char rcbuf[128];
 
+static void safe_strncpy(char *dest, const char *source, size_t num) {
+    memmove(dest, source, num);
+    dest[num] = '\0';
+}
+
 void
 cmdrc(char *m1, char *m2)
 {
@@ -2753,11 +2853,11 @@
 	    if (isspace(line[0]))
 		continue;
 	    if (strncasecmp(line, m1, l1) == 0)
-		strncpy(line, &line[l1], sizeof(line) - l1);
+		safe_strncpy(line, &line[l1], sizeof(line) - l1);
 	    else if (strncasecmp(line, m2, l2) == 0)
-		strncpy(line, &line[l2], sizeof(line) - l2);
+		safe_strncpy(line, &line[l2], sizeof(line) - l2);
 	    else if (strncasecmp(line, "DEFAULT", 7) == 0)
-		strncpy(line, &line[7], sizeof(line) - 7);
+		safe_strncpy(line, &line[7], sizeof(line) - 7);
 	    else
 		continue;
 	    if (line[0] != ' ' && line[0] != '\t' && line[0] != '\n')
@@ -2852,9 +2952,11 @@
 	unsigned char *cp, *cp2, *lsrp, *ep;
 	struct sockaddr_in *_sin;
 #ifdef INET6
+#ifndef INET6_NO_RTHDR
 	struct sockaddr_in6 *sin6;
-	struct ip6_rthdr *rth;
 #endif
+	struct ip6_rthdr *rth = NULL;
+#endif
 	struct addrinfo hints, *res;
 	int error;
 	char c;
@@ -2866,7 +2968,7 @@
 	if (cpp == NULL || lenp == NULL)
 		return -1;
 	if (*cpp != NULL) {
-		switch (res->ai_family) {
+		switch (ai->ai_family) {
 		case AF_INET:
 			if (*lenp < 7)
 				return -1;
@@ -2888,14 +2990,17 @@
 		lsrp = *cpp;
 		ep = lsrp + *lenp;
 	} else {
-		*cpp = lsrp = (char *)ALIGN(buf);
+		*cpp = lsrp = (unsigned char *)ALIGN(buf);
 		ep = lsrp + 1024;
 	}
 
-	cp = arg;
+	cp = (unsigned char *)arg;
 
 #ifdef INET6
 	if (ai->ai_family == AF_INET6) {
+#ifdef INET6_NO_RTHDR
+		return -1;
+#else
 		if ((rth = inet6_rth_init((void *)*cpp, sizeof(buf),
 					  IPV6_RTHDR_TYPE_0, 0)) == NULL)
 			return -1;
@@ -2903,6 +3008,7 @@
 			return -1;
 		*protop = IPPROTO_IPV6;
 		*optp = IPV6_RTHDR;
+#endif
 	} else
 #endif
       {
@@ -2958,10 +3064,10 @@
 			cp2 = 0;
 
 		hints.ai_flags = AI_NUMERICHOST;
-		error = getaddrinfo(cp, NULL, &hints, &res);
+		error = getaddrinfo((char *)cp, NULL, &hints, &res);
 		if (error == EAI_NONAME) {
 			hints.ai_flags = 0;
-			error = getaddrinfo(cp, NULL, &hints, &res);
+			error = getaddrinfo((char *)cp, NULL, &hints, &res);
 		}
 		if (error != 0) {
 			fprintf(stderr, "%s: %s\n", cp, gai_strerror(error));
@@ -2973,9 +3079,13 @@
 		}
 #ifdef INET6
 		if (res->ai_family == AF_INET6) {
+#ifdef INET6_NO_RTHDR
+			return -1;
+#else
 			sin6 = (struct sockaddr_in6 *)res->ai_addr;
 			if (inet6_rth_add((void *)rth, &sin6->sin6_addr) == -1)
 				return(0);
+#endif
 		} else
 #endif
 	      {
--- src.orig/telnet/telnet/externs.h
+++ src.freebsd/telnet/telnet/externs.h
@@ -68,7 +68,7 @@
 #include <string.h>
 
 #if defined(IPSEC)
-#include <netipsec/ipsec.h>
+#include <linux/ipsec.h>
 #if defined(IPSEC_POLICY_IPSEC)
 extern char *ipsec_policy_in;
 extern char *ipsec_policy_out;
--- src.orig/telnet/telnet/main.c
+++ src.freebsd/telnet/telnet/main.c
@@ -34,6 +34,7 @@
 #endif
 
 #include <sys/param.h>
+#include <sys/types.h>
 #include <sys/socket.h>
 #include <stdlib.h>
 #include <string.h>
--- src.orig/telnet/telnet/ring.c
+++ src.freebsd/telnet/telnet/ring.c
@@ -47,6 +47,7 @@
 #include	<errno.h>
 #include	<stdio.h>
 #include	<string.h>
+#include <stdint.h>
 
 #ifdef	size_t
 #undef	size_t
@@ -177,7 +178,7 @@
 	ring->clearto = 0;
     else if (ring->consume + count > ring->top &&
 		ring->bottom <= ring->clearto &&
-		ring->bottom + ((ring->consume + count) - ring->top))
+		(uintptr_t)ring->bottom + (uintptr_t)((ring->consume + count) - ring->top))
 	ring->clearto = 0;
 #endif	/* ENCRYPTION */
     ring->consume = ring_increment(ring, ring->consume, count);
--- src.orig/telnet/telnet/sys_bsd.c
+++ src.freebsd/telnet/telnet/sys_bsd.c
@@ -39,6 +39,7 @@
  */
 
 #include <sys/param.h>
+#include <sys/types.h>
 #include <sys/socket.h>
 #include <sys/time.h>
 #include <err.h>
@@ -71,7 +72,7 @@
 # define old_tc ottyb
 
 #else	/* USE_TERMIO */
-struct	termio old_tc = { 0, 0, 0, 0, {}, 0, 0 };
+struct	termio old_tc = {0};
 
 # ifndef	TCSANOW
 #  ifdef TCSETS
@@ -648,7 +649,12 @@
 #ifdef	SIGTSTP
 	(void) signal(SIGTSTP, SIG_DFL);
 # ifndef SOLARIS
-	(void) sigsetmask(sigblock(0) & ~(1<<(SIGTSTP-1)));
+	{
+		sigset_t sigs;
+		sigemptyset (&sigs);
+		sigaddset (&sigs, SIGTSTP);
+		sigprocmask (SIG_UNBLOCK, &sigs, 0);
+	}
 # else	/* SOLARIS */
 	(void) sigrelse(SIGTSTP);
 # endif	/* SOLARIS */
@@ -740,7 +746,7 @@
 
 /* ARGSUSED */
 SIG_FUNC_RET
-intr(int sig __unused)
+intr(int sig __attribute__((unused)))
 {
     if (localchars) {
 	intp();
@@ -752,7 +758,7 @@
 
 /* ARGSUSED */
 SIG_FUNC_RET
-intr2(int sig __unused)
+intr2(int sig __attribute__((unused)))
 {
     if (localchars) {
 #ifdef	KLUDGELINEMODE
@@ -768,7 +774,7 @@
 #ifdef	SIGTSTP
 /* ARGSUSED */
 SIG_FUNC_RET
-susp(int sig __unused)
+susp(int sig __attribute__((unused)))
 {
     if ((rlogin != _POSIX_VDISABLE) && rlogin_susp())
 	return;
@@ -780,7 +786,7 @@
 #ifdef	SIGWINCH
 /* ARGSUSED */
 static SIG_FUNC_RET
-sendwin(int sig __unused)
+sendwin(int sig __attribute__((unused)))
 {
     if (connected) {
 	sendnaws();
@@ -791,7 +797,7 @@
 #ifdef	SIGINFO
 /* ARGSUSED */
 SIG_FUNC_RET
-ayt(int sig __unused)
+ayt(int sig __attribute__((unused)))
 {
     if (connected)
 	sendayt();
@@ -1031,7 +1037,7 @@
      */
     if (FD_ISSET(tin, ibitsp)) {
 	FD_CLR(tin, ibitsp);
-	c = TerminalRead(ttyiring.supply, ring_empty_consecutive(&ttyiring));
+	c = TerminalRead((char *)ttyiring.supply, ring_empty_consecutive(&ttyiring));
 	if (c < 0 && errno == EIO)
 	    c = 0;
 	if (c < 0 && errno == EWOULDBLOCK) {
--- src.orig/telnet/telnet/telnet.c
+++ src.freebsd/telnet/telnet/telnet.c
@@ -40,8 +40,15 @@
  * declared in curses.h.
  */
 
-#include <ctype.h>
+#ifdef HAVE_NCURSESW_NCURSES_H
+#include <ncursesw/ncurses.h>
+#elif defined HAVE_NCURSES_H
+#include <ncurses.h>
+#else
 #include <curses.h>
+#endif
+
+#include <ctype.h>
 #include <signal.h>
 #include <stdlib.h>
 #include <term.h>
@@ -206,7 +213,7 @@
 void
 DoBaudRate(char *arg)
 {
-    char *temp, temp2[11];
+    char *temp, temp2[16];
     int i;
     uint32_t baudrate;
 
@@ -216,14 +223,14 @@
 	ExitString("Invalid baud rate provided.\n", 1);
 
     for (i = 1; termspeeds[i].speed != -1; i++)
-	if (baudrate == termspeeds[i].speed)
+	if ((int)baudrate == termspeeds[i].speed)
 	    break;
     if (termspeeds[i].speed == -1)
 	ExitString("Invalid baud rate provided.\n", 1);
 
-    strlcpy(ComPortBaudRate, arg, sizeof(ComPortBaudRate));
+    strlcpy((char *)ComPortBaudRate, arg, sizeof(ComPortBaudRate));
 
-    if (NETROOM() < sizeof(temp2)) {
+    if (NETROOM() < (int)sizeof(temp2)) {
 	ExitString("No room in buffer for baud rate.\n", 1);
 	/* NOTREACHED */
     }
@@ -233,8 +240,8 @@
 
     baudrate = htonl(baudrate);
     memcpy(&temp2[4], &baudrate, sizeof(baudrate));
-    ring_supply_data(&netoring, temp2, sizeof(temp2));
-    printsub('>', &temp[2], sizeof(temp2) - 2);
+    ring_supply_data(&netoring, (unsigned char *)temp2, sizeof(temp2));
+    printsub('>', (unsigned char *)&temp[2], sizeof(temp2) - 2);
 }
 
 void
@@ -384,8 +391,9 @@
 	    case TELOPT_SGA:
 		if (!kludgelinemode)
 		    break;
-		/* FALLTHROUGH */
+		goto telopt_echo;
 #endif
+	    telopt_echo:
 	    case TELOPT_ECHO:
 		settimer(modenegotiated);
 		break;
@@ -475,7 +483,7 @@
 #endif
 
 	    case TELOPT_XDISPLOC:	/* X Display location */
-		if (env_getvalue("DISPLAY"))
+		if (env_getvalue((unsigned char *)"DISPLAY"))
 		    new_state_ok = 1;
 		break;
 
@@ -728,7 +736,7 @@
 		resettermname = 0;
 		if (tnamep && tnamep != unknown)
 			free(tnamep);
-		if ((tname = env_getvalue("TERM")) &&
+		if ((tname = (char *)env_getvalue((unsigned char *)"TERM")) &&
 				(setupterm(tname, 1, &err) == 0)) {
 			tnamep = mklist(termbuf, tname);
 		} else {
@@ -773,7 +781,7 @@
 	    return;
 	} else {
 	    const char *name;
-	    unsigned char temp[50];
+	    char temp[50];
 	    int len;
 
 	    name = gettermname();
@@ -781,8 +789,8 @@
 	    if (len < NETROOM()) {
 		snprintf(temp, sizeof(temp), "%c%c%c%c%s%c%c", IAC, SB, TELOPT_TTYPE,
 				TELQUAL_IS, name, IAC, SE);
-		ring_supply_data(&netoring, temp, len);
-		printsub('>', &temp[2], len-2);
+		ring_supply_data(&netoring, (unsigned char *)temp, len);
+		printsub('>', (unsigned char *)&temp[2], len-2);
 	    } else {
 		ExitString("No room in buffer for terminal type.\n", 1);
 		/*NOTREACHED*/
@@ -796,18 +804,18 @@
 	    return;
 	if (SB_GET() == TELQUAL_SEND) {
 	    long ospeed, ispeed;
-	    unsigned char temp[50];
+	    char temp[50];
 	    int len;
 
 	    TerminalSpeeds(&ispeed, &ospeed);
 
-	    snprintf((char *)temp, sizeof(temp), "%c%c%c%c%ld,%ld%c%c", IAC, SB, TELOPT_TSPEED,
+	    snprintf(temp, sizeof(temp), "%c%c%c%c%ld,%ld%c%c", IAC, SB, TELOPT_TSPEED,
 		    TELQUAL_IS, ospeed, ispeed, IAC, SE);
-	    len = strlen((char *)temp+4) + 4;	/* temp[3] is 0 ... */
+	    len = strlen(temp+4) + 4;	/* temp[3] is 0 ... */
 
 	    if (len < NETROOM()) {
-		ring_supply_data(&netoring, temp, len);
-		printsub('>', temp+2, len - 2);
+		ring_supply_data(&netoring, (unsigned char *)temp, len);
+		printsub('>', (unsigned char *)&temp[2], len - 2);
 	    }
 /*@*/	    else printf("lm_will: not enough room in buffer\n");
 	}
@@ -895,10 +903,10 @@
 	if (SB_EOF())
 	    return;
 	if (SB_GET() == TELQUAL_SEND) {
-	    unsigned char temp[50], *dp;
+	    char temp[50], *dp;
 	    int len;
 
-	    if ((dp = env_getvalue("DISPLAY")) == NULL ||
+	    if ((dp = (char *)env_getvalue((unsigned char *)"DISPLAY")) == NULL ||
 		strlen(dp) > sizeof(temp) - 7) {
 		/*
 		 * Something happened, we no longer have a DISPLAY
@@ -909,11 +917,11 @@
 	    }
 	    snprintf(temp, sizeof(temp), "%c%c%c%c%s%c%c", IAC, SB,
 		    TELOPT_XDISPLOC, TELQUAL_IS, dp, IAC, SE);
-	    len = strlen((char *)temp+4) + 4;	/* temp[3] is 0 ... */
+	    len = strlen(temp+4) + 4;	/* temp[3] is 0 ... */
 
 	    if (len < NETROOM()) {
-		ring_supply_data(&netoring, temp, len);
-		printsub('>', temp+2, len - 2);
+		ring_supply_data(&netoring, (unsigned char *)temp, len);
+		printsub('>', (unsigned char *)&temp[2], len - 2);
 	    }
 /*@*/	    else printf("lm_will: not enough room in buffer\n");
 	}
@@ -1582,7 +1590,7 @@
 		opt_replyp = opt_reply + len - (opt_replyend - opt_replyp);
 		opt_replyend = opt_reply + len;
 	}
-	if (opt_welldefined(ep))
+	if (opt_welldefined((const char *)ep))
 #ifdef	OLD_ENVIRON
 		if (telopt_environ == TELOPT_OLD_ENVIRON)
 			*opt_replyp++ = old_env_var;
@@ -1951,7 +1959,7 @@
 				continue;
 			}
 			if (sc == escape) {
-				command(0, tbp, tcc);
+				command(0, (const char *)tbp, tcc);
 				bol = 1;
 				count += tcc;
 				tcc = 0;
@@ -2101,7 +2109,7 @@
 #ifdef	AUTHENTICATION
 #define __unusedhere
 #else
-#define __unusedhere __unused
+#define __unusedhere __attribute__((unused))
 #endif
 /*
  * Select from tty and network...
@@ -2142,7 +2150,7 @@
 	send_will(TELOPT_LINEMODE, 1);
 	send_will(TELOPT_NEW_ENVIRON, 1);
 	send_do(TELOPT_STATUS, 1);
-	if (env_getvalue("DISPLAY"))
+	if (env_getvalue((unsigned char *)"DISPLAY"))
 	    send_will(TELOPT_XDISPLOC, 1);
 	if (eight)
 	    tel_enter_binary(eight);
@@ -2271,7 +2279,7 @@
 }
 
 int
-dosynch(char *ch __unused)
+dosynch(char *ch __attribute__((unused)))
 {
     netclear();			/* clear the path to the network */
     NETADD(IAC);
@@ -2284,7 +2292,7 @@
 int want_status_response = 0;
 
 int
-get_status(char *ch __unused)
+get_status(char *ch __attribute__((unused)))
 {
     unsigned char tmp[16];
     unsigned char *cp;
--- src.orig/telnet/telnet/terminal.c
+++ src.freebsd/telnet/telnet/terminal.c
@@ -126,7 +126,7 @@
 	    TerminalFlushOutput();
 	    /* we leave 'n' alone! */
 	} else {
-	    n = TerminalWrite(ttyoring.consume, n);
+	    n = TerminalWrite((char *)ttyoring.consume, n);
 	}
     }
     if (n > 0) {
@@ -141,7 +141,7 @@
 	if (n1 == n && n0 > n) {
 		n1 = n0 - n;
 		if (!drop)
-			n1 = TerminalWrite(ttyoring.bottom, n1);
+			n1 = TerminalWrite((char *)ttyoring.bottom, n1);
 		if (n1 > 0)
 			n += n1;
 	}
--- src.orig/telnet/telnet/utilities.c
+++ src.freebsd/telnet/telnet/utilities.c
@@ -433,7 +433,7 @@
 			((pointer[3] & AUTH_HOW_MASK) == AUTH_HOW_MUTUAL) ?
 			"MUTUAL" : "ONE-WAY");
 
-		auth_printsub(&pointer[1], length - 1, buf, sizeof(buf));
+		auth_printsub(&pointer[1], length - 1, (unsigned char *)buf, sizeof(buf));
 		fprintf(NetTrace, "%s", buf);
 		break;
 
@@ -511,7 +511,7 @@
 		else
 		    fprintf(NetTrace, " %d (unknown)", pointer[2]);
 
-		encrypt_printsub(&pointer[1], length - 1, buf, sizeof(buf));
+		encrypt_printsub(&pointer[1], length - 1, (unsigned char *)buf, sizeof(buf));
 		fprintf(NetTrace, "%s", buf);
 		break;
 
--- src.orig/tip/getcap.c
+++ src.freebsd/tip/getcap.c
@@ -34,7 +34,6 @@
 
 #include <sys/cdefs.h>
 __SCCSID("@(#)getcap.c	8.3 (Berkeley) 3/25/94");
-#include "namespace.h"
 #include <sys/types.h>
 
 #include <ctype.h>
@@ -45,9 +44,8 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
-#include "un-namespace.h"
 
-#include <db.h>
+#include "getcap.h"
 
 #define	BFRAG		1024
 #define	BSIZE		1024
@@ -63,7 +61,6 @@
 static char	*toprec;	/* Additional record specified by cgetset() */
 static int	 gottoprec;	/* Flag indicating retrieval of toprecord */
 
-static int	cdbget(DB *, char **, const char *);
 static int 	getent(char **, u_int *, char **, int, const char *, int, char *);
 static int	nfcmp(char *, char *);
 
@@ -185,12 +182,10 @@
 getent(char **cap, u_int *len, char **db_array, int fd, const char *name,
     int depth, char *nfield)
 {
-	DB *capdbp;
 	char *r_end, *rp, **db_p;
-	int myfd, eof, foundit, retval;
-	char *record, *cbuf;
+	int myfd, eof, foundit;
+	char *record;
 	int tc_not_resolved;
-	char pbuf[_POSIX_PATH_MAX];
 
 	/*
 	 * Return with ``loop detected'' error if we've recursed more than
@@ -238,6 +233,7 @@
 			(void)lseek(fd, (off_t)0, SEEK_SET);
 			myfd = 0;
 		} else {
+#if 0
 			(void)snprintf(pbuf, sizeof(pbuf), "%s.db", *db_p);
 			if ((capdbp = dbopen(pbuf, O_RDONLY, 0, DB_HASH, 0))
 			     != NULL) {
@@ -261,8 +257,10 @@
 				*len = strlen(cbuf);
 				*cap = cbuf;
 				return (retval);
-			} else {
-				fd = _open(*db_p, O_RDONLY | O_CLOEXEC, 0);
+			} else
+#endif
+			{
+				fd = open(*db_p, O_RDONLY | O_CLOEXEC, 0);
 				if (fd < 0)
 					continue;
 				myfd = 1;
@@ -297,10 +295,10 @@
 				if (bp >= b_end) {
 					int n;
 
-					n = _read(fd, buf, sizeof(buf));
+					n = read(fd, buf, sizeof(buf));
 					if (n <= 0) {
 						if (myfd)
-							(void)_close(fd);
+							(void)close(fd);
 						if (n < 0) {
 							free(record);
 							return (-2);
@@ -339,7 +337,7 @@
 					if (record == NULL) {
 						errno = ENOMEM;
 						if (myfd)
-							(void)_close(fd);
+							(void)close(fd);
 						return (-2);
 					}
 					r_end = record + newsize;
@@ -431,7 +429,7 @@
 				/* an error */
 				if (iret < -1) {
 					if (myfd)
-						(void)_close(fd);
+						(void)close(fd);
 					free(record);
 					return (iret);
 				}
@@ -481,7 +479,7 @@
 				if (record == NULL) {
 					errno = ENOMEM;
 					if (myfd)
-						(void)_close(fd);
+						(void)close(fd);
 					free(icap);
 					return (-2);
 				}
@@ -513,7 +511,7 @@
 	 * return capability, length and success.
 	 */
 	if (myfd)
-		(void)_close(fd);
+		(void)close(fd);
 	*len = rp - record - 1;	/* don't count NUL */
 	if (r_end > rp)
 		if ((record =
@@ -528,6 +526,7 @@
 	return (0);
 }
 
+#if 0
 static int
 cdbget(DB *capdbp, char **bp, const char *name)
 {
@@ -563,6 +562,7 @@
 	free(namebuf);
 	return (((char *)(data.data))[0] == TCERR ? 1 : 0);
 }
+#endif
 
 /*
  * Cgetmatch will return 0 if name is one of the names of the capability
@@ -611,7 +611,7 @@
 
 
 
-
+#if 0
 int
 cgetfirst(char **buf, char **db_array)
 {
@@ -768,6 +768,7 @@
 	}
 	/* NOTREACHED */
 }
+#endif
 
 /*
  * Cgetstr retrieves the value of the string capability cap from the
@@ -895,6 +896,7 @@
 	return (len);
 }
 
+#if 0
 /*
  * Cgetustr retrieves the value of the string capability cap from the
  * capability record pointed to by buf.  The difference between cgetustr()
@@ -966,6 +968,7 @@
 	*str = mem;
 	return (len);
 }
+#endif
 
 /*
  * Cgetnum retrieves the value of the numeric capability cap from the
--- src.orig/tip/getcap.h
+++ src.freebsd/tip/getcap.h
@@ -0,0 +1,11 @@
+#ifndef GETCAP_H
+#define GETCAP_H
+
+char *cgetcap(char *, const char *, int);
+int cgetent(char **, char **, const char *);
+int cgetmatch(const char *, const char *);
+int cgetnum(char *, const char *, long *);
+int cgetset(const char *);
+int cgetstr(char *, const char *, char **);
+
+#endif
--- src.orig/tip/libacu/courier.c
+++ src.freebsd/tip/libacu/courier.c
@@ -124,9 +124,13 @@
 cour_disconnect(void)
 {
 	 /* first hang up the modem*/
-	ioctl(FD, TIOCCDTR, 0);
+	int flags = 0;
+	ioctl(FD, TIOCMGET, &flags);
+	flags &= ~TIOCM_DTR;
+	ioctl(FD, TIOCMSET, &flags);
 	sleep(1);
-	ioctl(FD, TIOCSDTR, 0);
+	flags |= TIOCM_DTR;
+	ioctl(FD, TIOCMSET, &flags);
 	coursync();				/* reset */
 	close(FD);
 }
@@ -270,7 +274,7 @@
 coursync(void)
 {
 	int already = 0;
-	int len;
+	int len, flags = 0;
 	char buf[40];
 
 	while (already++ < MAXRETRY) {
@@ -300,9 +304,12 @@
 		 * Toggle DTR to force anyone off that might have left
 		 * the modem connected.
 		 */
-		ioctl(FD, TIOCCDTR, 0);
+		ioctl(FD, TIOCMGET, &flags);
+		flags &= ~TIOCM_DTR;
+		ioctl(FD, TIOCMSET, &flags);
 		sleep(1);
-		ioctl(FD, TIOCSDTR, 0);
+		flags |= TIOCM_DTR;
+		ioctl(FD, TIOCMSET, &flags);
 	}
 	cour_write(FD, "\rAT Z\r", 6);
 	return (0);
--- src.orig/tip/libacu/dn11.c
+++ src.freebsd/tip/libacu/dn11.c
@@ -130,8 +130,12 @@
 dn_disconnect(void)
 {
 	sleep(2);
-	if (FD > 0)
-		ioctl(FD, TIOCCDTR, 0);
+	if (FD > 0) {
+		int flags = 0;
+		ioctl(FD, TIOCMGET, &flags);
+		flags &= ~TIOCM_DTR;
+		ioctl(FD, TIOCMSET, &flags);
+	}
 	close(FD);
 }
 
@@ -143,7 +147,11 @@
 		kill(child, SIGKILL);
 	if (dn > 0)
 		close(dn);
-	if (FD > 0)
-		ioctl(FD, TIOCCDTR, 0);
+	if (FD > 0) {
+		int flags = 0;
+		ioctl(FD, TIOCMGET, &flags);
+		flags &= ~TIOCM_DTR;
+		ioctl(FD, TIOCMSET, &flags);
+	}
 	close(FD);
 }
--- src.orig/tip/libacu/hayes.c
+++ src.freebsd/tip/libacu/hayes.c
@@ -147,12 +147,16 @@
 hay_disconnect(void)
 {
 	/* first hang up the modem*/
+	int flags = 0;
 #ifdef DEBUG
 	printf("\rdisconnecting modem....\n\r");
 #endif
-	ioctl(FD, TIOCCDTR, 0);
+	ioctl(FD, TIOCMGET, &flags);
+	flags &= ~TIOCM_DTR;
+	ioctl(FD, TIOCMSET, &flags);
 	sleep(1);
-	ioctl(FD, TIOCSDTR, 0);
+	flags |= TIOCM_DTR;
+	ioctl(FD, TIOCMSET, &flags);
 	goodbye();
 }
 
@@ -251,7 +255,7 @@
 static void
 goodbye(void)
 {
-	int len;
+	int len, flags = 0;
 	char c;
 
 	tcflush(FD, TCIOFLUSH);
@@ -287,7 +291,9 @@
 #endif
 	}
 	tcflush(FD, TCIOFLUSH);
-	ioctl(FD, TIOCCDTR, 0);		/* clear DTR (insurance) */
+	ioctl(FD, TIOCMGET, &flags);
+	flags &= ~TIOCM_DTR; /* clear DTR (insurance) */
+	ioctl(FD, TIOCMSET, &flags);
 	close(FD);
 }
 
@@ -296,7 +302,7 @@
 static int
 hay_sync(void)
 {
-	int len, retry = 0;
+	int len, retry = 0, flags = 0;
 
 	while (retry++ <= MAXRETRY) {
 		write(FD, "AT\r", 3);
@@ -312,8 +318,11 @@
 			printf("hay_sync: (\"%s\") %d\n\r", dumbuf, retry);
 #endif
 		}
-		ioctl(FD, TIOCCDTR, 0);
-		ioctl(FD, TIOCSDTR, 0);
+		ioctl(FD, TIOCMGET, &flags);
+		flags &= ~TIOCM_DTR;
+		ioctl(FD, TIOCMSET, &flags);
+		flags |= TIOCM_DTR;
+		ioctl(FD, TIOCMSET, &flags);
 	}
 	printf("Cannot synchronize with hayes...\n\r");
 	return(0);
--- src.orig/tip/libacu/t3000.c
+++ src.freebsd/tip/libacu/t3000.c
@@ -125,9 +125,13 @@
 t3000_disconnect(void)
 {
 	 /* first hang up the modem*/
-	ioctl(FD, TIOCCDTR, 0);
+	int flags = 0;
+	ioctl(FD, TIOCMGET, &flags);
+	flags &= ~TIOCM_DTR;
+	ioctl(FD, TIOCMSET, &flags);
 	sleep(1);
-	ioctl(FD, TIOCSDTR, 0);
+	flags |= TIOCM_DTR;
+	ioctl(FD, TIOCMSET, &flags);
 	t3000_sync();				/* reset */
 	close(FD);
 }
@@ -285,7 +289,7 @@
 t3000_sync(void)
 {
 	int already = 0;
-	int len;
+	int len, flags = 0;
 	char buf[40];
 
 	while (already++ < MAXRETRY) {
@@ -318,9 +322,12 @@
 		 * Toggle DTR to force anyone off that might have left
 		 * the modem connected.
 		 */
-		ioctl(FD, TIOCCDTR, 0);
+		ioctl(FD, TIOCMGET, &flags);
+		flags &= ~TIOCM_DTR;
+		ioctl(FD, TIOCMSET, &flags);
 		sleep(1);
-		ioctl(FD, TIOCSDTR, 0);
+		flags |= TIOCM_DTR;
+		ioctl(FD, TIOCMSET, &flags);
 	}
 	t3000_write(FD, "\rAT Z\r", 6);
 	return (0);
--- src.orig/tip/libacu/v831.c
+++ src.freebsd/tip/libacu/v831.c
@@ -139,7 +139,10 @@
         printf("[disconnect: FD=%d]\n", FD);
 #endif
         if (FD > 0) {
-                ioctl(FD, TIOCCDTR, 0);
+		int flags = 0;
+		ioctl(FD, TIOCMGET, &flags);
+		flags &= ~TIOCM_DTR;
+		ioctl(FD, TIOCMSET, &flags);
 		tcgetattr(FD, &cntrl);
 		cfsetospeed(&cntrl, 0);
 		cfsetispeed(&cntrl, 0);
@@ -161,8 +164,12 @@
         if (FD > 0)
                 ioctl(FD, TIOCNXCL, NULL);
         close(AC);
-        if (FD > 0)
-                ioctl(FD, TIOCCDTR, 0);
+        if (FD > 0) {
+                int flags = 0;
+                ioctl(FD, TIOCMGET, &flags);
+                flags &= ~TIOCM_DTR;
+                ioctl(FD, TIOCMSET, &flags);
+        }
         close(FD);
 }
 
--- src.orig/tip/libacu/ventel.c
+++ src.freebsd/tip/libacu/ventel.c
@@ -218,7 +218,7 @@
 static int
 vensync(int fd)
 {
-	int already = 0, nread;
+	int already = 0, nread, flags = 0;
 	char buf[60];
 
 	/*
@@ -229,9 +229,12 @@
 	 * If you don't have the ioctl calls to diddle directly
 	 * with DTR, you can always try setting the baud rate to 0.
 	 */
-	ioctl(FD, TIOCCDTR, 0);
+	ioctl(FD, TIOCMGET, &flags);
+	flags &= ~TIOCM_DTR;
+	ioctl(FD, TIOCMSET, &flags);
 	sleep(1);
-	ioctl(FD, TIOCSDTR, 0);
+	flags |= TIOCM_DTR;
+	ioctl(FD, TIOCMSET, &flags);
 	while (already < MAXRETRY) {
 		/*
 		 * After reseting the modem, send it two \r's to
--- src.orig/tip/remote.5
+++ src.freebsd/tip/remote.5
@@ -189,7 +189,7 @@
 is retrieved from the environment).
 .Bd -literal
 UNIX-57600:\e
-:dv=/dev/cuau0:el=^D^U^C^S^Q^O@:oe=^D:du:at=hayes:br#115200:pa=none:
+:dv=/dev/ttyS0:el=^D^U^C^S^Q^O@:oe=^D:du:at=hayes:br#115200:pa=none:
 arpavax|ax:\e
 :pn=\e@:tc=UNIX-57600
 .Ed
--- src.orig/tip/tip/acu.c
+++ src.freebsd/tip/tip/acu.c
@@ -117,7 +117,7 @@
 			tried++;
 		}
 	} else {
-		if ((fd = fopen(PH, "r")) == NOFILE) {
+		if ((fd = fopen(PH, "r")) == NULL) {
 			printf("%s: ", PH);
 			return ("can't open phone number file");
 		}
--- src.orig/tip/tip/cmds.c
+++ src.freebsd/tip/tip/cmds.c
@@ -620,7 +620,7 @@
 	/*
 	 * enable TIPOUT side for dialogue
 	 */
-	kill(tipout_pid, SIGEMT);
+	kill(tipout_pid, SIGBUS);
 	if (boolean(value(SCRIPT)))
 		write(fildes[1], value(RECORD), size(value(RECORD)));
 	write(fildes[1], "\n", 1);
@@ -958,8 +958,7 @@
 	close(pivec[1]);
 	l = read(pivec[0], xname, BUFSIZ);
 	close(pivec[0]);
-	while (wait(&s) != pid);
-		;
+	while (wait(&s) != pid) {}
 	s &= 0377;
 	if (s != 0 && s != SIGPIPE) {
 		fprintf(stderr, "\"Echo\" failed\n");
--- src.orig/tip/tip/cu.1
+++ src.freebsd/tip/tip/cu.1
@@ -68,9 +68,9 @@
 .It Fl l Ar line
 Specify the line to use.
 Either of the forms like
-.Pa cuau0
+.Pa ttyS0
 or
-.Pa /dev/cuau0
+.Pa /dev/ttyS0
 are permitted.
 .It Fl o
 Use odd parity.
@@ -486,17 +486,17 @@
 .Dq Li /bin/sh .
 .El
 .Sh FILES
-.Bl -tag -width ".Pa /var/spool/lock/LCK..*" -compact
+.Bl -tag -width ".Pa /var/lock/LCK..*" -compact
 .It Pa /var/log/aculog
 line access log
-.It Pa /var/spool/lock/LCK..*
+.It Pa /var/lock/LCK..*
 lock file to avoid conflicts with
 .Xr uucp 1 Pq Pa ports/net/freebsd-uucp
 .El
 .Sh EXAMPLES
 Connect to the first USB serial port at the speed of 115200 baud:
 .Bd -literal -offset indent
-cu -s 115200 -l /dev/cuaU0
+cu -s 115200 -l /dev/ttyUSB0
 .Ed
 .Sh SEE ALSO
 .Xr tip 1
--- src.orig/tip/tip/pathnames.h
+++ src.freebsd/tip/tip/pathnames.h
@@ -37,6 +37,6 @@
 #include <paths.h>
 
 #define	_PATH_ACULOG		"/var/log/aculog"
-#define	_PATH_LOCKDIRNAME	"/var/spool/lock/LCK..%s"
+#define	_PATH_LOCKDIRNAME	"/var/lock/LCK..%s"
 #define	_PATH_PHONES		"/etc/phones"
 #define	_PATH_REMOTE		"/etc/remote"
--- src.orig/tip/tip/phones
+++ src.freebsd/tip/tip/phones
@@ -1,5 +1,3 @@
-#	From: @(#)phones	5.2 (Berkeley) 6/30/90
-#
 # phones -- remote host phone number data base
 # see tip(1), phones(5)
 # examples:
--- src.orig/tip/tip/remote
+++ src.freebsd/tip/tip/remote
@@ -1,6 +1,3 @@
-#
-#	@(#)remote	5.2 (Berkeley) 6/30/90
-#
 # remote -- remote host description file
 # see tip(1), remote(5)
 #
@@ -51,25 +48,25 @@
 dial14400|14400 Baud Hayes attributes:\
 	br#57600:tc=dial:
 dial|Generic dialing parameters:\
-	:dv=/dev/cuau0:cu=/dev/cuau0:at=hayes:du:pa=none:
+	:dv=/dev/ttyS0:cu=/dev/ttyS0:at=hayes:du:pa=none:
 
 # Hardwired line
 cuau0c|cua0c:dv=/dev/cuau0:br#9600:pa=none:
 
 # Finger friendly shortcuts
-uart0|com1:dv=/dev/cuau0:br#9600:pa=none:
-uart1|com2:dv=/dev/cuau1:br#9600:pa=none:
-uart2|com3:dv=/dev/cuau2:br#9600:pa=none:
-uart3|com4:dv=/dev/cuau3:br#9600:pa=none:
-uart4|com5:dv=/dev/cuau4:br#9600:pa=none:
-uart5|com6:dv=/dev/cuau5:br#9600:pa=none:
-uart6|com7:dv=/dev/cuau6:br#9600:pa=none:
-uart7|com8:dv=/dev/cuau7:br#9600:pa=none:
-ucom1:dv=/dev/cuaU0:br#9600:pa=none:
-ucom2:dv=/dev/cuaU1:br#9600:pa=none:
-ucom3:dv=/dev/cuaU2:br#9600:pa=none:
-ucom4:dv=/dev/cuaU3:br#9600:pa=none:
-ucom5:dv=/dev/cuaU4:br#9600:pa=none:
-ucom6:dv=/dev/cuaU5:br#9600:pa=none:
-ucom7:dv=/dev/cuaU6:br#9600:pa=none:
-ucom8:dv=/dev/cuaU7:br#9600:pa=none:
+uart0|com1:dv=/dev/ttyS0:br#9600:pa=none:
+uart1|com2:dv=/dev/ttyS1:br#9600:pa=none:
+uart2|com3:dv=/dev/ttyS2:br#9600:pa=none:
+uart3|com4:dv=/dev/ttyS3:br#9600:pa=none:
+uart4|com5:dv=/dev/ttyS4:br#9600:pa=none:
+uart5|com6:dv=/dev/ttyS5:br#9600:pa=none:
+uart6|com7:dv=/dev/ttyS6:br#9600:pa=none:
+uart7|com8:dv=/dev/ttyS7:br#9600:pa=none:
+ucom1:dv=/dev/ttyUSB0:br#9600:pa=none:
+ucom2:dv=/dev/ttyUSB1:br#9600:pa=none:
+ucom3:dv=/dev/ttyUSB2:br#9600:pa=none:
+ucom4:dv=/dev/ttyUSB3:br#9600:pa=none:
+ucom5:dv=/dev/ttyUSB4:br#9600:pa=none:
+ucom6:dv=/dev/ttyUSB5:br#9600:pa=none:
+ucom7:dv=/dev/ttyUSB6:br#9600:pa=none:
+ucom8:dv=/dev/ttyUSB7:br#9600:pa=none:
--- src.orig/tip/tip/remote.c
+++ src.freebsd/tip/tip/remote.c
@@ -52,6 +52,7 @@
 
 #include "pathnames.h"
 #include "tip.h"
+#include "getcap.h"
 
 /*
  * Attributes to be gleened from remote host description
@@ -126,7 +127,7 @@
 	if (!BR && (cgetnum(bp, "br", &BR) == -1))
 		BR = DEFBR;
 	if (!LD && (cgetnum(bp, "ld", &LD) == -1))
-		LD = TTYDISC;
+		LD = N_TTY;
 	if (cgetnum(bp, "fs", &FS) == -1)
 		FS = DEFFS;
 	if (DU < 0)
--- src.orig/tip/tip/tip.1
+++ src.freebsd/tip/tip/tip.1
@@ -569,7 +569,7 @@
 .Dq Li /bin/sh .
 .El
 .Sh FILES
-.Bl -tag -width ".Pa /var/spool/lock/LCK..*" -compact
+.Bl -tag -width ".Pa /var/lock/LCK..*" -compact
 .It Pa ~/.tiprc
 initialization file
 .It Pa tip.record
@@ -584,7 +584,7 @@
 database
 .It Pa /var/log/aculog
 line access log
-.It Pa /var/spool/lock/LCK..*
+.It Pa /var/lock/LCK..*
 lock file to avoid conflicts with
 .Xr uucp 1 Pq Pa ports/net/freebsd-uucp
 .El
--- src.orig/tip/tip/tip.c
+++ src.freebsd/tip/tip/tip.c
@@ -56,7 +56,7 @@
 #include "tip.h"
 #include "pathnames.h"
 
-int	disc = TTYDISC;		/* tip normally runs this way */
+int	disc = N_TTY;		/* tip normally runs this way */
 char	PNbuf[256];			/* This limits the size of a number */
 
 static void	intprompt(int);
@@ -226,14 +226,13 @@
 	term.c_cc[VTIME] = 0;
 	defchars = term;
 	term.c_cc[VINTR] = term.c_cc[VQUIT] = term.c_cc[VSUSP] =
-	    term.c_cc[VDSUSP] = term.c_cc[VDISCARD] =
-	    term.c_cc[VLNEXT] = _POSIX_VDISABLE;
+	    term.c_cc[VDISCARD] = term.c_cc[VLNEXT] = _POSIX_VDISABLE;
 	raw();
 
 	pipe(fildes); pipe(repdes);
 	(void)signal(SIGALRM, timeout);
 
-	if (value(LINEDISC) != TTYDISC) {
+	if (value(LINEDISC) != N_TTY) {
 		int ld = (int)(intptr_t)value(LINEDISC);
 		ioctl(FD, TIOCSETD, &ld);
 	}		
@@ -391,7 +390,7 @@
 	 * Kinda klugey here...
 	 *   check for scripting being turned on from the .tiprc file,
 	 *   but be careful about just using setscript(), as we may
-	 *   send a SIGEMT before tipout has a chance to set up catching
+	 *   send a SIGBUS before tipout has a chance to set up catching
 	 *   it; so wait a second, then setscript()
 	 */
 	if (boolean(value(SCRIPT))) {
@@ -548,6 +547,20 @@
 	}
 }
 
+static const int baudlist[] = {
+	0, 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400,
+	4800, 9600, 19200, 38400, 57600, 115200, 230400, 460800, 500000,
+	576000, 921600,	1000000, 1152000, 1500000, 2000000, 2500000,
+	3000000, 3500000, 4000000,
+};
+
+static const speed_t baudvals[] = {
+	B0, B50, B75, B110, B134, B150, B200, B300, B600, B1200, B1800, B2400,
+	B4800, B9600, B19200, B38400, B57600, B115200, B230400, B460800, B500000,
+	B576000, B921600, B1000000, B1152000, B1500000, B2000000, B2500000,
+	B3000000, B3500000, B4000000,
+};
+
 /*
  * Set up the "remote" tty's state
  */
@@ -555,10 +568,16 @@
 ttysetup(int speed)
 {
 	struct termios	cntrl;
-
-	if (tcgetattr(FD, &cntrl))
+	speed_t aspeed = B0;
+	for (size_t i = 0; i < (sizeof(baudlist) / sizeof(int)); ++i) {
+		if (baudlist[i] == speed) {
+			aspeed = baudvals[i];
+			break;
+		}
+	}
+	if ((aspeed == B0) || tcgetattr(FD, &cntrl))
 		return (-1);
-	cfsetspeed(&cntrl, speed);
+	cfsetspeed(&cntrl, aspeed);
 	cntrl.c_cflag &= ~(CSIZE|PARENB);
 	cntrl.c_cflag |= CS8;
 	if (boolean(value(DC)))
--- src.orig/tip/tip/tip.h
+++ src.freebsd/tip/tip/tip.h
@@ -42,20 +42,24 @@
 #include <sys/types.h>
 #include <sys/file.h>
 #include <sys/time.h>
+#include <sys/stat.h>
 #include <sys/wait.h>
 #include <sys/ioctl.h>
+#include <sys/ttydefaults.h>
 
 #include <termios.h>
 #include <signal.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <fcntl.h>
 #include <pwd.h>
 #include <ctype.h>
 #include <setjmp.h>
 #include <unistd.h>
 #include <errno.h>
 #include <limits.h>
+#include <time.h>
 
 #ifndef EXTERN
 #define	EXTERN	extern
@@ -235,7 +239,6 @@
 #define NOVAL	((value_t *)NULL)
 #define NOACU	((acu_t *)NULL)
 #define NOSTR	((char *)NULL)
-#define NOFILE	((FILE *)NULL)
 #define NOPWD	((struct passwd *)0)
 
 EXTERN struct termios	term;		/* current mode of terminal */
--- src.orig/tip/tip/tipout.c
+++ src.freebsd/tip/tip/tipout.c
@@ -136,7 +136,7 @@
 
 	signal(SIGINT, SIG_IGN);
 	signal(SIGQUIT, SIG_IGN);
-	signal(SIGEMT, intEMT);		/* attention from TIPIN */
+	signal(SIGBUS, intEMT);		/* attention from TIPIN */
 	signal(SIGTERM, intTERM);	/* time to go signal */
 	signal(SIGIOT, intIOT);		/* scripting going on signal */
 	signal(SIGHUP, intTERM);	/* for dial-ups */
@@ -160,7 +160,7 @@
 		}
 		cnt = scnt;
 		sigemptyset(&mask);
-		sigaddset(&mask, SIGEMT);
+		sigaddset(&mask, SIGBUS);
 		sigaddset(&mask, SIGTERM);
 		sigaddset(&mask, SIGIOT);
 		sigaddset(&mask, SIGSYS);
--- src.orig/tip/tip/uucplock.c
+++ src.freebsd/tip/tip/uucplock.c
@@ -41,8 +41,9 @@
 #endif /* not lint */
 
 #include <sys/types.h>
+#include <sys/param.h>
 #include <sys/file.h>
-#include <sys/dirent.h>
+#include <dirent.h>
 #include <stdio.h>
 #include <string.h>
 #include <signal.h>
--- src.orig/unvis/unvis.c
+++ src.freebsd/unvis/unvis.c
@@ -56,7 +56,6 @@
 	FILE *fp;
 	int ch, eflags = 0;
 
-	setprogname(argv[0]);
 	while ((ch = getopt(argc, argv, "eHhm")) != -1)
 		switch((char)ch) {
 		case 'e':
--- src.orig/util/fts.3
+++ src.freebsd/util/fts.3
@@ -38,7 +38,7 @@
 .Sh SYNOPSIS
 .In fts.h
 .Ft FTS *
-.Fn fts_open "char * const *path_argv" "int options" "int (*compar)(const FTSENT * const *, const FTSENT * const *)"
+.Fn fts_open "char * const *path_argv" "int options" "int (*compar)(const FTSENT **, const FTSENT **)"
 .Ft FTSENT *
 .Fn fts_read "FTS *ftsp"
 .Ft FTSENT *
--- src.orig/util/fts.c
+++ src.freebsd/util/fts.c
@@ -33,10 +33,10 @@
 
 #include <sys/cdefs.h>
 __SCCSID("@(#)fts.c	8.6 (Berkeley) 8/14/94");
-#include "namespace.h"
 #include <sys/param.h>
 #include <sys/mount.h>
 #include <sys/stat.h>
+#include <sys/vfs.h>
 
 #include <dirent.h>
 #include <errno.h>
@@ -45,9 +45,8 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
-#include "un-namespace.h"
 
-#include "gen-private.h"
+#if !defined(_CHIMERAUTILS_BUILD) || !defined(HAVE_FTS_OPEN)
 
 static FTSENT	*fts_alloc(FTS *, char *, size_t);
 static FTSENT	*fts_build(FTS *, int);
@@ -59,7 +58,6 @@
 static FTSENT	*fts_sort(FTS *, FTSENT *, size_t);
 static int	 fts_stat(FTS *, FTSENT *, int, int);
 static int	 fts_safe_changedir(FTS *, FTSENT *, int, char *);
-static int	 fts_ufslinks(FTS *, const FTSENT *);
 
 #define	ISDOT(a)	(a[0] == '.' && (!a[1] || (a[1] == '.' && !a[2])))
 
@@ -95,6 +93,7 @@
  * links and directories this way, so we must punt for others.
  */
 
+#if 0
 static const char *ufslike_filesystems[] = {
 	"ufs",
 	"zfs",
@@ -102,10 +101,22 @@
 	"ext2fs",
 	0
 };
+#endif
 
+/* so we don't have to expose this symbol in libchimera-util */
+static void *_reallocf(void *ptr, size_t size) {
+    void *nptr = realloc(ptr, size);
+    if (!nptr && ptr && size) {
+        free(ptr);
+    }
+    return nptr;
+}
+
+#define reallocf _reallocf
+
 FTS *
 fts_open(char * const *argv, int options,
-    int (*compar)(const FTSENT * const *, const FTSENT * const *))
+    int (*compar)(const FTSENT **, const FTSENT **))
 {
 	struct _fts_private *priv;
 	FTS *sp;
@@ -203,7 +214,7 @@
 	 * descriptor we run anyway, just more slowly.
 	 */
 	if (!ISSET(FTS_NOCHDIR) &&
-	    (sp->fts_rfd = _open(".", O_RDONLY | O_CLOEXEC, 0)) < 0)
+	    (sp->fts_rfd = open(".", O_RDONLY | O_CLOEXEC, 0)) < 0)
 		SET(FTS_NOCHDIR);
 
 	return (sp);
@@ -269,7 +280,7 @@
 	/* Return to original directory, save errno if necessary. */
 	if (!ISSET(FTS_NOCHDIR)) {
 		saved_errno = fchdir(sp->fts_rfd) ? errno : 0;
-		(void)_close(sp->fts_rfd);
+		(void)close(sp->fts_rfd);
 
 		/* Set errno and return. */
 		if (saved_errno != 0) {
@@ -328,7 +339,7 @@
 	    (p->fts_info == FTS_SL || p->fts_info == FTS_SLNONE)) {
 		p->fts_info = fts_stat(sp, p, 1, -1);
 		if (p->fts_info == FTS_D && !ISSET(FTS_NOCHDIR)) {
-			if ((p->fts_symfd = _open(".", O_RDONLY | O_CLOEXEC,
+			if ((p->fts_symfd = open(".", O_RDONLY | O_CLOEXEC,
 			    0)) < 0) {
 				p->fts_errno = errno;
 				p->fts_info = FTS_ERR;
@@ -344,7 +355,7 @@
 		if (instr == FTS_SKIP ||
 		    (ISSET(FTS_XDEV) && p->fts_dev != sp->fts_dev)) {
 			if (p->fts_flags & FTS_SYMFOLLOW)
-				(void)_close(p->fts_symfd);
+				(void)close(p->fts_symfd);
 			if (sp->fts_child) {
 				fts_lfree(sp->fts_child);
 				sp->fts_child = NULL;
@@ -421,7 +432,7 @@
 			p->fts_info = fts_stat(sp, p, 1, -1);
 			if (p->fts_info == FTS_D && !ISSET(FTS_NOCHDIR)) {
 				if ((p->fts_symfd =
-				    _open(".", O_RDONLY | O_CLOEXEC, 0)) < 0) {
+				    open(".", O_RDONLY | O_CLOEXEC, 0)) < 0) {
 					p->fts_errno = errno;
 					p->fts_info = FTS_ERR;
 				} else
@@ -468,12 +479,12 @@
 	} else if (p->fts_flags & FTS_SYMFOLLOW) {
 		if (FCHDIR(sp, p->fts_symfd)) {
 			saved_errno = errno;
-			(void)_close(p->fts_symfd);
+			(void)close(p->fts_symfd);
 			errno = saved_errno;
 			SET(FTS_STOP);
 			return (NULL);
 		}
-		(void)_close(p->fts_symfd);
+		(void)close(p->fts_symfd);
 	} else if (!(p->fts_flags & FTS_DONTCHDIR) &&
 	    fts_safe_changedir(sp, p->fts_parent, -1, "..")) {
 		SET(FTS_STOP);
@@ -494,6 +505,7 @@
 int
 fts_set(FTS *sp, FTSENT *p, int instr)
 {
+	(void)sp;
 	if (instr != 0 && instr != FTS_AGAIN && instr != FTS_FOLLOW &&
 	    instr != FTS_NOINSTR && instr != FTS_SKIP) {
 		errno = EINVAL;
@@ -560,14 +572,14 @@
 	    ISSET(FTS_NOCHDIR))
 		return (sp->fts_child = fts_build(sp, instr));
 
-	if ((fd = _open(".", O_RDONLY | O_CLOEXEC, 0)) < 0)
+	if ((fd = open(".", O_RDONLY | O_CLOEXEC, 0)) < 0)
 		return (NULL);
 	sp->fts_child = fts_build(sp, instr);
 	serrno = (sp->fts_child == NULL) ? errno : 0;
 	rc = fchdir(fd);
 	if (rc < 0 && serrno == 0)
 		serrno = errno;
-	(void)_close(fd);
+	(void)close(fd);
 	errno = serrno;
 	if (rc < 0)
 		return (NULL);
@@ -638,8 +650,10 @@
 	DIR *dirp;
 	void *oldaddr;
 	char *cp;
-	int cderrno, descend, oflag, saved_errno, nostat, doadjust,
-	    readdir_errno;
+	int cderrno, descend, saved_errno, nostat, doadjust, readdir_errno;
+#ifdef FTS_WHITEOUT
+	int oflag;
+#endif
 	long level;
 	long nlinks;	/* has to be signed because -1 is a magic value */
 	size_t dnamlen, len, maxlen, nitems;
@@ -677,10 +691,7 @@
 		/* Be quiet about nostat, GCC. */
 		nostat = 0;
 	} else if (ISSET(FTS_NOSTAT) && ISSET(FTS_PHYSICAL)) {
-		if (fts_ufslinks(sp, cur))
-			nlinks = cur->fts_nlink - (ISSET(FTS_SEEDOT) ? 0 : 2);
-		else
-			nlinks = -1;
+		nlinks = cur->fts_nlink - (ISSET(FTS_SEEDOT) ? 0 : 2);
 		nostat = 1;
 	} else {
 		nlinks = -1;
@@ -709,7 +720,7 @@
 	 */
 	cderrno = 0;
 	if (nlinks || type == BREAD) {
-		if (fts_safe_changedir(sp, cur, _dirfd(dirp), NULL)) {
+		if (fts_safe_changedir(sp, cur, dirfd(dirp), NULL)) {
 			if (nlinks && type == BREAD)
 				cur->fts_errno = errno;
 			cur->fts_flags |= FTS_DONTCHDIR;
@@ -748,7 +759,11 @@
 	readdir_errno = 0;
 	for (head = tail = NULL, nitems = 0;
 	    (dp = fts_safe_readdir(dirp, &readdir_errno));) {
+#if 0
 		dnamlen = dp->d_namlen;
+#else
+		dnamlen = strlen(dp->d_name);
+#endif
 		if (!ISSET(FTS_SEEDOT) && ISDOT(dp->d_name))
 			continue;
 
@@ -811,7 +826,7 @@
 			if (ISSET(FTS_NOCHDIR)) {
 				p->fts_accpath = p->fts_path;
 				memmove(cp, p->fts_name, p->fts_namelen + 1);
-				p->fts_info = fts_stat(sp, p, 0, _dirfd(dirp));
+				p->fts_info = fts_stat(sp, p, 0, dirfd(dirp));
 			} else {
 				p->fts_accpath = p->fts_name;
 				p->fts_info = fts_stat(sp, p, 0, -1);
@@ -990,7 +1005,7 @@
 	FTS *parent;
 
 	parent = (*(const FTSENT * const *)a)->fts_fts;
-	return (*parent->fts_compar)(a, b);
+	return (*parent->fts_compar)((const FTSENT **)a, (const FTSENT **)b);
 }
 
 static FTSENT *
@@ -1149,10 +1164,10 @@
 	newfd = fd;
 	if (ISSET(FTS_NOCHDIR))
 		return (0);
-	if (fd < 0 && (newfd = _open(path, O_RDONLY | O_DIRECTORY |
+	if (fd < 0 && (newfd = open(path, O_RDONLY | O_DIRECTORY |
 	    O_CLOEXEC, 0)) < 0)
 		return (-1);
-	if (_fstat(newfd, &sb)) {
+	if (fstat(newfd, &sb)) {
 		ret = -1;
 		goto bail;
 	}
@@ -1165,11 +1180,12 @@
 bail:
 	oerrno = errno;
 	if (fd < 0)
-		(void)_close(newfd);
+		(void)close(newfd);
 	errno = oerrno;
 	return (ret);
 }
 
+#if 0
 /*
  * Check if the filesystem for "ent" has UFS-style links.
  */
@@ -1203,3 +1219,6 @@
 	}
 	return (priv->ftsp_linksreliable);
 }
+#endif
+
+#endif
--- src.orig/util/rpmatch.3
+++ src.freebsd/util/rpmatch.3
@@ -32,7 +32,7 @@
 .Sh LIBRARY
 .Lb libc
 .Sh SYNOPSIS
-.In stdlib.h
+.In rpmatch.h
 .Ft int
 .Fn rpmatch "const char *response"
 .Sh DESCRIPTION
--- src.orig/util/rpmatch.c
+++ src.freebsd/util/rpmatch.c
@@ -29,7 +29,10 @@
 #include <langinfo.h>
 #include <regex.h>
 #include <stdlib.h>
+#include <rpmatch.h>
 
+#if !defined(_CHIMERAUTILS_BUILD) || !defined(HAVE_FTS_OPEN)
+
 int
 rpmatch(const char *response)
 {
@@ -52,3 +55,5 @@
 	regfree(&no);
 	return (ret);
 }
+
+#endif
