--- src.orig/awk/FIXES
+++ src.freebsd/awk/FIXES
@@ -23,7 +23,53 @@
 ****************************************************************/
 
 This file lists all bug fixes, changes, etc., made since the AWK book
-was sent to the printers in August, 1987.
++was sent to the printers in August 1987.
+ 
++Dec 15, 2022:
+	Force hex escapes in strings to be no more than two characters,
++	as they already are in regular expressions. This brings internal
+	consistency, as well as consistency with gawk. Thanks to
+	Arnold Robbins.
++
+Sep 12, 2022:
+	adjbuf minlen error (cannot be 0) in cat, resulting in NULL pbuf.
+	discovered by todd miller. also use-after-free issue with
+	tempfree in cat, thanks to Miguel Pineiro Jr and valgrind.
+
+Aug 30, 2022:
+	Various leaks and use-after-free issues plugged/fixed.
+	Thanks to Miguel Pineiro Jr. <mpj@pineiro.cc>.
+
+May 23, 2022:
+	Memory leak when assigning a string to some of the built-in
+	variables. allocated string erroneously marked DONTFREE.
+	Thanks to Miguel Pineiro Jr. <mpj@pineiro.cc>.
+
+Mar 14, 2022:
+	Historic bug: command-line "name=value" assignment had been
+	truncating its entry in ARGV. (circa 1989) Thanks to 
+	Miguel Pineiro Jr. <mpj@pineiro.cc>.
+
+Mar 3, 2022:
+	Fixed file management memory leak that appears to have been
+	there since the files array was first initialized with stdin,
+	stdout, and stderr (circa 1992). Thanks to Miguel Pineiro Jr.
+	<mpj@pineiro.cc>.
+
+December 8, 2021:
+	The error handling in closefile and closeall was mangled. Long
+	standing warnings had been made fatal and some fatal errors went
+	undetected. Thanks to Miguel Pineiro Jr. <mpj@pineiro.cc>.
+
+Nov 03, 2021:
+        getline accesses uninitialized data after getrec()
+	returns 0 on EOF and leaves the contents of buf unchanged.
+	Thanks to Volodymyr Gubarkov, and Todd C Miller.
+
+Oct 12, 2021:
+	The fix for #83 changed the code to insert 2 chars, but the
+	call to adjbuf just above it only allows for 1 char. This can
+	cause a heap buffer overflow.
 
 July 27, 2021:
 	As per IEEE Std 1003.1-2008, -F "str" is now consistent with
--- src.orig/awk/awk.h
+++ src.freebsd/awk/awk.h
@@ -37,7 +37,7 @@
 
 typedef	unsigned char uschar;
 
-#define	xfree(a)	{ if ((a) != NULL) { free((void *)(intptr_t)(a)); (a) = NULL; } }
+#define	xfree(a)	{ free((void *)(intptr_t)(a)); (a) = NULL; }
 /*
  * We sometimes cheat writing read-only pointers to NUL-terminate them
  * and then put back the original value
--- src.orig/awk/awkgram.y
+++ src.freebsd/awk/awkgram.y
@@ -206,9 +206,10 @@
 		{ $$ = op2(AND, notnull($1), notnull($3)); }
 	| ppattern MATCHOP reg_expr	{ $$ = op3($2, NIL, $1, (Node*)makedfa($3, 0)); }
 	| ppattern MATCHOP ppattern
-		{ if (constnode($3))
+		{ if (constnode($3)) {
 			$$ = op3($2, NIL, $1, (Node*)makedfa(strnode($3), 0));
-		  else
+			free($3);
+		  } else
 			$$ = op3($2, (Node *)1, $1, $3); }
 	| ppattern IN varname		{ $$ = op2(INTEST, $1, makearr($3)); }
 	| '(' plist ')' IN varname	{ $$ = op2(INTEST, $2, makearr($5)); }
@@ -233,9 +234,10 @@
 	| pattern NE pattern		{ $$ = op2($2, $1, $3); }
 	| pattern MATCHOP reg_expr	{ $$ = op3($2, NIL, $1, (Node*)makedfa($3, 0)); }
 	| pattern MATCHOP pattern
-		{ if (constnode($3))
+		{ if (constnode($3)) {
 			$$ = op3($2, NIL, $1, (Node*)makedfa(strnode($3), 0));
-		  else
+			free($3);
+		  } else
 			$$ = op3($2, (Node *)1, $1, $3); }
 	| pattern IN varname		{ $$ = op2(INTEST, $1, makearr($3)); }
 	| '(' plist ')' IN varname	{ $$ = op2(INTEST, $2, makearr($5)); }
@@ -378,17 +380,19 @@
 	| GENSUB '(' reg_expr comma pattern comma pattern ')'
 		{ $$ = op5(GENSUB, NIL, (Node*)makedfa($3, 1), $5, $7, rectonode()); }
 	| GENSUB '(' pattern comma pattern comma pattern ')'
-		{ if (constnode($3))
+		{ if (constnode($3)) {
 			$$ = op5(GENSUB, NIL, (Node *)makedfa(strnode($3), 1), $5, $7, rectonode());
-		  else
+			free($3);
+		  } else
 			$$ = op5(GENSUB, (Node *)1, $3, $5, $7, rectonode());
 		}
 	| GENSUB '(' reg_expr comma pattern comma pattern comma pattern ')'
 		{ $$ = op5(GENSUB, NIL, (Node*)makedfa($3, 1), $5, $7, $9); }
 	| GENSUB '(' pattern comma pattern comma pattern comma pattern ')'
-		{ if (constnode($3))
+		{ if (constnode($3)) {
 			$$ = op5(GENSUB, NIL, (Node *)makedfa(strnode($3),1), $5,$7,$9);
-		  else
+			free($3);
+		  } else
 			$$ = op5(GENSUB, (Node *)1, $3, $5, $7, $9);
 		}
 	| GETLINE var LT term		{ $$ = op3(GETLINE, $2, itonp($3), $4); }
@@ -404,9 +408,10 @@
 	| MATCHFCN '(' pattern comma reg_expr ')'
 		{ $$ = op3(MATCHFCN, NIL, $3, (Node*)makedfa($5, 1)); }
 	| MATCHFCN '(' pattern comma pattern ')'
-		{ if (constnode($5))
+		{ if (constnode($5)) {
 			$$ = op3(MATCHFCN, NIL, $3, (Node*)makedfa(strnode($5), 1));
-		  else
+			free($5);
+		  } else
 			$$ = op3(MATCHFCN, (Node *)1, $3, $5); }
 	| NUMBER			{ $$ = celltonode($1, CCON); }
 	| SPLIT '(' pattern comma varname comma pattern ')'     /* string */
@@ -420,16 +425,18 @@
 	| subop '(' reg_expr comma pattern ')'
 		{ $$ = op4($1, NIL, (Node*)makedfa($3, 1), $5, rectonode()); }
 	| subop '(' pattern comma pattern ')'
-		{ if (constnode($3))
+		{ if (constnode($3)) {
 			$$ = op4($1, NIL, (Node*)makedfa(strnode($3), 1), $5, rectonode());
-		  else
+			free($3);
+		  } else
 			$$ = op4($1, (Node *)1, $3, $5, rectonode()); }
 	| subop '(' reg_expr comma pattern comma var ')'
 		{ $$ = op4($1, NIL, (Node*)makedfa($3, 1), $5, $7); }
 	| subop '(' pattern comma pattern comma var ')'
-		{ if (constnode($3))
+		{ if (constnode($3)) {
 			$$ = op4($1, NIL, (Node*)makedfa(strnode($3), 1), $5, $7);
-		  else
+			free($3);
+		  } else
 			$$ = op4($1, (Node *)1, $3, $5, $7); }
 	| SUBSTR '(' pattern comma pattern comma pattern ')'
 		{ $$ = op3(SUBSTR, $3, $5, $7); }
--- src.orig/awk/b.c
+++ src.freebsd/awk/b.c
@@ -807,6 +807,7 @@
 		}
 		else
 			FATAL("syntax error in regular expression %s at %s", lastre, prestr);
+		/* FALLTHROUGH */
 	default:
 		FATAL("illegal primary in regular expression %s at %s", lastre, prestr);
 	}
@@ -1101,7 +1102,7 @@
 					 * program to track each string's length.
 					 */
 					for (i = 1; i <= UCHAR_MAX; i++) {
-						if (!adjbuf((char **) &buf, &bufsz, bp-buf+1, 100, (char **) &bp, "relex2"))
+						if (!adjbuf((char **) &buf, &bufsz, bp-buf+2, 100, (char **) &bp, "relex2"))
 						    FATAL("out of space for reg expr %.10s...", lastre);
 						if (cc->cc_func(i)) {
 							/* escape backslash */
--- src.orig/awk/bugs
+++ src.freebsd/awk/bugs
@@ -0,0 +1,29 @@
+normal status 42
+death by signal status 257
+death by signal with core dump status 518
+normal status 42
+death by signal status 0.00390625
+death by signal with core dump status 0.523438
+# Unmodified nawk prints the 16 bit exit status divided by 256, but
+# does so using floating point arithmetic, yielding strange results.
+#
+# The fix is to use the various macros defined for wait(2) and to
+# use the signal number + 256 for death by signal, or signal number + 512
+# for death by signal with core dump.
+
+BEGIN {
+	status = system("exit 42")
+	print "normal status", status
+
+	status = system("kill -HUP $$")
+	print "death by signal status", status
+
+	status = system("kill -ABRT $$")
+	print "death by signal with core dump status", status
+
+	system("rm -f core*")
+}
+../a.out: cannot set NF to a negative value
+ source line number 1
+../a.out: not enough args in printf(%*s)
+ source line number 1
--- src.orig/awk/bugs
+++ src.freebsd/awk/bugs
@@ -0,0 +1,2 @@
+../a.out: not enough args in printf(%*s)
+ source line number 1
--- src.orig/awk/bugs
+++ src.freebsd/awk/bugs
@@ -0,0 +1,2 @@
+../a.out: cannot set NF to a negative value
+ source line number 1
--- src.orig/awk/bugs
+++ src.freebsd/awk/bugs
@@ -0,0 +1,19 @@
+# Unmodified nawk prints the 16 bit exit status divided by 256, but
+# does so using floating point arithmetic, yielding strange results.
+#
+# The fix is to use the various macros defined for wait(2) and to
+# use the signal number + 256 for death by signal, or signal number + 512
+# for death by signal with core dump.
+
+BEGIN {
+	status = system("exit 42")
+	print "normal status", status
+
+	status = system("kill -HUP $$")
+	print "death by signal status", status
+
+	status = system("kill -ABRT $$")
+	print "death by signal with core dump status", status
+
+	system("rm -f core*")
+}
--- src.orig/awk/bugs
+++ src.freebsd/awk/bugs
@@ -0,0 +1,3 @@
+normal status 42
+death by signal status 0.00390625
+death by signal with core dump status 0.523438
--- src.orig/awk/bugs
+++ src.freebsd/awk/bugs
@@ -0,0 +1,3 @@
+normal status 42
+death by signal status 257
+death by signal with core dump status 518
--- src.orig/awk/lex.c
+++ src.freebsd/awk/lex.c
@@ -425,19 +425,28 @@
 				break;
 
 			case 'x':	/* hex  \x0-9a-fA-F + */
-			    {	char xbuf[100], *px;
-				for (px = xbuf; (c = input()) != 0 && px-xbuf < 100-2; ) {
-					if (isdigit(c)
-					 || (c >= 'a' && c <= 'f')
-					 || (c >= 'A' && c <= 'F'))
-						*px++ = c;
-					else
+			    {
+				int i;
+
+				n = 0;
+				for (i = 1; i <= 2; i++) {
+					c = input();
+					if (c == 0)
 						break;
+					if (isxdigit(c)) {
+						c = tolower(c);
+						n *= 16;
+						if (isdigit(c))
+							n += (c - '0');
+						else
+							n += 10 + (c - 'a');
+					} else
+						break;
 				}
-				*px = 0;
-				unput(c);
-	  			sscanf(xbuf, "%x", (unsigned int *) &n);
-				*bp++ = n;
+				if (n)
+					*bp++ = n;
+				else
+					unput(c);
 				break;
 			    }
 
@@ -534,7 +543,7 @@
 	char *bp;
 
 	if (buf == NULL && (buf = (char *) malloc(bufsz)) == NULL)
-		FATAL("out of space for rex expr");
+		FATAL("out of space for reg expr");
 	bp = buf;
 	for ( ; (c = input()) != '/' && c != 0; ) {
 		if (!adjbuf(&buf, &bufsz, bp-buf+3, 500, &bp, "regexpr"))
@@ -554,7 +563,7 @@
 	*bp = 0;
 	if (c == 0)
 		SYNTAX("non-terminated regular expression %.10s...", buf);
-	yylval.s = tostring(buf);
+	yylval.s = buf;
 	unput('/');
 	RET(REGEXPR);
 }
--- src.orig/awk/lib.c
+++ src.freebsd/awk/lib.c
@@ -297,12 +297,13 @@
 
 void setclvar(char *s)	/* set var=value from s */
 {
-	char *p;
+	char *e, *p;
 	Cell *q;
 	double result;
 
 	for (p=s; *p != '='; p++)
 		;
+	e = p;
 	*p++ = 0;
 	p = qstring(p, '\0');
 	q = setsymtab(s, p, 0.0, STR, symtab);
@@ -312,6 +313,8 @@
 		q->tval |= NUM;
 	}
 	DPRINTF("command line set %s to |%s|\n", s, p);
+	free(p);
+	*e = '=';
 }
 
 
--- src.orig/awk/main.c
+++ src.freebsd/awk/main.c
@@ -22,7 +22,7 @@
 THIS SOFTWARE.
 ****************************************************************/
 
-const char	*version = "version 20210724";
+const char	*version = "version 20221215";
 
 #define DEBUG
 #include <stdio.h>
--- src.orig/awk/run.c
+++ src.freebsd/awk/run.c
@@ -447,13 +447,15 @@
 			n = getrec(&record, &recsize, true);
 		else {			/* getline var */
 			n = getrec(&buf, &bufsize, false);
-			x = execute(a[0]);
-			setsval(x, buf);
-			if (is_number(x->sval, & result)) {
-				x->fval = result;
-				x->tval |= NUM;
+			if (n > 0) {
+				x = execute(a[0]);
+				setsval(x, buf);
+				if (is_number(x->sval, & result)) {
+					x->fval = result;
+					x->tval |= NUM;
+				}
+				tempfree(x);
 			}
-			tempfree(x);
 		}
 	}
 	setfval(r, (Awkfloat) n);
@@ -972,8 +974,10 @@
 	}
 	*p = '\0';
 	free(fmt);
-	for ( ; a; a = a->nnext)		/* evaluate any remaining args */
-		execute(a);
+	for ( ; a; a = a->nnext) {		/* evaluate any remaining args */
+		x = execute(a);
+		tempfree(x);
+	}
 	*pbuf = buf;
 	*pbufsize = bufsize;
 	return p - buf;
@@ -1196,16 +1200,17 @@
 
 	x = execute(a[0]);
 	n1 = strlen(getsval(x));
-	adjbuf(&s, &ssz, n1, recsize, 0, "cat1");
+	adjbuf(&s, &ssz, n1 + 1, recsize, 0, "cat1");
 	memcpy(s, x->sval, n1);
 
+	tempfree(x);
+
 	y = execute(a[1]);
 	n2 = strlen(getsval(y));
 	adjbuf(&s, &ssz, n1 + n2 + 1, recsize, 0, "cat2");
 	memcpy(s + n1, y->sval, n2);
 	s[n1 + n2] = '\0';
 
-	tempfree(x);
 	tempfree(y);
 
 	z = gettemp();
@@ -1267,6 +1272,7 @@
 
 	y = execute(a[0]);	/* source string */
 	origs = s = strdup(getsval(y));
+	tempfree(y);
 	arg3type = ptoi(a[3]);
 	if (a[2] == NULL)		/* fs string */
 		fs = getsval(fsloc);
@@ -1387,7 +1393,6 @@
 		}
 	}
 	tempfree(ap);
-	tempfree(y);
 	xfree(origs);
 	xfree(origfs);
 	x = gettemp();
@@ -1541,14 +1546,8 @@
 		buf = tostringN(s, strlen(s) * sz + 1);
 
 		(void) mbtowc(NULL, NULL, 0);	/* reset internal state */
-		/*
-		 * Reset internal state here too.
-		 * Assign result to avoid a compiler warning. (Casting to void
-		 * doesn't work.)
-		 * Increment said variable to avoid a different warning.
-		 */
-		int unused = wctomb(NULL, L'\0');
-		unused++;
+		/* Reset internal state here too. */
+		(void) wctomb(NULL, L'\0');
 
 		ps   = s;
 		pbuf = buf;
@@ -1604,7 +1603,7 @@
 Cell *bltin(Node **a, int n)	/* builtin functions. a[0] is type, a[1] is arg list */
 {
 	Cell *x, *y;
-	Awkfloat u;
+	Awkfloat u = 0;
 	int t, sz;
 	Awkfloat tmp;
 	char *buf, *fmt;
@@ -1808,8 +1807,10 @@
 	setfval(x, u);
 	if (nextarg != NULL) {
 		WARNING("warning: function has too many arguments");
-		for ( ; nextarg; nextarg = nextarg->nnext)
-			execute(nextarg);
+		for ( ; nextarg; nextarg = nextarg->nnext) {
+			y = execute(nextarg);
+			tempfree(y);
+		}
 	}
 	return(x);
 }
@@ -1876,13 +1877,13 @@
 	if (files == NULL)
 		FATAL("can't allocate file memory for %zu files", nfiles);
         files[0].fp = stdin;
-	files[0].fname = "/dev/stdin";
+	files[0].fname = tostring("/dev/stdin");
 	files[0].mode = LT;
         files[1].fp = stdout;
-	files[1].fname = "/dev/stdout";
+	files[1].fname = tostring("/dev/stdout");
 	files[1].mode = GT;
         files[2].fp = stderr;
-	files[2].fname = "/dev/stderr";
+	files[2].fname = tostring("/dev/stderr");
 	files[2].mode = GT;
 }
 
@@ -1956,8 +1957,8 @@
 	return "???";
 }
 
- Cell *closefile(Node **a, int n)
- {
+Cell *closefile(Node **a, int n)
+{
  	Cell *x;
 	size_t i;
 	bool stat;
@@ -1968,8 +1969,15 @@
  	for (i = 0; i < nfiles; i++) {
 		if (!files[i].fname || strcmp(x->sval, files[i].fname) != 0)
 			continue;
-		if (ferror(files[i].fp))
-			FATAL("i/o error occurred on %s", files[i].fname);
+		if (files[i].mode == GT || files[i].mode == '|')
+			fflush(files[i].fp);
+		if (ferror(files[i].fp)) {
+			if ((files[i].mode == GT && files[i].fp != stderr)
+			  || files[i].mode == '|')
+				FATAL("write error on %s", files[i].fname);
+			else
+				WARNING("i/o error occurred on %s", files[i].fname);
+		}
 		if (files[i].fp == stdin || files[i].fp == stdout ||
 		    files[i].fp == stderr)
 			stat = freopen("/dev/null", "r+", files[i].fp) == NULL;
@@ -1978,9 +1986,8 @@
 		else
 			stat = fclose(files[i].fp) == EOF;
 		if (stat)
-			FATAL("i/o error occurred closing %s", files[i].fname);
-		if (i > 2)	/* don't do /dev/std... */
-			xfree(files[i].fname);
+			WARNING("i/o error occurred closing %s", files[i].fname);
+		xfree(files[i].fname);
 		files[i].fname = NULL;	/* watch out for ref thru this */
 		files[i].fp = NULL;
 		break;
@@ -1989,7 +1996,7 @@
  	x = gettemp();
 	setfval(x, (Awkfloat) (stat ? -1 : 0));
  	return(x);
- }
+}
 
 void closeall(void)
 {
@@ -1999,18 +2006,24 @@
 	for (i = 0; i < nfiles; i++) {
 		if (! files[i].fp)
 			continue;
-		if (ferror(files[i].fp))
-			FATAL( "i/o error occurred on %s", files[i].fname );
-		if (files[i].fp == stdin)
+		if (files[i].mode == GT || files[i].mode == '|')
+			fflush(files[i].fp);
+		if (ferror(files[i].fp)) {
+			if ((files[i].mode == GT && files[i].fp != stderr)
+			  || files[i].mode == '|')
+				FATAL("write error on %s", files[i].fname);
+			else
+				WARNING("i/o error occurred on %s", files[i].fname);
+		}
+		if (files[i].fp == stdin || files[i].fp == stdout ||
+		    files[i].fp == stderr)
 			continue;
 		if (files[i].mode == '|' || files[i].mode == LE)
 			stat = pclose(files[i].fp) == -1;
-		else if (files[i].fp == stdout || files[i].fp == stderr)
-			stat = fflush(files[i].fp) == EOF;
 		else
 			stat = fclose(files[i].fp) == EOF;
 		if (stat)
-			FATAL( "i/o error occurred while closing %s", files[i].fname );
+			WARNING("i/o error occurred while closing %s", files[i].fname);
 	}
 }
 
--- src.orig/awk/tran.c
+++ src.freebsd/awk/tran.c
@@ -70,18 +70,6 @@
 
 extern Cell **fldtab;
 
-static void
-setfree(Cell *vp)
-{
-	if (&vp->sval == FS || &vp->sval == RS ||
-	    &vp->sval == OFS || &vp->sval == ORS ||
-	    &vp->sval == OFMT || &vp->sval == CONVFMT ||
-	    &vp->sval == FILENAME || &vp->sval == SUBSEP)
-		vp->tval |= DONTFREE;
-	else
-		vp->tval &= ~DONTFREE;
-}
-
 void syminit(void)	/* initialize symbol table with builtin vars */
 {
 	literal0 = setsymtab("0", "0", 0.0, NUM|STR|CON|DONTFREE, symtab);
@@ -377,10 +365,9 @@
 	t = s ? tostring(s) : tostring("");	/* in case it's self-assign */
 	if (freeable(vp))
 		xfree(vp->sval);
-	vp->tval &= ~(NUM|CONVC|CONVO);
+	vp->tval &= ~(NUM|DONTFREE|CONVC|CONVO);
 	vp->tval |= STR;
 	vp->fmt = NULL;
-	setfree(vp);
 	DPRINTF("setsval %p: %s = \"%s (%p) \", t=%o r,f=%d,%d\n",
 		(void*)vp, NN(vp->nval), t, (void*)t, vp->tval, donerec, donefld);
 	vp->sval = t;
--- src.orig/bc/dc/bcode.c
+++ src.freebsd/bc/dc/bcode.c
@@ -70,7 +70,7 @@
 static void		 pop_print(void);
 static void		 pop_printn(void);
 static __inline void	 print_stack(void);
-static __inline void	 dup(void);
+static __inline void	 dcdup(void);
 static void		 swap(void);
 static void		 drop(void);
 
@@ -195,7 +195,7 @@
 	{ '_',	parse_number	},
 	{ 'a',	to_ascii	},
 	{ 'c',	clear_stack	},
-	{ 'd',	dup		},
+	{ 'd',	dcdup		},
 	{ 'e',	print_err	},
 	{ 'f',	print_stack	},
 	{ 'i',	set_ibase	},
@@ -549,7 +549,7 @@
 }
 
 static __inline void
-dup(void)
+dcdup(void)
 {
 
 	stack_dup(&bmachine.stack);
--- src.orig/bintrans/qp.c
+++ src.freebsd/bintrans/qp.c
@@ -90,7 +90,7 @@
 static void
 encode_quoted_printable(const char *body, FILE *fpo)
 {
-	char prev;
+	char prev = 0;
 	const char *end = body + strlen(body);
 	size_t linelen = 0;
 
--- src.orig/bintrans/uudecode.c
+++ src.freebsd/bintrans/uudecode.c
@@ -58,6 +58,7 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <libgen.h>
+#include <libutil.h>
 #include <pwd.h>
 #include <resolv.h>
 #include <stdbool.h>
@@ -465,7 +466,7 @@
 		strcpy(leftover, inbuf + count4 + 1);
 		inbuf[count4 + 1] = 0;
 
-		n = b64_pton(inbuf, outbuf, sizeof(outbuf));
+		n = compat_b64_pton(inbuf, outbuf, sizeof(outbuf));
 
 		if (n < 0)
 			break;
--- src.orig/bintrans/uuencode.c
+++ src.freebsd/bintrans/uuencode.c
@@ -55,6 +55,7 @@
 #include <err.h>
 #include <errno.h>
 #include <libgen.h>
+#include <libutil.h>
 #include <resolv.h>
 #include <stdio.h>
 #include <stdbool.h>
@@ -184,7 +185,7 @@
 	if (!raw)
 		fprintf(output, "begin-base64 %o %s\n", mode, *av);
 	while ((n = fread(buf, 1, sizeof(buf), stdin))) {
-		rv = b64_ntop(buf, n, buf2, nitems(buf2));
+		rv = compat_b64_ntop(buf, n, buf2, nitems(buf2));
 		if (rv == -1)
 			errx(1, "b64_ntop: error encoding base64");
 		if (columns == 0) {
--- src.orig/compat/merge.c
+++ src.freebsd/compat/merge.c
@@ -36,6 +36,9 @@
 static char sccsid[] = "@(#)merge.c	8.2 (Berkeley) 2/14/94";
 #endif /* LIBC_SCCS and not lint */
 #include <sys/cdefs.h>
+
+#define __is_aligned(x, align) (((uintptr_t)x & ((align) - 1)) == 0)
+
 /*
  * Hybrid exponential search/linear search merge sort with hybrid
  * natural/pairwise first pass.  Requires about .3% more comparisons
@@ -50,11 +53,13 @@
  * (The default is pairwise merging.)
  */
 
+#include <sys/types.h>
 #include <sys/param.h>
 
 #include <errno.h>
 #include <stdlib.h>
 #include <string.h>
+#include <stdint.h>
 
 #ifdef I_AM_MERGESORT_B
 #include "block_abi.h"
--- src.orig/compat/setmode.c
+++ src.freebsd/compat/setmode.c
@@ -34,10 +34,8 @@
 
 #include <sys/cdefs.h>
 __SCCSID("@(#)setmode.c	8.2 (Berkeley) 3/25/94");
-#include "namespace.h"
 #include <sys/types.h>
 #include <sys/stat.h>
-#include <sys/sysctl.h>
 
 #include <ctype.h>
 #include <errno.h>
@@ -50,8 +48,6 @@
 #ifdef SETMODE_DEBUG
 #include <stdio.h>
 #endif
-#include "un-namespace.h"
-#include "libc_private.h"
 
 #define	SET_LEN	6		/* initial # of bitcmd struct to malloc */
 #define	SET_LEN_INCR 4		/* # of bitcmd structs to add as needed */
@@ -152,11 +148,12 @@
 #define	ADDCMD(a, b, c, d)						\
 	if (set >= endset) {						\
 		BITCMD *newset;						\
+		ptrdiff_t setdiff = set - saveset; \
 		setlen += SET_LEN_INCR;					\
 		newset = reallocarray(saveset, setlen, sizeof(BITCMD));	\
 		if (newset == NULL)					\
 			goto out;					\
-		set = newset + (set - saveset);				\
+		set = newset + setdiff;				\
 		saveset = newset;					\
 		endset = newset + (setlen - 2);				\
 	}								\
@@ -344,9 +341,7 @@
 get_current_umask(void)
 {
 	sigset_t sigset, sigoset;
-	size_t len;
 	mode_t mask;
-	u_short smask;
 
 #ifdef KERN_PROC_UMASK
 	/*
@@ -364,9 +359,9 @@
 	 * handler, protect them as best we can.
 	 */
 	sigfillset(&sigset);
-	(void)__libc_sigprocmask(SIG_BLOCK, &sigset, &sigoset);
+	(void)sigprocmask(SIG_BLOCK, &sigset, &sigoset);
 	(void)umask(mask = umask(0));
-	(void)__libc_sigprocmask(SIG_SETMASK, &sigoset, NULL);
+	(void)sigprocmask(SIG_SETMASK, &sigoset, NULL);
 	return (mask);
 }
 
--- src.orig/compat/strftime.c
+++ src.freebsd/compat/strftime.c
@@ -30,25 +30,34 @@
 #endif /* !defined NOID */
 #endif /* !defined lint */
 
-#include "namespace.h"
-#include "private.h"
-
 #if defined(LIBC_SCCS) && !defined(lint)
 static const char	sccsid[] = "@(#)strftime.c	5.4 (Berkeley) 3/14/89";
 #endif /* LIBC_SCCS and not lint */
 #include <sys/cdefs.h>
-#include "tzfile.h"
 #include <fcntl.h>
 #include <sys/stat.h>
 #include <stdio.h>
-#include "un-namespace.h"
-#include "timelocal.h"
+#include <time.h>
+#include <langinfo.h>
+ 
+#define DAYSPERWEEK 7
+#define MONSPERYEAR 12
+#define HOURSPERDAY 24
+#define SECSPERMIN 60
+#define MINSPERHOUR 60
+#define DAYSPERNYEAR 365
+#define DAYSPERLYEAR 366
+#define TM_YEAR_BASE 1900
+#define TM_GMTOFF tm_gmtoff
+#define TM_ZONE tm_zone
 
+#define isleap(y) (((y) % 4) == 0 && (((y) % 100) != 0 || ((y) % 400) == 0))
+#define isleap_sum(a, b) isleap((a) % 400 + (b) % 400)
+
 static char *	_add(const char *, char *, const char *);
-static char *	_conv(int, const char *, char *, const char *, locale_t);
-static char *	_fmt(const char *, const struct tm *, char *, const char *,
-			int *, locale_t);
-static char *	_yconv(int, int, int, int, char *, const char *, locale_t);
+static char *	_conv(int, const char *, char *, const char *);
+static char *	_fmt(const char *, const struct tm *, char *, const char *);
+static char *	_yconv(int, int, int, int, char *, const char *);
 
 extern char *	tzname[];
 
@@ -86,51 +95,23 @@
 };
 
 size_t
-strftime_l(char * __restrict s, size_t maxsize, const char * __restrict format,
-    const struct tm * __restrict t, locale_t loc)
+strftime_bsd(char * __restrict s, size_t maxsize, const char * __restrict format,
+    const struct tm * __restrict t)
 {
 	char *	p;
-	int	warn;
-	FIX_LOCALE(loc);
-
 	tzset();
-	warn = IN_NONE;
-	p = _fmt(((format == NULL) ? "%c" : format), t, s, s + maxsize, &warn, loc);
-#ifndef NO_RUN_TIME_WARNINGS_ABOUT_YEAR_2000_PROBLEMS_THANK_YOU
-	if (warn != IN_NONE && getenv(YEAR_2000_NAME) != NULL) {
-		(void) fprintf_l(stderr, loc, "\n");
-		if (format == NULL)
-			(void) fputs("NULL strftime format ", stderr);
-		else	(void) fprintf_l(stderr, loc, "strftime format \"%s\" ",
-				format);
-		(void) fputs("yields only two digits of years in ", stderr);
-		if (warn == IN_SOME)
-			(void) fputs("some locales", stderr);
-		else if (warn == IN_THIS)
-			(void) fputs("the current locale", stderr);
-		else	(void) fputs("all locales", stderr);
-		(void) fputs("\n", stderr);
-	}
-#endif /* !defined NO_RUN_TIME_WARNINGS_ABOUT_YEAR_2000_PROBLEMS_THANK_YOU */
+	p = _fmt(((format == NULL) ? "%c" : format), t, s, s + maxsize);
 	if (p == s + maxsize)
 		return (0);
 	*p = '\0';
 	return p - s;
 }
 
-size_t
-strftime(char * __restrict s, size_t maxsize, const char * __restrict format,
-    const struct tm * __restrict t)
-{
-	return strftime_l(s, maxsize, format, t, __get_locale());
-}
-
 static char *
 _fmt(const char *format, const struct tm * const t, char *pt,
-    const char * const ptlim, int *warnp, locale_t loc)
+    const char * const ptlim)
 {
 	int Ealternative, Oalternative, PadIndex;
-	struct lc_time_T *tptr = __get_current_time_locale(loc);
 
 	for ( ; *format; ++format) {
 		if (*format == '%') {
@@ -145,27 +126,26 @@
 			case 'A':
 				pt = _add((t->tm_wday < 0 ||
 					t->tm_wday >= DAYSPERWEEK) ?
-					"?" : tptr->weekday[t->tm_wday],
+					"?" : nl_langinfo(DAY_1 + t->tm_wday),
 					pt, ptlim);
 				continue;
 			case 'a':
 				pt = _add((t->tm_wday < 0 ||
 					t->tm_wday >= DAYSPERWEEK) ?
-					"?" : tptr->wday[t->tm_wday],
+					"?" : nl_langinfo(ABDAY_1 + t->tm_wday),
 					pt, ptlim);
 				continue;
 			case 'B':
 				pt = _add((t->tm_mon < 0 ||
 					t->tm_mon >= MONSPERYEAR) ?
-					"?" : (Oalternative ? tptr->alt_month :
-					tptr->month)[t->tm_mon],
+					"?" : nl_langinfo(MON_1 + t->tm_mon),
 					pt, ptlim);
 				continue;
 			case 'b':
 			case 'h':
 				pt = _add((t->tm_mon < 0 ||
 					t->tm_mon >= MONSPERYEAR) ?
-					"?" : tptr->mon[t->tm_mon],
+					"?" : nl_langinfo(ABMON_1 + t->tm_mon),
 					pt, ptlim);
 				continue;
 			case 'C':
@@ -177,26 +157,18 @@
 				 * (ado, 1993-05-24)
 				 */
 				pt = _yconv(t->tm_year, TM_YEAR_BASE, 1, 0,
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 			case 'c':
-				{
-				int warn2 = IN_SOME;
-
-				pt = _fmt(tptr->c_fmt, t, pt, ptlim, &warn2, loc);
-				if (warn2 == IN_ALL)
-					warn2 = IN_THIS;
-				if (warn2 > *warnp)
-					*warnp = warn2;
-				}
+				pt = _fmt(nl_langinfo(D_T_FMT), t, pt, ptlim);
 				continue;
 			case 'D':
-				pt = _fmt("%m/%d/%y", t, pt, ptlim, warnp, loc);
+				pt = _fmt("%m/%d/%y", t, pt, ptlim);
 				continue;
 			case 'd':
 				pt = _conv(t->tm_mday,
 					fmt_padding[PAD_FMT_DAYOFMONTH][PadIndex],
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 			case 'E':
 				if (Ealternative || Oalternative)
@@ -223,25 +195,25 @@
 			case 'e':
 				pt = _conv(t->tm_mday,
 					fmt_padding[PAD_FMT_SDAYOFMONTH][PadIndex],
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 			case 'F':
-				pt = _fmt("%Y-%m-%d", t, pt, ptlim, warnp, loc);
+				pt = _fmt("%Y-%m-%d", t, pt, ptlim);
 				continue;
 			case 'H':
 				pt = _conv(t->tm_hour, fmt_padding[PAD_FMT_HMS][PadIndex],
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 			case 'I':
 				pt = _conv((t->tm_hour % 12) ?
 					(t->tm_hour % 12) : 12,
 					fmt_padding[PAD_FMT_HMS][PadIndex],
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 			case 'j':
 				pt = _conv(t->tm_yday + 1,
 					fmt_padding[PAD_FMT_DAYOFYEAR][PadIndex],
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 			case 'k':
 				/*
@@ -255,7 +227,7 @@
 				 * (ado, 1993-05-24)
 				 */
 				pt = _conv(t->tm_hour, fmt_padding[PAD_FMT_SHMS][PadIndex],
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 #ifdef KITCHEN_SINK
 			case 'K':
@@ -278,55 +250,49 @@
 				pt = _conv((t->tm_hour % 12) ?
 					(t->tm_hour % 12) : 12,
 					fmt_padding[PAD_FMT_SHMS][PadIndex],
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 			case 'M':
 				pt = _conv(t->tm_min, fmt_padding[PAD_FMT_HMS][PadIndex],
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 			case 'm':
 				pt = _conv(t->tm_mon + 1,
 					fmt_padding[PAD_FMT_MONTH][PadIndex],
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 			case 'n':
 				pt = _add("\n", pt, ptlim);
 				continue;
 			case 'p':
-				pt = _add((t->tm_hour >= (HOURSPERDAY / 2)) ?
-					tptr->pm : tptr->am,
+				pt = _add(nl_langinfo((t->tm_hour >= (HOURSPERDAY / 2)) ?
+					PM_STR : AM_STR),
 					pt, ptlim);
 				continue;
 			case 'R':
-				pt = _fmt("%H:%M", t, pt, ptlim, warnp, loc);
+				pt = _fmt("%H:%M", t, pt, ptlim);
 				continue;
 			case 'r':
-				pt = _fmt(tptr->ampm_fmt, t, pt, ptlim,
-					warnp, loc);
+				pt = _fmt(nl_langinfo(T_FMT_AMPM), t, pt, ptlim);
 				continue;
 			case 'S':
 				pt = _conv(t->tm_sec, fmt_padding[PAD_FMT_HMS][PadIndex],
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 			case 's':
 				{
 					struct tm	tm;
-					char		buf[INT_STRLEN_MAXIMUM(
-								time_t) + 1];
+					char		buf[32];
 					time_t		mkt;
 
 					tm = *t;
 					mkt = mktime(&tm);
-					if (TYPE_SIGNED(time_t))
-						(void) sprintf_l(buf, loc, "%ld",
-							(long) mkt);
-					else	(void) sprintf_l(buf, loc, "%lu",
-							(unsigned long) mkt);
+					(void) sprintf(buf, "%lld", (long long) mkt);
 					pt = _add(buf, pt, ptlim);
 				}
 				continue;
 			case 'T':
-				pt = _fmt("%H:%M:%S", t, pt, ptlim, warnp, loc);
+				pt = _fmt("%H:%M:%S", t, pt, ptlim);
 				continue;
 			case 't':
 				pt = _add("\t", pt, ptlim);
@@ -335,7 +301,7 @@
 				pt = _conv((t->tm_yday + DAYSPERWEEK -
 					t->tm_wday) / DAYSPERWEEK,
 					fmt_padding[PAD_FMT_WEEKOFYEAR][PadIndex],
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 			case 'u':
 				/*
@@ -346,7 +312,7 @@
 				 */
 				pt = _conv((t->tm_wday == 0) ?
 					DAYSPERWEEK : t->tm_wday,
-					"%d", pt, ptlim, loc);
+					"%d", pt, ptlim);
 				continue;
 			case 'V':	/* ISO 8601 week number */
 			case 'G':	/* ISO 8601 year (four digits) */
@@ -427,13 +393,12 @@
 #endif /* defined XPG4_1994_04_09 */
 					if (*format == 'V')
 						pt = _conv(w, fmt_padding[PAD_FMT_WEEKOFYEAR][PadIndex],
-							pt, ptlim, loc);
+							pt, ptlim);
 					else if (*format == 'g') {
-						*warnp = IN_ALL;
 						pt = _yconv(year, base, 0, 1,
-							pt, ptlim, loc);
+							pt, ptlim);
 					} else	pt = _yconv(year, base, 1, 1,
-							pt, ptlim, loc);
+							pt, ptlim);
 				}
 				continue;
 			case 'v':
@@ -442,7 +407,7 @@
 				 * "date as dd-bbb-YYYY"
 				 * (ado, 1993-05-24)
 				 */
-				pt = _fmt("%e-%b-%Y", t, pt, ptlim, warnp, loc);
+				pt = _fmt("%e-%b-%Y", t, pt, ptlim);
 				continue;
 			case 'W':
 				pt = _conv((t->tm_yday + DAYSPERWEEK -
@@ -450,33 +415,24 @@
 					(t->tm_wday - 1) :
 					(DAYSPERWEEK - 1))) / DAYSPERWEEK,
 					fmt_padding[PAD_FMT_WEEKOFYEAR][PadIndex],
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 			case 'w':
-				pt = _conv(t->tm_wday, "%d", pt, ptlim, loc);
+				pt = _conv(t->tm_wday, "%d", pt, ptlim);
 				continue;
 			case 'X':
-				pt = _fmt(tptr->X_fmt, t, pt, ptlim, warnp, loc);
+				pt = _fmt(nl_langinfo(T_FMT), t, pt, ptlim);
 				continue;
 			case 'x':
-				{
-				int	warn2 = IN_SOME;
-
-				pt = _fmt(tptr->x_fmt, t, pt, ptlim, &warn2, loc);
-				if (warn2 == IN_ALL)
-					warn2 = IN_THIS;
-				if (warn2 > *warnp)
-					*warnp = warn2;
-				}
+				pt = _fmt(nl_langinfo(D_FMT), t, pt, ptlim);
 				continue;
 			case 'y':
-				*warnp = IN_ALL;
 				pt = _yconv(t->tm_year, TM_YEAR_BASE, 0, 1,
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 			case 'Y':
 				pt = _yconv(t->tm_year, TM_YEAR_BASE, 1, 1,
-					pt, ptlim, loc);
+					pt, ptlim);
 				continue;
 			case 'Z':
 #ifdef TM_ZONE
@@ -546,12 +502,15 @@
 					(diff % MINSPERHOUR);
 				pt = _conv(diff,
 					fmt_padding[PAD_FMT_YEAR][PadIndex],
-					pt, ptlim, loc);
+					pt, ptlim);
 				}
 				continue;
 			case '+':
-				pt = _fmt(tptr->date_fmt, t, pt, ptlim,
-					warnp, loc);
+#ifdef _DATE_FMT
+				pt = _fmt(nl_langinfo(_DATE_FMT), t, pt, ptlim);
+#else
+				pt = _fmt("%a %b %e %H:%M:%S %Z %Y", t, pt, ptlim);
+#endif
 				continue;
 			case '-':
 				if (PadIndex != PAD_DEFAULT)
@@ -587,11 +546,11 @@
 
 static char *
 _conv(const int n, const char * const format, char * const pt,
-    const char * const ptlim, locale_t  loc)
+    const char * const ptlim)
 {
-	char	buf[INT_STRLEN_MAXIMUM(int) + 1];
+	char	buf[16];
 
-	(void) sprintf_l(buf, loc, format, n);
+	(void) sprintf(buf, format, n);
 	return _add(buf, pt, ptlim);
 }
 
@@ -613,7 +572,7 @@
 
 static char *
 _yconv(const int a, const int b, const int convert_top, const int convert_yy,
-    char *pt, const char * const ptlim, locale_t  loc)
+    char *pt, const char * const ptlim)
 {
 	register int	lead;
 	register int	trail;
@@ -632,10 +591,10 @@
 	if (convert_top) {
 		if (lead == 0 && trail < 0)
 			pt = _add("-0", pt, ptlim);
-		else	pt = _conv(lead, "%02d", pt, ptlim, loc);
+		else	pt = _conv(lead, "%02d", pt, ptlim);
 	}
 	if (convert_yy)
 		pt = _conv(((trail < 0) ? -trail : trail), "%02d", pt,
-		     ptlim, loc);
+		     ptlim);
 	return (pt);
 }
--- src.orig/compat/stringlist.c
+++ src.freebsd/compat/stringlist.c
@@ -28,13 +28,11 @@
 
 #include <sys/cdefs.h>
 __RCSID("$NetBSD: stringlist.c,v 1.2 1997/01/17 07:26:20 lukem Exp $");
-#include "namespace.h"
 #include <stdio.h>
 #include <string.h>
 #include <err.h>
 #include <stdlib.h>
 #include <stringlist.h>
-#include "un-namespace.h"
 
 #define _SL_CHUNKSIZE	20
 
@@ -48,13 +46,13 @@
 
 	sl = malloc(sizeof(StringList));
 	if (sl == NULL)
-		_err(1, "stringlist: %m");
+		err(1, "stringlist: %m");
 
 	sl->sl_cur = 0;
 	sl->sl_max = _SL_CHUNKSIZE;
 	sl->sl_str = malloc(sl->sl_max * sizeof(char *));
 	if (sl->sl_str == NULL)
-		_err(1, "stringlist: %m");
+		err(1, "stringlist: %m");
 	return sl;
 }
 
--- src.orig/compat/strptime.c
+++ src.freebsd/compat/strptime.c
@@ -45,21 +45,24 @@
 static char sccsid[] __unused = "@(#)strptime.c	0.1 (Powerdog) 94/03/27";
 #endif /* !defined NOID */
 #endif /* not lint */
-#include "namespace.h"
 #include <time.h>
 #include <ctype.h>
 #include <errno.h>
 #include <stdlib.h>
 #include <string.h>
 #include <pthread.h>
-#include "private.h"
-#include "un-namespace.h"
-#include "libc_private.h"
-#include "timelocal.h"
-#include "tzfile.h"
+#include <langinfo.h>
 
-static char * _strptime(const char *, const char *, struct tm *, int *, locale_t);
+#define DAYSPERWEEK 7
+#define MONSPERYEAR 12
+#define	TM_SUNDAY 0
+#define TM_MONDAY 1
+#define TM_YEAR_BASE 1900
 
+#define isleap(y) (((y) % 4) == 0 && (((y) % 100) != 0 || ((y) % 400) == 0))
+
+static char * _strptime(const char *, const char *, struct tm *, int *);
+
 #define	asizeof(a)	(sizeof(a) / sizeof((a)[0]))
 
 #define	FLAG_NONE	(1 << 0)
@@ -84,18 +87,16 @@
 }
 
 static char *
-_strptime(const char *buf, const char *fmt, struct tm *tm, int *GMTp,
-		locale_t locale)
+_strptime(const char *buf, const char *fmt, struct tm *tm, int *GMTp)
 {
 	char	c;
-	const char *ptr;
+	const char *ptr, *ex;
 	int	day_offset = -1, wday_offset;
 	int week_offset;
 	int	i, len;
 	int flags;
 	int Ealternative, Oalternative;
 	int century, year;
-	const struct lc_time_T *tptr = __get_current_time_locale(locale);
 	static int start_of_month[2][13] = {
 		{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},
 		{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}
@@ -110,9 +111,9 @@
 		c = *ptr++;
 
 		if (c != '%') {
-			if (isspace_l((unsigned char)c, locale))
+			if (isspace((unsigned char)c))
 				while (*buf != 0 && 
-				       isspace_l((unsigned char)*buf, locale))
+				       isspace((unsigned char)*buf))
 					buf++;
 			else if (c != *buf++)
 				return (NULL);
@@ -130,20 +131,24 @@
 			break;
 
 		case '+':
-			buf = _strptime(buf, tptr->date_fmt, tm, GMTp, locale);
+#ifdef _DATE_FMT
+			buf = _strptime(buf, nl_langinfo(_DATE_FMT), tm, GMTp);
+#else
+			buf = _strptime(buf, "%a %b %e %H:%M:%S %Z %Y", tm, GMTp);
+#endif
 			if (buf == NULL)
 				return (NULL);
 			flags |= FLAG_WDAY | FLAG_MONTH | FLAG_MDAY | FLAG_YEAR;
 			break;
 
 		case 'C':
-			if (!isdigit_l((unsigned char)*buf, locale))
+			if (!isdigit((unsigned char)*buf))
 				return (NULL);
 
 			/* XXX This will break for 3-digit centuries. */
 			len = 2;
 			for (i = 0; len && *buf != 0 &&
-			     isdigit_l((unsigned char)*buf, locale); buf++) {
+			     isdigit((unsigned char)*buf); buf++) {
 				i *= 10;
 				i += *buf - '0';
 				len--;
@@ -155,14 +160,14 @@
 			break;
 
 		case 'c':
-			buf = _strptime(buf, tptr->c_fmt, tm, GMTp, locale);
+			buf = _strptime(buf, nl_langinfo(D_T_FMT), tm, GMTp);
 			if (buf == NULL)
 				return (NULL);
 			flags |= FLAG_WDAY | FLAG_MONTH | FLAG_MDAY | FLAG_YEAR;
 			break;
 
 		case 'D':
-			buf = _strptime(buf, "%m/%d/%y", tm, GMTp, locale);
+			buf = _strptime(buf, "%m/%d/%y", tm, GMTp);
 			if (buf == NULL)
 				return (NULL);
 			flags |= FLAG_MONTH | FLAG_MDAY | FLAG_YEAR;
@@ -181,50 +186,50 @@
 			goto label;
 
 		case 'F':
-			buf = _strptime(buf, "%Y-%m-%d", tm, GMTp, locale);
+			buf = _strptime(buf, "%Y-%m-%d", tm, GMTp);
 			if (buf == NULL)
 				return (NULL);
 			flags |= FLAG_MONTH | FLAG_MDAY | FLAG_YEAR;
 			break;
 
 		case 'R':
-			buf = _strptime(buf, "%H:%M", tm, GMTp, locale);
+			buf = _strptime(buf, "%H:%M", tm, GMTp);
 			if (buf == NULL)
 				return (NULL);
 			break;
 
 		case 'r':
-			buf = _strptime(buf, tptr->ampm_fmt, tm, GMTp, locale);
+			buf = _strptime(buf, nl_langinfo(T_FMT_AMPM), tm, GMTp);
 			if (buf == NULL)
 				return (NULL);
 			break;
 
 		case 'T':
-			buf = _strptime(buf, "%H:%M:%S", tm, GMTp, locale);
+			buf = _strptime(buf, "%H:%M:%S", tm, GMTp);
 			if (buf == NULL)
 				return (NULL);
 			break;
 
 		case 'X':
-			buf = _strptime(buf, tptr->X_fmt, tm, GMTp, locale);
+			buf = _strptime(buf, nl_langinfo(T_FMT), tm, GMTp);
 			if (buf == NULL)
 				return (NULL);
 			break;
 
 		case 'x':
-			buf = _strptime(buf, tptr->x_fmt, tm, GMTp, locale);
+			buf = _strptime(buf, nl_langinfo(D_FMT), tm, GMTp);
 			if (buf == NULL)
 				return (NULL);
 			flags |= FLAG_MONTH | FLAG_MDAY | FLAG_YEAR;
 			break;
 
 		case 'j':
-			if (!isdigit_l((unsigned char)*buf, locale))
+			if (!isdigit((unsigned char)*buf))
 				return (NULL);
 
 			len = 3;
 			for (i = 0; len && *buf != 0 &&
-			     isdigit_l((unsigned char)*buf, locale); buf++){
+			     isdigit((unsigned char)*buf); buf++){
 				i *= 10;
 				i += *buf - '0';
 				len--;
@@ -240,15 +245,15 @@
 		case 'M':
 		case 'S':
 			if (*buf == 0 ||
-				isspace_l((unsigned char)*buf, locale))
+				isspace((unsigned char)*buf))
 				break;
 
-			if (!isdigit_l((unsigned char)*buf, locale))
+			if (!isdigit((unsigned char)*buf))
 				return (NULL);
 
 			len = 2;
 			for (i = 0; len && *buf != 0 &&
-				isdigit_l((unsigned char)*buf, locale); buf++){
+				isdigit((unsigned char)*buf); buf++){
 				i *= 10;
 				i += *buf - '0';
 				len--;
@@ -281,16 +286,16 @@
 
 			len = 2;
 			if ((c == 'k' || c == 'l') &&
-			    isblank_l((unsigned char)*buf, locale)) {
+			    isblank((unsigned char)*buf)) {
 				buf++;
 				len = 1;
 			}
 
-			if (!isdigit_l((unsigned char)*buf, locale))
+			if (!isdigit((unsigned char)*buf))
 				return (NULL);
 
 			for (i = 0; len && *buf != 0 &&
-			     isdigit_l((unsigned char)*buf, locale); buf++) {
+			     isdigit((unsigned char)*buf); buf++) {
 				i *= 10;
 				i += *buf - '0';
 				len--;
@@ -313,16 +318,18 @@
 			if (tm->tm_hour > 12)
 				return (NULL);
 
-			len = strlen(tptr->am);
-			if (strncasecmp_l(buf, tptr->am, len, locale) == 0) {
+			ex = nl_langinfo(AM_STR);
+			len = strlen(ex);
+			if (strncasecmp(buf, ex, len) == 0) {
 				if (tm->tm_hour == 12)
 					tm->tm_hour = 0;
 				buf += len;
 				break;
 			}
 
-			len = strlen(tptr->pm);
-			if (strncasecmp_l(buf, tptr->pm, len, locale) == 0) {
+			ex = nl_langinfo(PM_STR);
+			len = strlen(ex);
+			if (strncasecmp(buf, ex, len) == 0) {
 				if (tm->tm_hour != 12)
 					tm->tm_hour += 12;
 				buf += len;
@@ -333,17 +340,17 @@
 
 		case 'A':
 		case 'a':
-			for (i = 0; i < asizeof(tptr->weekday); i++) {
-				len = strlen(tptr->weekday[i]);
-				if (strncasecmp_l(buf, tptr->weekday[i],
-						len, locale) == 0)
+			for (i = 0; i < DAYSPERWEEK; i++) {
+				ex = nl_langinfo(DAY_1 + i);
+				len = strlen(ex);
+				if (strncasecmp(buf, ex, len) == 0)
 					break;
-				len = strlen(tptr->wday[i]);
-				if (strncasecmp_l(buf, tptr->wday[i],
-						len, locale) == 0)
+				ex = nl_langinfo(ABDAY_1 + i);
+				len = strlen(ex);
+				if (strncasecmp(buf, ex, len) == 0)
 					break;
 			}
-			if (i == asizeof(tptr->weekday))
+			if (i == DAYSPERWEEK)
 				return (NULL);
 
 			buf += len;
@@ -359,12 +366,12 @@
 			 * point to calculate a real value, so just check the
 			 * range for now.
 			 */
-			if (!isdigit_l((unsigned char)*buf, locale))
+			if (!isdigit((unsigned char)*buf))
 				return (NULL);
 
 			len = 2;
 			for (i = 0; len && *buf != 0 &&
-			     isdigit_l((unsigned char)*buf, locale); buf++) {
+			     isdigit((unsigned char)*buf); buf++) {
 				i *= 10;
 				i += *buf - '0';
 				len--;
@@ -384,7 +391,7 @@
 
 		case 'u':
 		case 'w':
-			if (!isdigit_l((unsigned char)*buf, locale))
+			if (!isdigit((unsigned char)*buf))
 				return (NULL);
 
 			i = *buf++ - '0';
@@ -403,7 +410,7 @@
 			 * before single digits.
 			 */
 			if (*buf != 0 &&
-			    isspace_l((unsigned char)*buf, locale))
+			    isspace((unsigned char)*buf))
 			       buf++;
 			/* FALLTHROUGH */
 		case 'd':
@@ -416,12 +423,12 @@
 			 * XXX The %e specifier may gobble one too many
 			 * digits if used incorrectly.
 			 */
-			if (!isdigit_l((unsigned char)*buf, locale))
+			if (!isdigit((unsigned char)*buf))
 				return (NULL);
 
 			len = 2;
 			for (i = 0; len && *buf != 0 &&
-			     isdigit_l((unsigned char)*buf, locale); buf++) {
+			     isdigit((unsigned char)*buf); buf++) {
 				i *= 10;
 				i += *buf - '0';
 				len--;
@@ -437,19 +444,18 @@
 		case 'B':
 		case 'b':
 		case 'h':
-			for (i = 0; i < asizeof(tptr->month); i++) {
+			for (i = 0; i < MONSPERYEAR; i++) {
 				if (Oalternative) {
 					if (c == 'B') {
-						len = strlen(tptr->alt_month[i]);
-						if (strncasecmp_l(buf,
-								tptr->alt_month[i],
-								len, locale) == 0)
+						ex = nl_langinfo(MON_1 + i);
+						len = strlen(ex);
+						if (strncasecmp(buf, ex, len) == 0)
 							break;
 					}
 				} else {
-					len = strlen(tptr->month[i]);
-					if (strncasecmp_l(buf, tptr->month[i],
-							len, locale) == 0)
+					ex = nl_langinfo(MON_1 + i);
+					len = strlen(ex);
+					if (strncasecmp(buf, ex, len) == 0)
 						break;
 				}
 			}
@@ -457,15 +463,15 @@
 			 * Try the abbreviated month name if the full name
 			 * wasn't found and Oalternative was not requested.
 			 */
-			if (i == asizeof(tptr->month) && !Oalternative) {
-				for (i = 0; i < asizeof(tptr->month); i++) {
-					len = strlen(tptr->mon[i]);
-					if (strncasecmp_l(buf, tptr->mon[i],
-							len, locale) == 0)
+			if (i == MONSPERYEAR && !Oalternative) {
+				for (i = 0; i < MONSPERYEAR; i++) {
+					ex = nl_langinfo(ABMON_1 + i);
+					len = strlen(ex);
+					if (strncasecmp(buf, ex, len) == 0)
 						break;
 				}
 			}
-			if (i == asizeof(tptr->month))
+			if (i == MONSPERYEAR)
 				return (NULL);
 
 			tm->tm_mon = i;
@@ -475,12 +481,12 @@
 			break;
 
 		case 'm':
-			if (!isdigit_l((unsigned char)*buf, locale))
+			if (!isdigit((unsigned char)*buf))
 				return (NULL);
 
 			len = 2;
 			for (i = 0; len && *buf != 0 &&
-			     isdigit_l((unsigned char)*buf, locale); buf++) {
+			     isdigit((unsigned char)*buf); buf++) {
 				i *= 10;
 				i += *buf - '0';
 				len--;
@@ -502,7 +508,7 @@
 
 			sverrno = errno;
 			errno = 0;
-			n = strtol_l(buf, &cp, 10, locale);
+			n = strtol(buf, &cp, 10);
 			if (errno == ERANGE || (long)(t = n) != n) {
 				errno = sverrno;
 				return (NULL);
@@ -520,15 +526,15 @@
 		case 'Y':
 		case 'y':
 			if (*buf == 0 ||
-			    isspace_l((unsigned char)*buf, locale))
+			    isspace((unsigned char)*buf))
 				break;
 
-			if (!isdigit_l((unsigned char)*buf, locale))
+			if (!isdigit((unsigned char)*buf))
 				return (NULL);
 
 			len = (c == 'Y') ? 4 : 2;
 			for (i = 0; len && *buf != 0 &&
-			     isdigit_l((unsigned char)*buf, locale); buf++) {
+			     isdigit((unsigned char)*buf); buf++) {
 				i *= 10;
 				i += *buf - '0';
 				len--;
@@ -547,7 +553,7 @@
 			char *zonestr;
 
 			for (cp = buf; *cp &&
-			     isupper_l((unsigned char)*cp, locale); ++cp) {
+			     isupper((unsigned char)*cp); ++cp) {
 				/*empty*/}
 			if (cp - buf) {
 				zonestr = alloca(cp - buf + 1);
@@ -583,7 +589,7 @@
 			buf++;
 			i = 0;
 			for (len = 4; len > 0; len--) {
-				if (isdigit_l((unsigned char)*buf, locale)) {
+				if (isdigit((unsigned char)*buf)) {
 					i *= 10;
 					i += *buf - '0';
 					buf++;
@@ -605,7 +611,7 @@
 
 		case 'n':
 		case 't':
-			while (isspace_l((unsigned char)*buf, locale))
+			while (isspace((unsigned char)*buf))
 				buf++;
 			break;
 
@@ -697,15 +703,14 @@
 }
 
 char *
-strptime_l(const char * __restrict buf, const char * __restrict fmt,
-    struct tm * __restrict tm, locale_t loc)
+strptime_bsd(const char * __restrict buf, const char * __restrict fmt,
+    struct tm * __restrict tm)
 {
 	char *ret;
 	int gmt;
-	FIX_LOCALE(loc);
 
 	gmt = 0;
-	ret = _strptime(buf, fmt, tm, &gmt, loc);
+	ret = _strptime(buf, fmt, tm, &gmt);
 	if (ret && gmt) {
 		time_t t = timegm(tm);
 
@@ -713,11 +718,4 @@
 	}
 
 	return (ret);
-}
-
-char *
-strptime(const char * __restrict buf, const char * __restrict fmt,
-    struct tm * __restrict tm)
-{
-	return strptime_l(buf, fmt, tm, __get_locale());
 }
--- src.orig/compat/unvis.c
+++ src.freebsd/compat/unvis.c
@@ -39,7 +39,6 @@
 #endif /* LIBC_SCCS and not lint */
 __FBSDID("$FreeBSD$");
 
-#include "namespace.h"
 #include <sys/types.h>
 
 #include <assert.h>
--- src.orig/compat/vis.c
+++ src.freebsd/compat/vis.c
@@ -64,7 +64,6 @@
 #define	_DIAGASSERT(x)	assert(x)
 #endif
 
-#include "namespace.h"
 #include <sys/types.h>
 #include <sys/param.h>
 
@@ -73,8 +72,10 @@
 #include <errno.h>
 #include <stdint.h>
 #include <stdlib.h>
+#include <stdint.h>
 #include <wchar.h>
 #include <wctype.h>
+#include <limits.h>
 
 #ifdef __weak_alias
 __weak_alias(strvisx,_strvisx)
@@ -82,7 +83,6 @@
 
 #if !HAVE_VIS || !HAVE_SVIS
 #include <ctype.h>
-#include <limits.h>
 #include <stdio.h>
 #include <string.h>
 
--- src.orig/compress/compress.c
+++ src.freebsd/compress/compress.c
@@ -43,6 +43,7 @@
 
 #include <sys/cdefs.h>
 #include <sys/param.h>
+#include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/time.h>
 
@@ -236,6 +237,7 @@
 
 	if (fclose(ofp)) {
 		cwarn("%s", out);
+		ofp = NULL;
 		goto err;
 	}
 	ofp = NULL;
@@ -339,6 +341,7 @@
 	ifp = NULL;
 
 	if (fclose(ofp)) {
+		ofp = NULL;
 		cwarn("%s", out);
 		goto err;
 	}
@@ -385,9 +388,6 @@
 	}
 	if (chmod(name, fs->st_mode) && errno != EOPNOTSUPP)
 		cwarn("chmod: %s", name);
-
-	if (chflags(name, fs->st_flags) && errno != EOPNOTSUPP)
-		cwarn("chflags: %s", name);
 }
 
 static int
--- src.orig/compress/zopen.c
+++ src.freebsd/compress/zopen.c
@@ -61,6 +61,7 @@
  */
 
 #include <sys/param.h>
+#include <sys/types.h>
 #include <sys/stat.h>
 
 #include <ctype.h>
@@ -72,6 +73,10 @@
 #include <unistd.h>
 #include "zopen.h"
 
+#ifndef EFTYPE
+#define EFTYPE EINVAL
+#endif
+
 #define	BITS		16		/* Default bits. */
 #define	HSIZE		69001		/* 95% occupancy */
 
@@ -202,8 +207,8 @@
 static code_int	getcode(struct s_zstate *);
 static int	output(struct s_zstate *, code_int);
 static int	zclose(void *);
-static int	zread(void *, char *, int);
-static int	zwrite(void *, const char *, int);
+static ssize_t	zread(void *, char *, size_t);
+static ssize_t	zwrite(void *, const char *, size_t);
 
 /*-
  * Algorithm from "A Technique for High Performance Data Compression",
@@ -231,8 +236,8 @@
  * file size for noticeable speed improvement on small files.  Please direct
  * questions about this implementation to ames!jaw.
  */
-static int
-zwrite(void *cookie, const char *wbp, int num)
+static ssize_t
+zwrite(void *cookie, const char *wbp, size_t num)
 {
 	code_int i;
 	int c, disp;
@@ -452,8 +457,8 @@
  * compressed file.  The tables used herein are shared with those of the
  * compress() routine.  See the definitions above.
  */
-static int
-zread(void *cookie, char *rbp, int num)
+static ssize_t
+zread(void *cookie, char *rbp, size_t num)
 {
 	u_int count;
 	struct s_zstate *zs;
@@ -693,6 +698,7 @@
 zopen(const char *fname, const char *mode, int bits)
 {
 	struct s_zstate *zs;
+	cookie_io_functions_t zfuncs;
 
 	if ((mode[0] != 'r' && mode[0] != 'w') || mode[1] != '\0' ||
 	    bits < 0 || bits > BITS) {
@@ -728,10 +734,18 @@
 	switch (*mode) {
 	case 'r':
 		zmode = 'r';
-		return (funopen(zs, zread, NULL, NULL, zclose));
+		zfuncs.read = zread;
+		zfuncs.write = NULL;
+		zfuncs.seek = NULL;
+		zfuncs.close = zclose;
+		return fopencookie(zs, "r", zfuncs);
 	case 'w':
 		zmode = 'w';
-		return (funopen(zs, NULL, zwrite, NULL, zclose));
+		zfuncs.read = NULL;
+		zfuncs.write = zwrite;
+		zfuncs.seek = NULL;
+		zfuncs.close = zclose;
+		return fopencookie(zs, "w", zfuncs);
 	}
 	/* NOTREACHED */
 	return (NULL);
--- src.orig/coreutils/cat/cat.c
+++ src.freebsd/coreutils/cat/cat.c
@@ -68,6 +68,10 @@
 #include <wchar.h>
 #include <wctype.h>
 
+#ifndef BOOTSTRAP_CAT
+#include <sys/sendfile.h>
+#endif
+
 #include <libcasper.h>
 #include <casper/cap_fileargs.h>
 #include <casper/cap_net.h>
@@ -100,6 +104,9 @@
 /* Maximum buffer size in bytes - do not allow it to grow larger than this. */
 #define	BUFSIZE_MAX (2 * 1024 * 1024)
 
+/* Maximum length to send when using sendfile */
+#define SPLICEBUF_MAX (16 * 1024)
+
 /*
  * Small (default) buffer size in bytes. It's inefficient for this to be
  * smaller than MAXPHYS.
@@ -303,7 +310,7 @@
 cook_cat(FILE *fp)
 {
 	int ch, gobble, line, prev;
-	wint_t wch;
+	wchar_t wch;
 
 	/* Reset EOF condition on stdin. */
 	if (fp == stdin && feof(stdin))
@@ -342,23 +349,33 @@
 				continue;
 			}
 		} else if (vflag) {
-			(void)ungetc(ch, fp);
-			/*
-			 * Our getwc(3) doesn't change file position
-			 * on error.
-			 */
-			if ((wch = getwc(fp)) == WEOF) {
-				if (ferror(fp) && errno == EILSEQ) {
-					clearerr(fp);
-					/* Resync attempt. */
-					memset(&fp->_mbstate, 0, sizeof(mbstate_t));
-					if ((ch = getc(fp)) == EOF)
-						break;
+			mbstate_t st = {0};
+			unsigned char b;
+			size_t l = (size_t)-2;
+			if (ch == EOF)
+				break;
+			b = ch;
+			l = mbrtowc(&wch, (void *)&b, 1, &st);
+			if (l == (size_t)-1) {
+				wch = ch;
+				goto ilseq;
+			}
+			while (l == (size_t)-2) {
+				int nch = getc(fp);
+				if (nch == EOF) {
 					wch = ch;
 					goto ilseq;
-				} else
-					break;
+				}
+				b = nch;
+				l = mbrtowc(&wch, (void *)&b, 1, &st);
+				if (l == (size_t)-1) {
+					/* go back by the failed char */
+					ungetc(ch, fp);
+					wch = ch;
+					goto ilseq;
+				}
 			}
+			/* wch should be a valid multibyte char now */
 			if (!iswascii(wch) && !iswprint(wch)) {
 ilseq:
 				if (putchar('M') == EOF || putchar('-') == EOF)
@@ -390,6 +407,18 @@
 }
 
 static ssize_t
+spliced_copy(int rfd, int wfd)
+{
+	ssize_t ret = 1;
+	off_t off = 0;
+
+	while (ret > 0)
+		ret = sendfile(wfd, rfd, &off, SPLICEBUF_MAX);
+
+	return (ret);
+}
+
+static ssize_t
 in_kernel_copy(int rfd)
 {
 	int wfd;
@@ -400,6 +429,9 @@
 
 	while (ret > 0)
 		ret = copy_file_range(rfd, NULL, wfd, NULL, SSIZE_MAX, 0);
+
+	if (ret < 0)
+		ret = spliced_copy(rfd, wfd);
 
 	return (ret);
 }
--- src.orig/coreutils/chmod/chmod.1
+++ src.freebsd/coreutils/chmod/chmod.1
@@ -39,7 +39,7 @@
 .Nd change file modes
 .Sh SYNOPSIS
 .Nm
-.Op Fl fhv
+.Op Fl fv
 .Op Fl R Op Fl H | L | P
 .Ar mode
 .Ar
@@ -65,9 +65,6 @@
 option is specified, symbolic links on the command line are followed
 and hence unaffected by the command.
 (Symbolic links encountered during tree traversal are not followed.)
-.It Fl h
-If the file is a symbolic link, change the mode of the link itself
-rather than the file that the link points to.
 .It Fl L
 If the
 .Fl R
@@ -108,7 +105,7 @@
 If
 .Nm
 receives a
-.Dv SIGINFO
+.Dv SIGUSR1
 signal (see the
 .Cm status
 argument for
@@ -332,7 +329,6 @@
 .Sh SEE ALSO
 .Xr chflags 1 ,
 .Xr install 1 ,
-.Xr setfacl 1 ,
 .Xr chmod 2 ,
 .Xr stat 2 ,
 .Xr umask 2 ,
--- src.orig/coreutils/chmod/chmod.c
+++ src.freebsd/coreutils/chmod/chmod.c
@@ -80,7 +80,7 @@
 
 	set = NULL;
 	Hflag = Lflag = Rflag = fflag = hflag = vflag = 0;
-	while ((ch = getopt(argc, argv, "HLPRXfghorstuvwx")) != -1)
+	while ((ch = getopt(argc, argv, "HLPRXfgorstuvwx")) != -1)
 		switch (ch) {
 		case 'H':
 			Hflag = 1;
@@ -200,16 +200,24 @@
 		if (may_have_nfs4acl(p, hflag) == 0 &&
 		    (newmode & ALLPERMS) == (p->fts_statp->st_mode & ALLPERMS))
 				continue;
+		/* on linux we need to skip symlinks */
+		errno = 0;
 		if (fchmodat(AT_FDCWD, p->fts_accpath, newmode, atflag) == -1
-		    && !fflag) {
+		    && !fflag && (errno != ENOTSUP)) {
 			warn("%s", p->fts_path);
 			rval = 1;
 		} else if (vflag || siginfo) {
+			int olderr = errno;
+
 			(void)printf("%s", p->fts_path);
 
 			if (vflag > 1 || siginfo) {
 				char m1[12], m2[12];
 
+				/* do not give misleading information for linux symlinks */
+				if (olderr == ENOTSUP)
+					newmode = p->fts_statp->st_mode;
+
 				strmode(p->fts_statp->st_mode, m1);
 				strmode((p->fts_statp->st_mode &
 				    S_IFMT) | newmode, m2);
@@ -238,6 +246,7 @@
 static int
 may_have_nfs4acl(const FTSENT *ent, int hflag)
 {
+#ifndef __linux__
 	int ret;
 	static dev_t previous_dev = NODEV;
 	static int supports_acls = -1;
@@ -257,4 +266,10 @@
 	}
 
 	return (supports_acls);
+#else
+	/* Linux does not support NFSv4 ACLs */
+	(void)ent;
+	(void)hflag;
+	return 0;
+#endif
 }
--- src.orig/coreutils/chown/chgrp.1
+++ src.freebsd/coreutils/chown/chgrp.1
@@ -123,7 +123,7 @@
 If
 .Nm
 receives a
-.Dv SIGINFO
+.Dv SIGUSR1
 signal (see the
 .Cm status
 argument for
--- src.orig/coreutils/chown/chown.8
+++ src.freebsd/coreutils/chown/chown.8
@@ -138,7 +138,7 @@
 If
 .Nm
 receives a
-.Dv SIGINFO
+.Dv SIGUSR1
 signal (see the
 .Cm status
 argument for
--- src.orig/coreutils/chroot/chroot.8
+++ src.freebsd/coreutils/chroot/chroot.8
@@ -63,14 +63,10 @@
 .Ar user .
 .It Fl n
 Use the
-.Dv PROC_NO_NEW_PRIVS_CTL
-.Xr procctl 2
-command before chrooting, effectively disabling SUID/SGID bits
-for the calling process and its descendants.
-If
-.Dv security.bsd.unprivileged_chroot
-sysctl is set to 1, it will make it possible to chroot without
-superuser privileges.
+.Dv CLONE_NEWUSER
+.Xr unshare 2
+parameter before chrooting, effectively unsharing the user namespace.
+This makes it possible to chroot without superuser privileges.
 .El
 .Sh ENVIRONMENT
 The following environment variable is referenced by
--- src.orig/coreutils/chroot/chroot.c
+++ src.freebsd/coreutils/chroot/chroot.c
@@ -42,7 +42,6 @@
 #endif
 #include <sys/cdefs.h>
 #include <sys/types.h>
-#include <sys/procctl.h>
 
 #include <ctype.h>
 #include <err.h>
@@ -55,6 +54,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <sched.h>
 
 static void usage(void) __dead2;
 
@@ -67,7 +67,7 @@
 	const char	*shell;
 	gid_t		gid, *gidlist;
 	uid_t		uid;
-	int		arg, ch, error, gids;
+	int		ch, error, gids;
 	long		ngroups_max;
 	bool		nonprivileged;
 
@@ -159,10 +159,9 @@
 	}
 
 	if (nonprivileged) {
-		arg = PROC_NO_NEW_PRIVS_ENABLE;
-		error = procctl(P_PID, getpid(), PROC_NO_NEW_PRIVS_CTL, &arg);
+		error = unshare(CLONE_NEWUSER);
 		if (error != 0)
-			err(1, "procctl");
+			err(1, "unshare");
 	}
 
 	if (chdir(argv[0]) == -1 || chroot(".") == -1)
--- src.orig/coreutils/cp/cp.1
+++ src.freebsd/coreutils/cp/cp.1
@@ -125,8 +125,9 @@
 instead.
 .It Fl a
 Archive mode.
-Same as
-.Fl RpP .
+Similar to
+.Fl RpP
+but additionally tries to preserve xattrs (but ignores any failure to do so).
 .It Fl f
 For each existing destination pathname, remove it and
 create a new file, without prompting for confirmation
@@ -172,6 +173,7 @@
 to preserve the following attributes of each source
 file in the copy: modification time, access time,
 file flags, file mode, ACL, user ID, and group ID, as allowed by permissions.
+Extended attributes are not preserved, except in archive mode.
 .Pp
 If the user ID and group ID cannot be preserved, no error message
 is displayed and the exit value is not altered.
@@ -251,7 +253,7 @@
 If
 .Nm
 receives a
-.Dv SIGINFO
+.Dv SIGUSR1
 (see the
 .Cm status
 argument for
--- src.orig/coreutils/cp/cp.c
+++ src.freebsd/coreutils/cp/cp.c
@@ -84,7 +84,7 @@
 
 PATH_T to = { to.p_path, emptystring, "" };
 
-int fflag, iflag, lflag, nflag, pflag, sflag, vflag;
+int fflag, iflag, lflag, nflag, pflag, sflag, vflag, aflag;
 static int Hflag, Lflag, Rflag, rflag;
 volatile sig_atomic_t info;
 
@@ -121,6 +121,7 @@
 			Rflag = 1;
 			break;
 		case 'a':
+			aflag = 1;
 			pflag = 1;
 			Rflag = 1;
 			Pflag = 1;
@@ -450,6 +451,7 @@
 				if (preserve_dir_acls(curr->fts_statp,
 				    curr->fts_accpath, to.p_path) != 0)
 					rval = 1;
+				if (aflag) preserve_dir_xattrs(curr->fts_accpath, to.p_path);
 			} else {
 				mode = curr->fts_statp->st_mode;
 				if ((mode & (S_ISUID | S_ISGID | S_ISTXT)) ||
--- src.orig/coreutils/cp/extern.h
+++ src.freebsd/coreutils/cp/extern.h
@@ -38,7 +38,7 @@
 } PATH_T;
 
 extern PATH_T to;
-extern int fflag, iflag, lflag, nflag, pflag, sflag, vflag;
+extern int fflag, iflag, lflag, nflag, pflag, sflag, vflag, aflag;
 extern volatile sig_atomic_t info;
 
 __BEGIN_DECLS
@@ -49,5 +49,7 @@
 int	setfile(struct stat *, int);
 int	preserve_dir_acls(struct stat *, char *, char *);
 int	preserve_fd_acls(int, int);
+int	preserve_fd_xattrs(int, int);
+int	preserve_dir_xattrs(const char *, const char *);
 void	usage(void) __dead2;
 __END_DECLS
--- src.orig/coreutils/cp/utils.c
+++ src.freebsd/coreutils/cp/utils.c
@@ -38,6 +38,8 @@
 #include <sys/param.h>
 #include <sys/acl.h>
 #include <sys/stat.h>
+#include <sys/xattr.h>
+#include <acl/libacl.h>
 
 #include <err.h>
 #include <errno.h>
@@ -46,6 +48,8 @@
 #include <limits.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
+#include <signal.h>
 #include <sysexits.h>
 #include <unistd.h>
 
@@ -178,9 +182,14 @@
 			if (use_copy_file_range) {
 				wcount = copy_file_range(from_fd, NULL,
 				    to_fd, NULL, SSIZE_MAX, 0);
-				if (wcount < 0 && errno == EINVAL) {
-					/* Prob a non-seekable FD */
+				if (wcount < 0) switch (errno) {
+				case EINVAL: /* Prob a non-seekable FD */
+				case EXDEV: /* Cross-FS link */
+				case ENOSYS: /* Syscall not supported */
 					use_copy_file_range = 0;
+					break;
+				default:
+					break;
 				}
 			}
 			if (!use_copy_file_range) {
@@ -223,6 +232,7 @@
 			rval = 1;
 		if (pflag && preserve_fd_acls(from_fd, to_fd) != 0)
 			rval = 1;
+		if (aflag) preserve_fd_xattrs(from_fd, to_fd);
 		if (close(to_fd)) {
 			warn("%s", to.p_path);
 			rval = 1;
@@ -349,12 +359,13 @@
 
 	if (!gotstat || fs->st_mode != ts.st_mode)
 		if (fdval ? fchmod(fd, fs->st_mode) :
-		    (islink ? lchmod(to.p_path, fs->st_mode) :
+		    (islink ? 0 :
 		    chmod(to.p_path, fs->st_mode))) {
 			warn("chmod: %s", to.p_path);
 			rval = 1;
 		}
 
+#if 0
 	if (!gotstat || fs->st_flags != ts.st_flags)
 		if (fdval ?
 		    fchflags(fd, fs->st_flags) :
@@ -363,6 +374,7 @@
 			warn("chflags: %s", to.p_path);
 			rval = 1;
 		}
+#endif
 
 	return (rval);
 }
@@ -371,9 +383,9 @@
 preserve_fd_acls(int source_fd, int dest_fd)
 {
 	acl_t acl;
-	acl_type_t acl_type;
-	int acl_supported = 0, ret, trivial;
+	int acl_supported = 0, ret;
 
+#if 0
 	ret = fpathconf(source_fd, _PC_ACL_NFS4);
 	if (ret > 0 ) {
 		acl_supported = 1;
@@ -382,13 +394,13 @@
 		warn("fpathconf(..., _PC_ACL_NFS4) failed for %s", to.p_path);
 		return (1);
 	}
+#endif
 	if (acl_supported == 0) {
-		ret = fpathconf(source_fd, _PC_ACL_EXTENDED);
+		ret = acl_extended_fd(source_fd);
 		if (ret > 0 ) {
 			acl_supported = 1;
-			acl_type = ACL_TYPE_ACCESS;
-		} else if (ret < 0 && errno != EINVAL) {
-			warn("fpathconf(..., _PC_ACL_EXTENDED) failed for %s",
+		} else if (ret < 0 && errno != ENOTSUP) {
+			warn("acl_extended_fd() failed for %s",
 			    to.p_path);
 			return (1);
 		}
@@ -396,21 +408,12 @@
 	if (acl_supported == 0)
 		return (0);
 
-	acl = acl_get_fd_np(source_fd, acl_type);
+	acl = acl_get_fd(source_fd);
 	if (acl == NULL) {
 		warn("failed to get acl entries while setting %s", to.p_path);
 		return (1);
 	}
-	if (acl_is_trivial_np(acl, &trivial)) {
-		warn("acl_is_trivial() failed for %s", to.p_path);
-		acl_free(acl);
-		return (1);
-	}
-	if (trivial) {
-		acl_free(acl);
-		return (0);
-	}
-	if (acl_set_fd_np(dest_fd, acl, acl_type) < 0) {
+	if (acl_set_fd(dest_fd, acl) < 0) {
 		warn("failed to set acl entries for %s", to.p_path);
 		acl_free(acl);
 		return (1);
@@ -424,11 +427,11 @@
 {
 	acl_t (*aclgetf)(const char *, acl_type_t);
 	int (*aclsetf)(const char *, acl_type_t, acl_t);
-	struct acl *aclp;
 	acl_t acl;
 	acl_type_t acl_type;
-	int acl_supported = 0, ret, trivial;
+	int acl_supported = 0, ret;
 
+#if 0
 	ret = pathconf(source_dir, _PC_ACL_NFS4);
 	if (ret > 0) {
 		acl_supported = 1;
@@ -437,13 +440,14 @@
 		warn("fpathconf(..., _PC_ACL_NFS4) failed for %s", source_dir);
 		return (1);
 	}
-	if (acl_supported == 0) {
-		ret = pathconf(source_dir, _PC_ACL_EXTENDED);
+#endif
+	if (!S_ISLNK(fs->st_mode) && acl_supported == 0) {
+		ret = acl_extended_file(source_dir);
 		if (ret > 0) {
 			acl_supported = 1;
 			acl_type = ACL_TYPE_ACCESS;
-		} else if (ret < 0 && errno != EINVAL) {
-			warn("fpathconf(..., _PC_ACL_EXTENDED) failed for %s",
+		} else if (ret < 0 && errno != ENOTSUP) {
+			warn("acl_extended_file() failed for %s",
 			    source_dir);
 			return (1);
 		}
@@ -451,30 +455,22 @@
 	if (acl_supported == 0)
 		return (0);
 
-	/*
-	 * If the file is a link we will not follow it.
-	 */
-	if (S_ISLNK(fs->st_mode)) {
-		aclgetf = acl_get_link_np;
-		aclsetf = acl_set_link_np;
-	} else {
-		aclgetf = acl_get_file;
-		aclsetf = acl_set_file;
-	}
+	aclgetf = acl_get_file;
+	aclsetf = acl_set_file;
+
 	if (acl_type == ACL_TYPE_ACCESS) {
 		/*
 		 * Even if there is no ACL_TYPE_DEFAULT entry here, a zero
 		 * size ACL will be returned. So it is not safe to simply
 		 * check the pointer to see if the default ACL is present.
 		 */
-		acl = aclgetf(source_dir, ACL_TYPE_DEFAULT);
+		acl = acl_get_file(source_dir, ACL_TYPE_DEFAULT);
 		if (acl == NULL) {
 			warn("failed to get default acl entries on %s",
 			    source_dir);
 			return (1);
 		}
-		aclp = &acl->ats_acl;
-		if (aclp->acl_cnt != 0 && aclsetf(dest_dir,
+		if (acl_entries(acl) > 0 && aclsetf(dest_dir,
 		    ACL_TYPE_DEFAULT, acl) < 0) {
 			warn("failed to set default acl entries on %s",
 			    dest_dir);
@@ -488,15 +484,6 @@
 		warn("failed to get acl entries on %s", source_dir);
 		return (1);
 	}
-	if (acl_is_trivial_np(acl, &trivial)) {
-		warn("acl_is_trivial() failed on %s", source_dir);
-		acl_free(acl);
-		return (1);
-	}
-	if (trivial) {
-		acl_free(acl);
-		return (0);
-	}
 	if (aclsetf(dest_dir, acl_type, acl) < 0) {
 		warn("failed to set acl entries on %s", dest_dir);
 		acl_free(acl);
@@ -504,6 +491,138 @@
 	}
 	acl_free(acl);
 	return (0);
+}
+
+/* for now we don't really care about warnings or result,
+ * we only support the quiet case for archive mode
+ */
+int
+preserve_fd_xattrs(int source_fd, int dest_fd)
+{
+    ssize_t size;
+    char buf[256], vbuf[128];
+    char *names, *name, *nend;
+    char *value = vbuf;
+    int retval = 0, rerrno = 0;
+    size_t vbufs = sizeof(vbuf);
+
+    size = flistxattr(source_fd, NULL, 0);
+    if (size < 0) {
+        return 1;
+    }
+
+    if (size < (ssize_t)sizeof(buf)) {
+        names = buf;
+    } else {
+        names = malloc(size + 1);
+        if (!names) err(1, "Not enough memory");
+    }
+
+    size = flistxattr(source_fd, names, size);
+    if (size < 0) {
+        if (names != buf) free(names);
+        return 1;
+    }
+    names[size] = '\0';
+    nend = names + size;
+
+    for (name = names; name != nend; name = strchr(name, '\0') + 1) {
+        size = fgetxattr(source_fd, name, NULL, 0);
+        if (size < 0) {
+            retval = 1;
+            rerrno = errno;
+            continue;
+        }
+        if (size > (ssize_t)vbufs) {
+            if (value == vbuf) value = NULL;
+            value = realloc(value, size);
+            if (!value) {
+                err(1, "Not enough memory");
+            }
+            vbufs = size;
+        }
+        size = fgetxattr(source_fd, name, value, size);
+        if (size < 0) {
+            retval = 1;
+            rerrno = errno;
+            continue;
+        }
+        if (fsetxattr(dest_fd, name, value, size, 0)) {
+            retval = 1;
+            rerrno = errno;
+        }
+    }
+
+    if (names != buf) free(names);
+    if (value != vbuf) free(value);
+    if (retval) {
+        errno = rerrno;
+    }
+    return retval;
+}
+
+int
+preserve_dir_xattrs(const char *source_dir, const char *dest_dir) {
+    ssize_t size;
+    char buf[256], vbuf[128];
+    char *names, *name, *nend;
+    char *value = vbuf;
+    int retval = 0, rerrno = 0;
+    size_t vbufs = sizeof(vbuf);
+
+    size = llistxattr(source_dir, NULL, 0);
+    if (size < 0) {
+        return 1;
+    }
+
+    if (size < (ssize_t)sizeof(buf)) {
+        names = buf;
+    } else {
+        names = malloc(size + 1);
+        if (!names) err(1, "Not enough memory");
+    }
+
+    size = llistxattr(source_dir, names, size);
+    if (size < 0) {
+        if (names != buf) free(names);
+        return 1;
+    }
+    names[size] = '\0';
+    nend = names + size;
+
+    for (name = names; name != nend; name = strchr(name, '\0') + 1) {
+        size = lgetxattr(source_dir, name, NULL, 0);
+        if (size < 0) {
+            retval = 1;
+            rerrno = errno;
+            continue;
+        }
+        if (size > (ssize_t)vbufs) {
+            if (value == vbuf) value = NULL;
+            value = realloc(value, size);
+            if (!value) {
+                err(1, "Not enough memory");
+            }
+            vbufs = size;
+        }
+        size = lgetxattr(source_dir, name, value, size);
+        if (size < 0) {
+            retval = 1;
+            rerrno = errno;
+            continue;
+        }
+        if (lsetxattr(dest_dir, name, value, size, 0)) {
+            retval = 1;
+            rerrno = errno;
+        }
+    }
+
+    if (names != buf) free(names);
+    if (value != vbuf) free(value);
+    if (retval) {
+        errno = rerrno;
+    }
+    return retval;
 }
 
 void
--- src.orig/coreutils/cut/cut.c
+++ src.freebsd/coreutils/cut/cut.c
@@ -275,14 +275,15 @@
 static int
 b_n_cut(FILE *fp, const char *fname)
 {
-	size_t col, i, lbuflen;
-	char *lbuf;
+	size_t col, i, bufsize = 0;
+	ssize_t lbuflen;
+	char *lbuf = NULL;
 	int canwrite, clen, warned;
 	mbstate_t mbs;
 
 	memset(&mbs, 0, sizeof(mbs));
 	warned = 0;
-	while ((lbuf = fgetln(fp, &lbuflen)) != NULL) {
+	while ((lbuflen = getline(&lbuf, &bufsize, fp)) >= 0) {
 		for (col = 0; lbuflen > 0; col += clen) {
 			if ((clen = mbrlen(lbuf, lbuflen, &mbs)) < 0) {
 				if (!warned) {
@@ -331,6 +332,7 @@
 		if (lbuflen > 0)
 			putchar('\n');
 	}
+	free(lbuf);
 	return (warned);
 }
 
@@ -389,21 +391,22 @@
 	int field, i, isdelim;
 	char *pos, *p;
 	int output;
-	char *lbuf, *mlbuf;
-	size_t clen, lbuflen, reallen;
+	char *lbuf = NULL;
+	size_t clen, bufsize = 0, reallen;
+	ssize_t lbuflen;
 
-	mlbuf = NULL;
-	while ((lbuf = fgetln(fp, &lbuflen)) != NULL) {
+	while ((lbuflen = getline(&lbuf, &bufsize, fp)) >= 0) {
 		reallen = lbuflen;
 		/* Assert EOL has a newline. */
-		if (*(lbuf + lbuflen - 1) != '\n') {
+		if (lbuflen > 0 && *(lbuf + lbuflen - 1) != '\n') {
 			/* Can't have > 1 line with no trailing newline. */
-			mlbuf = malloc(lbuflen + 1);
-			if (mlbuf == NULL)
-				err(1, "malloc");
-			memcpy(mlbuf, lbuf, lbuflen);
-			*(mlbuf + lbuflen) = '\n';
-			lbuf = mlbuf;
+			if ((ssize_t)bufsize < (lbuflen + 1)) {
+				bufsize = lbuflen + 1;
+				lbuf = realloc(lbuf, bufsize);
+			}
+			if (lbuf == NULL)
+				err(1, "realloc");
+			lbuf[lbuflen] = '\n';
 			reallen++;
 		}
 		output = 0;
@@ -411,7 +414,7 @@
 			clen = mbrtowc(&ch, p, lbuf + reallen - p, NULL);
 			if (clen == (size_t)-1 || clen == (size_t)-2) {
 				warnc(EILSEQ, "%s", fname);
-				free(mlbuf);
+				free(lbuf);
 				return (1);
 			}
 			if (clen == 0)
@@ -438,7 +441,7 @@
 				    NULL);
 				if (clen == (size_t)-1 || clen == (size_t)-2) {
 					warnc(EILSEQ, "%s", fname);
-					free(mlbuf);
+					free(lbuf);
 					return (1);
 				}
 				if (clen == 0)
@@ -470,7 +473,7 @@
 		}
 		(void)putchar('\n');
 	}
-	free(mlbuf);
+	free(lbuf);
 	return (0);
 }
 
--- src.orig/coreutils/date/date.1
+++ src.freebsd/coreutils/date/date.1
@@ -128,7 +128,7 @@
 .Oc Ar MM Op Cm \&. Ar SS
 .Sm on
 format.
-Parsing is done using
+Parsing is done using FreeBSD
 .Xr strptime 3 .
 .It Fl I Ns Op Ar FMT
 Use
@@ -327,7 +327,7 @@
 The format string may contain any of the conversion specifications
 described in the
 .Xr strftime 3
-manual page, as well as any arbitrary text.
+FreeBSD manual page, as well as any arbitrary text.
 A newline
 .Pq Ql \en
 character is always output after the characters specified by
--- src.orig/coreutils/date/date.c
+++ src.freebsd/coreutils/date/date.c
@@ -56,6 +56,8 @@
 #include <syslog.h>
 #include <unistd.h>
 #include <utmpx.h>
+#include <time_bsd.h>
+#include <langinfo.h>
 
 #include "vary.h"
 
@@ -215,7 +217,7 @@
 		setlocale(LC_TIME, "C");
 
 
-	(void)strftime(buf, sizeof(buf), format, lt);
+	(void)strftime_bsd(buf, sizeof(buf), format, lt);
 	printdate(buf);
 }
 
@@ -238,10 +240,10 @@
 	for (it = iso8601_fmts; it <= iso8601_selected; it++)
 		strlcat(fmtbuf, it->format_string, sizeof(fmtbuf));
 
-	(void)strftime(buf, sizeof(buf), fmtbuf, lt);
+	(void)strftime_bsd(buf, sizeof(buf), fmtbuf, lt);
 
 	if (iso8601_selected > iso8601_fmts) {
-		(void)strftime(tzbuf, sizeof(tzbuf), "%z", lt);
+		(void)strftime_bsd(tzbuf, sizeof(tzbuf), "%z", lt);
 		memmove(&tzbuf[4], &tzbuf[3], 3);
 		tzbuf[3] = ':';
 		strlcat(buf, tzbuf, sizeof(buf));
@@ -267,7 +269,7 @@
 	lt->tm_isdst = -1;		/* divine correct DST */
 
 	if (fmt != NULL) {
-		t = strptime(p, fmt, lt);
+		t = strptime_bsd(p, fmt, lt);
 		if (t == NULL) {
 			fprintf(stderr, "Failed conversion of ``%s''"
 				" using format ``%s''\n", p, fmt);
@@ -348,14 +350,18 @@
 	if (!jflag) {
 		utx.ut_type = OLD_TIME;
 		memset(utx.ut_id, 0, sizeof(utx.ut_id));
-		(void)gettimeofday(&utx.ut_tv, NULL);
+		(void)gettimeofday(&tv, NULL);
+		utx.ut_tv.tv_sec = tv.tv_sec;
+		utx.ut_tv.tv_usec = tv.tv_usec;
 		pututxline(&utx);
 		tv.tv_sec = tval;
 		tv.tv_usec = 0;
 		if (settimeofday(&tv, NULL) != 0)
 			err(1, "settimeofday (timeval)");
 		utx.ut_type = NEW_TIME;
-		(void)gettimeofday(&utx.ut_tv, NULL);
+		(void)gettimeofday(&tv, NULL);
+		utx.ut_tv.tv_sec = tv.tv_sec;
+		utx.ut_tv.tv_usec = tv.tv_usec;
 		pututxline(&utx);
 
 		if ((p = getlogin()) == NULL)
--- src.orig/coreutils/dd/dd.1
+++ src.freebsd/coreutils/dd/dd.1
@@ -416,7 +416,7 @@
 If
 .Nm
 receives a
-.Dv SIGINFO
+.Dv SIGUSR1
 (see the
 .Cm status
 argument for
--- src.orig/coreutils/dd/dd.c
+++ src.freebsd/coreutils/dd/dd.c
@@ -48,9 +48,6 @@
 #include <sys/param.h>
 #include <sys/stat.h>
 #include <sys/capsicum.h>
-#include <sys/conf.h>
-#include <sys/disklabel.h>
-#include <sys/filio.h>
 #include <sys/mtio.h>
 #include <sys/time.h>
 
@@ -146,7 +143,7 @@
 	u_int cnt;
 	int iflags, oflags;
 	cap_rights_t rights;
-	unsigned long cmds[] = { FIODTYPE, MTIOCTOP };
+	unsigned long cmds[] = { 0 };
 
 	if (in.name == NULL) {
 		in.name = "stdin";
@@ -182,7 +179,7 @@
 			oflags = fcntl(out.fd, F_GETFL);
 			if (oflags == -1)
 				err(1, "unable to get fd flags for stdout");
-			oflags |= O_FSYNC;
+			oflags |= O_SYNC;
 			if (fcntl(out.fd, F_SETFL, oflags) == -1)
 				err(1, "unable to set fd flags for stdout");
 		}
@@ -191,7 +188,7 @@
 		if (!(ddflags & (C_SEEK | C_NOTRUNC)))
 			oflags |= O_TRUNC;
 		if (ddflags & C_OFSYNC)
-			oflags |= O_FSYNC;
+			oflags |= O_SYNC;
 		if (ddflags & C_ODIRECT)
 			oflags |= O_DIRECT;
 		before_io();
@@ -323,23 +320,16 @@
 getfdtype(IO *io)
 {
 	struct stat sb;
-	int type;
 
 	if (fstat(io->fd, &sb) == -1)
 		err(1, "%s", io->name);
 	if (S_ISREG(sb.st_mode))
 		io->flags |= ISTRUNC;
-	if (S_ISCHR(sb.st_mode) || S_ISBLK(sb.st_mode)) { 
-		if (ioctl(io->fd, FIODTYPE, &type) == -1) {
-			err(1, "%s", io->name);
-		} else {
-			if (type & D_TAPE)
-				io->flags |= ISTAPE;
-			else if (type & (D_DISK | D_MEM))
-				io->flags |= ISSEEK;
-			if (S_ISCHR(sb.st_mode) && (type & D_TAPE) == 0)
-				io->flags |= ISCHR;
-		}
+	if (S_ISCHR(sb.st_mode) || S_ISBLK(sb.st_mode)) {
+		if (S_ISCHR(sb.st_mode))
+			io->flags |= ISCHR;
+		if (S_ISBLK(sb.st_mode))
+			io->flags |= ISSEEK;
 		return;
 	}
 	errno = 0;
--- src.orig/coreutils/dd/dd.h
+++ src.freebsd/coreutils/dd/dd.h
@@ -35,6 +35,8 @@
  *	@(#)dd.h	8.3 (Berkeley) 4/2/94
  */
 
+#include <sys/types.h>
+
 /* Input/output stream state. */
 typedef struct {
 	u_char		*db;		/* buffer address */
--- src.orig/coreutils/dd/extern.h
+++ src.freebsd/coreutils/dd/extern.h
@@ -35,6 +35,8 @@
  *	@(#)extern.h	8.3 (Berkeley) 4/2/94
  */
 
+#include <signal.h>
+
 void block(void);
 void block_close(void);
 void dd_out(int);
--- src.orig/coreutils/dd/position.c
+++ src.freebsd/coreutils/dd/position.c
@@ -70,9 +70,9 @@
 	 *
 	 * Bail out if the calculation of a file offset would overflow.
 	 */
-	if ((io->flags & ISCHR) == 0 && (n < 0 || n > OFF_MAX / (ssize_t)sz))
+	if ((io->flags & ISCHR) == 0 && (n < 0 || n > LONG_MAX / (ssize_t)sz))
 		errx(1, "seek offsets cannot be larger than %jd",
-		    (intmax_t)OFF_MAX);
+		    (intmax_t)LONG_MAX);
 	else if ((io->flags & ISCHR) != 0 && (uint64_t)n > UINT64_MAX / sz)
 		errx(1, "seek offsets cannot be larger than %ju",
 		    (uintmax_t)UINT64_MAX);
--- src.orig/coreutils/df/df.1
+++ src.freebsd/coreutils/df/df.1
@@ -38,7 +38,7 @@
 .Nm
 .Op Fl -libxo
 .Op Fl b | g | H | h | k | m | P
-.Op Fl acilnT
+.Op Fl acilT
 .Op Fl \&,
 .Op Fl t Ar type
 .Op Ar file | filesystem ...
@@ -129,15 +129,6 @@
 This overrides any
 .Ev BLOCKSIZE
 specification from the environment.
-.It Fl n
-Print out the previously obtained statistics from the file systems.
-This option should be used if it is possible that one or more
-file systems are in a state such that they will not be able to provide
-statistics without a long delay.
-When this option is specified,
-.Nm
-will not request new statistics from the file systems, but will respond
-with the possibly stale statistics that were previously obtained.
 .It Fl P
 Explicitly use 512 byte blocks, overriding any
 .Ev BLOCKSIZE
@@ -221,7 +212,7 @@
 .Fl t
 option can be specified only once:
 .Bd -literal -offset indent
-$ df -i -n -t nodevfs,linsysfs
+$ df -i -t nodevfs,linsysfs
 Filesystem   1K-blocks      Used      Avail Capacity iused     ifree %iused
 Mounted on
 /dev/ada1p2  223235736 159618992   45757888    78% 1657590  27234568    6%   /
@@ -289,13 +280,6 @@
 command appeared in
 .At v1 .
 .Sh BUGS
-The
-.Fl n
-flag is ignored if a file or file system is specified.
-Also, if a mount
-point is not accessible by the user, it is possible that the file system
-information could be stale.
-.Pp
 The
 .Fl b
 and
--- src.orig/coreutils/df/df.c
+++ src.freebsd/coreutils/df/df.c
@@ -48,8 +48,8 @@
 #include <sys/cdefs.h>
 #include <sys/param.h>
 #include <sys/stat.h>
+#include <sys/statvfs.h>
 #include <sys/mount.h>
-#include <sys/sysctl.h>
 #include <getopt.h>
 #include <libutil.h>
 #include <locale.h>
@@ -60,10 +60,38 @@
 #include <sysexits.h>
 #include <unistd.h>
 #include <libxo/xo.h>
+#include <assert.h>
+#include <mntent.h>
 
 #define UNITS_SI	1
 #define UNITS_2		2
 
+/*
+ * Static list of network filesystems
+ *
+ * This replaces the makenetvfslist() function from FreeBSD, but this
+ * list should be made in to something we can generate at runtime or
+ * just expand the list.
+ */
+#define NETVFSLIST "nonfs,nfs4,smb,cifs"
+
+/* combining data from getmntent() and statvfs() on Linux */
+struct mntinfo {
+    char *f_mntfromname;          /* mnt_fsname from getmntent */
+    char *f_mntonname;            /* mnt_dir from getmntent */
+    char *f_fstypename;           /* mnt_fsname from getmntent */
+    char *f_opts;                 /* mnt_opts from getmntent */
+    unsigned long f_bsize;        /* f_bsize from statvfs */
+    fsblkcnt_t f_blocks;          /* f_blocks from statvfs */
+    fsblkcnt_t f_bfree;           /* f_bfree from statvfs */
+    fsblkcnt_t f_bavail;          /* f_bavail from statvfs */
+    fsfilcnt_t f_files;           /* f_files from statvfs */
+    fsfilcnt_t f_ffree;           /* f_ffree from statvfs */
+    unsigned long f_flag;         /* f_flag from statvfs */
+    dev_t f_dev;                  /* st_dev from stat */
+    unsigned int f_selected;      /* used internally here only */
+};
+
 /* Maximum widths of various fields. */
 struct maxwidths {
 	int	mntfrom;
@@ -75,20 +103,20 @@
 	int	ifree;
 };
 
-static void	  addstat(struct statfs *, struct statfs *);
-static char	 *getmntpt(const char *);
+static void	  addstat(struct mntinfo *, struct mntinfo *);
+static char	 *getmntpt(struct mntinfo **, const size_t, const char *);
 static const char **makevfslist(char *fslist, int *skip);
 static int	  checkvfsname(const char *vfsname, const char **vfslist, int skip);
 static int	  checkvfsselected(char *);
 static int	  int64width(int64_t);
-static char	 *makenetvfslist(void);
-static void	  prthuman(const struct statfs *, int64_t);
+static void	  prthuman(const struct mntinfo *, int64_t);
 static void	  prthumanval(const char *, int64_t);
 static intmax_t	  fsbtoblk(int64_t, uint64_t, u_long);
-static void	  prtstat(struct statfs *, struct maxwidths *);
-static size_t	  regetmntinfo(struct statfs **, long);
-static void	  update_maxwidths(struct maxwidths *, const struct statfs *);
+static void	  prtstat(struct mntinfo *, struct maxwidths *);
+static void	  update_maxwidths(struct maxwidths *, const struct mntinfo *);
 static void	  usage(void);
+static int	  getmntinfo(struct mntinfo **);
+static void	  freemntinfo(struct mntinfo *, int);
 
 static __inline int
 imax(int a, int b)
@@ -96,7 +124,7 @@
 	return (a > b ? a : b);
 }
 
-static int	  aflag = 0, cflag, hflag, iflag, kflag, lflag = 0, nflag, Tflag;
+static int	  aflag = 0, cflag, hflag, iflag, kflag, lflag = 0, Tflag;
 static int	  thousands;
 static int	  skipvfs_l, skipvfs_t;
 static const char **vfslist_l, **vfslist_t;
@@ -111,9 +139,9 @@
 main(int argc, char *argv[])
 {
 	struct stat stbuf;
-	struct statfs statfsbuf, totalbuf;
+	struct mntinfo *mntbuf = NULL;
+	struct mntinfo totalbuf;
 	struct maxwidths maxwidths;
-	struct statfs *mntbuf;
 	char *mntpt;
 	int i, mntsize;
 	int ch, rv;
@@ -122,13 +150,12 @@
 	memset(&maxwidths, 0, sizeof(maxwidths));
 	memset(&totalbuf, 0, sizeof(totalbuf));
 	totalbuf.f_bsize = DEV_BSIZE;
-	strlcpy(totalbuf.f_mntfromname, "total", MNAMELEN);
 
 	argc = xo_parse_args(argc, argv);
 	if (argc < 0)
 		exit(1);
 
-	while ((ch = getopt_long(argc, argv, "+abcgHhiklmnPt:T,", long_options,
+	while ((ch = getopt_long(argc, argv, "+abcgHhiklmPt:T,", long_options,
 	    NULL)) != -1)
 		switch (ch) {
 		case 'a':
@@ -173,7 +200,7 @@
 			/* Ignore duplicate -l */
 			if (lflag)
 				break;
-			vfslist_l = makevfslist(makenetvfslist(), &skipvfs_l);
+			vfslist_l = makevfslist(NETVFSLIST, &skipvfs_l);
 			lflag = 1;
 			break;
 		case 'm':
@@ -181,7 +208,6 @@
 			hflag = 0;
 			break;
 		case 'n':
-			nflag = 1;
 			break;
 		case 't':
 			if (vfslist_t != NULL)
@@ -202,32 +228,28 @@
 	argv += optind;
 
 	rv = EXIT_SUCCESS;
-	if (!*argv) {
-		/* everything (modulo -t) */
-		mntsize = getmntinfo(&mntbuf, MNT_NOWAIT);
-		mntsize = regetmntinfo(&mntbuf, mntsize);
-	} else {
-		/* just the filesystems specified on the command line */
-		mntbuf = malloc(argc * sizeof(*mntbuf));
-		if (mntbuf == NULL)
-			xo_err(1, "malloc()");
-		mntsize = 0;
-		/* continued in for loop below */
-	}
+	mntsize = getmntinfo(&mntbuf);
 
 	xo_open_container("storage-system-information");
 	xo_open_list("filesystem");
 
+	/* unselect all filesystems if an explicit list is given */
+	if (*argv) {
+		for (i = 0; i < mntsize; i++) {
+			mntbuf[i].f_selected = 0;
+		}
+	}
+
 	/* iterate through specified filesystems */
 	for (; *argv; argv++) {
 		if (stat(*argv, &stbuf) < 0) {
-			if ((mntpt = getmntpt(*argv)) == NULL) {
+			if ((mntpt = getmntpt(&mntbuf, mntsize, *argv)) == NULL) {
 				xo_warn("%s", *argv);
 				rv = EXIT_FAILURE;
 				continue;
 			}
 		} else if (S_ISCHR(stbuf.st_mode)) {
-			mntpt = getmntpt(*argv);
+			mntpt = getmntpt(&mntbuf, mntsize, *argv);
 			if (mntpt == NULL) {
 				xo_warnx("%s: not mounted", *argv);
 				rv = EXIT_FAILURE;
@@ -237,44 +259,25 @@
 			mntpt = *argv;
 		}
 
-		/*
-		 * Statfs does not take a `wait' flag, so we cannot
-		 * implement nflag here.
-		 */
-		if (statfs(mntpt, &statfsbuf) < 0) {
-			xo_warn("%s", mntpt);
-			rv = EXIT_FAILURE;
-			continue;
+		for (i = 0; i < mntsize; i++) {
+			/* selected specified filesystems if the mount point or device matches */
+			if (((stbuf.st_dev == mntbuf[i].f_dev) || !strcmp(mntbuf[i].f_mntfromname, mntpt) || !strcmp(mntbuf[i].f_mntonname, mntpt)) && checkvfsselected(mntbuf[i].f_fstypename) == 0) {
+				mntbuf[i].f_selected = 1;
+				break;
+			}
 		}
-
-		/*
-		 * Check to make sure the arguments we've been given are
-		 * satisfied.  Return an error if we have been asked to
-		 * list a mount point that does not match the other args
-		 * we've been given (-l, -t, etc.).
-		 */
-		if (checkvfsselected(statfsbuf.f_fstypename) != 0) {
-			rv = EXIT_FAILURE;
-			continue;
-		}
-
-		/* the user asked for it, so ignore the ignore flag */
-		statfsbuf.f_flags &= ~MNT_IGNORE;
-
-		/* add to list */
-		mntbuf[mntsize++] = statfsbuf;
 	}
 
 	memset(&maxwidths, 0, sizeof(maxwidths));
 	for (i = 0; i < mntsize; i++) {
-		if (aflag || (mntbuf[i].f_flags & MNT_IGNORE) == 0) {
+		if ((aflag || (mntbuf[i].f_blocks > 0)) && mntbuf[i].f_selected) {
 			update_maxwidths(&maxwidths, &mntbuf[i]);
 			if (cflag)
 				addstat(&totalbuf, &mntbuf[i]);
 		}
 	}
 	for (i = 0; i < mntsize; i++)
-		if (aflag || (mntbuf[i].f_flags & MNT_IGNORE) == 0)
+		if ((aflag || (mntbuf[i].f_blocks > 0)) && mntbuf[i].f_selected)
 			prtstat(&mntbuf[i], &maxwidths);
 
 	xo_close_list("filesystem");
@@ -285,19 +288,21 @@
 	xo_close_container("storage-system-information");
 	if (xo_finish() < 0)
 		rv = EXIT_FAILURE;
+	freemntinfo(mntbuf, mntsize);
 	exit(rv);
 }
 
 static char *
-getmntpt(const char *name)
+getmntpt(struct mntinfo **mntbuf, const size_t mntsize, const char *name)
 {
-	size_t mntsize, i;
-	struct statfs *mntbuf;
+	size_t i;
 
-	mntsize = getmntinfo(&mntbuf, MNT_NOWAIT);
+	if (mntsize == 0 || mntbuf == NULL || name == NULL)
+		return NULL;
+
 	for (i = 0; i < mntsize; i++) {
-		if (!strcmp(mntbuf[i].f_mntfromname, name))
-			return (mntbuf[i].f_mntonname);
+		if (mntbuf[i] == NULL)
+			continue;
 	}
 	return (NULL);
 }
@@ -374,6 +379,7 @@
 	return (result);
 }
 
+#if 0
 /*
  * Make a pass over the file system info in ``mntbuf'' filtering out
  * file system types not in vfslist_{l,t} and possibly re-stating to get
@@ -410,9 +416,10 @@
 	}
 	return (j);
 }
+#endif
 
 static void
-prthuman(const struct statfs *sfsp, int64_t used)
+prthuman(const struct mntinfo *sfsp, int64_t used)
 {
 
 	prthumanval("  {:blocks/%6s}", sfsp->f_blocks * sfsp->f_bsize);
@@ -456,7 +463,7 @@
 }
 
 /*
- * Convert statfs returned file system size into BLOCKSIZE units.
+ * Convert statvfs returned file system size into BLOCKSIZE units.
  */
 static intmax_t
 fsbtoblk(int64_t num, uint64_t fsbs, u_long bs)
@@ -468,7 +475,7 @@
  * Print out status about a file system.
  */
 static void
-prtstat(struct statfs *sfsp, struct maxwidths *mwp)
+prtstat(struct mntinfo *sfsp, struct maxwidths *mwp)
 {
 	static long blocksize;
 	static int headerlen, timesthrough = 0;
@@ -542,7 +549,7 @@
 		    mwp->avail, fsbtoblk(sfsp->f_bavail,
 		    sfsp->f_bsize, blocksize));
 	}
-	xo_emit(" {:used-percent/%5.0f}{U:%%}",
+	xo_emit("   {:used-percent/%5.0f}{U:%%}",
 	    availblks == 0 ? 100.0 : (double)used / (double)availblks * 100.0);
 	if (iflag) {
 		inodes = sfsp->f_files;
@@ -567,23 +574,23 @@
 		}
 	} else
 		xo_emit("  ");
-	if (strncmp(sfsp->f_mntfromname, "total", MNAMELEN) != 0)
-		xo_emit("  {:mounted-on}", sfsp->f_mntonname);
+	if (strcmp(sfsp->f_mntfromname, "total") != 0)
+		xo_emit("{:mounted-on}", sfsp->f_mntonname);
 	xo_emit("\n");
 	xo_close_instance("filesystem");
 }
 
 static void
-addstat(struct statfs *totalfsp, struct statfs *statfsp)
+addstat(struct mntinfo *totalfsp, struct mntinfo *statvfsp)
 {
 	uint64_t bsize;
 
-	bsize = statfsp->f_bsize / totalfsp->f_bsize;
-	totalfsp->f_blocks += statfsp->f_blocks * bsize;
-	totalfsp->f_bfree += statfsp->f_bfree * bsize;
-	totalfsp->f_bavail += statfsp->f_bavail * bsize;
-	totalfsp->f_files += statfsp->f_files;
-	totalfsp->f_ffree += statfsp->f_ffree;
+	bsize = statvfsp->f_bsize / totalfsp->f_bsize;
+	totalfsp->f_blocks += statvfsp->f_blocks * bsize;
+	totalfsp->f_bfree += statvfsp->f_bfree * bsize;
+	totalfsp->f_bavail += statvfsp->f_bavail * bsize;
+	totalfsp->f_files += statvfsp->f_files;
+	totalfsp->f_ffree += statvfsp->f_ffree;
 }
 
 /*
@@ -591,7 +598,7 @@
  * the file system specified by `sfsp'.
  */
 static void
-update_maxwidths(struct maxwidths *mwp, const struct statfs *sfsp)
+update_maxwidths(struct maxwidths *mwp, const struct mntinfo *sfsp)
 {
 	static long blocksize = 0;
 	int dummy;
@@ -643,69 +650,95 @@
 	exit(EX_USAGE);
 }
 
-static char *
-makenetvfslist(void)
+static int
+getmntinfo(struct mntinfo **mntbuf)
 {
-	char *str, *strptr, **listptr;
-	struct xvfsconf *xvfsp, *keep_xvfsp;
-	size_t buflen;
-	int cnt, i, maxvfsconf;
+	struct mntinfo *list = NULL;
+	struct mntinfo *current = NULL;
+	struct mntent *ent = NULL;
+	int mntsize = 0;
+	FILE *fp = NULL;
+	struct statvfs svfsbuf;
+	struct stat stmnt;
 
-	if (sysctlbyname("vfs.conflist", NULL, &buflen, NULL, 0) < 0) {
-		xo_warn("sysctl(vfs.conflist)");
-		return (NULL);
+#ifdef _PATH_MOUNTED
+	fp = setmntent(_PATH_MOUNTED, "r");
+#else
+	if (access("/proc/self/mounts", R_OK) == 0) {
+	    fp = setmntent("/proc/self/mounts", "r");
+	} else if (access("/proc/mounts", R_OK) == 0) {
+	    fp = setmntent("/proc/mounts", "r");
+	} else if (access("/etc/mtab", R_OK) == 0) {
+	    fp = setmntent("/etc/mtab", "r");
 	}
-	xvfsp = malloc(buflen);
-	if (xvfsp == NULL) {
-		xo_warnx("malloc failed");
-		return (NULL);
-	}
-	keep_xvfsp = xvfsp;
-	if (sysctlbyname("vfs.conflist", xvfsp, &buflen, NULL, 0) < 0) {
-		xo_warn("sysctl(vfs.conflist)");
-		free(keep_xvfsp);
-		return (NULL);
-	}
-	maxvfsconf = buflen / sizeof(struct xvfsconf);
+#endif
 
-	if ((listptr = malloc(sizeof(char*) * maxvfsconf)) == NULL) {
-		xo_warnx("malloc failed");
-		free(keep_xvfsp);
-		return (NULL);
+	if (fp == NULL) {
+	    xo_err(1, "setmntent");
 	}
 
-	for (cnt = 0, i = 0; i < maxvfsconf; i++) {
-		if (xvfsp->vfc_flags & VFCF_NETWORK) {
-			listptr[cnt++] = strdup(xvfsp->vfc_name);
-			if (listptr[cnt-1] == NULL) {
-				xo_warnx("malloc failed");
-				free(listptr);
-				free(keep_xvfsp);
-				return (NULL);
-			}
-		}
-		xvfsp++;
-	}
+	while ((ent = getmntent(fp)) != NULL) {
+	    /* skip if necessary */
+	    if (hasmntopt(ent, MNTTYPE_IGNORE) != NULL) {
+	        continue;
+	    }
 
-	if (cnt == 0 ||
-	    (str = malloc(sizeof(char) * (32 * cnt + cnt + 2))) == NULL) {
-		if (cnt > 0)
-			xo_warnx("malloc failed");
-		free(listptr);
-		free(keep_xvfsp);
-		return (NULL);
+	    /* filter out filesystems to be skipped */
+	    if (vfslist_l || vfslist_t) {
+	        if (checkvfsselected(ent->mnt_type) != 0)
+	            continue;
+	    }
+
+	    /* get stat(vfs) fields and copy those over */
+	    if (statvfs(ent->mnt_dir, &svfsbuf) == -1 || stat(ent->mnt_dir, &stmnt) == -1) {
+	        if ((errno == EACCES) || (errno == EPERM)) continue;
+	        xo_err(1, "statvfs");
+	    }
+
+	    /* allocate the entry */
+	    list = realloc(list, (mntsize + 1) * sizeof(*list));
+	    assert(list != NULL);
+	    current = list + mntsize;
+
+	    /* fill the struct with getmntent fields */
+	    current->f_fstypename = strdup(ent->mnt_type);
+	    current->f_mntfromname = strdup(ent->mnt_fsname);
+	    current->f_mntonname = strdup(ent->mnt_dir);
+	    current->f_opts = strdup(ent->mnt_opts);
+
+	    current->f_flag = svfsbuf.f_flag;
+	    current->f_blocks = svfsbuf.f_blocks;
+	    current->f_bsize = svfsbuf.f_bsize;
+	    current->f_bfree = svfsbuf.f_bfree;
+	    current->f_bavail = svfsbuf.f_bavail;
+	    current->f_files = svfsbuf.f_files;
+	    current->f_ffree = svfsbuf.f_ffree;
+
+	    current->f_dev = stmnt.st_dev;
+
+	    current->f_selected = 1;
+
+	    mntsize++;
 	}
 
-	*str = 'n'; *(str + 1) = 'o';
-	for (i = 0, strptr = str + 2; i < cnt; i++, strptr++) {
-		strlcpy(strptr, listptr[i], 32);
-		strptr += strlen(listptr[i]);
-		*strptr = ',';
-		free(listptr[i]);
+	endmntent(fp);
+
+	*mntbuf = list;
+	return mntsize;
+}
+
+static void
+freemntinfo(struct mntinfo *mntbuf, int mntsize)
+{
+	int i = 0;
+
+	for (i = 0; i < mntsize; i++) {
+	    free(mntbuf[i].f_fstypename);
+	    free(mntbuf[i].f_mntfromname);
+	    free(mntbuf[i].f_mntonname);
+	    free(mntbuf[i].f_opts);
 	}
-	*(--strptr) = '\0';
 
-	free(keep_xvfsp);
-	free(listptr);
-	return (str);
+	free(mntbuf);
+	return;
 }
--- src.orig/coreutils/du/du.1
+++ src.freebsd/coreutils/du/du.1
@@ -115,12 +115,6 @@
 are counted (and displayed) as many times as they are found.
 .It Fl m
 Display block counts in 1048576-byte (1 MiB) blocks.
-.It Fl n
-Ignore files and directories with user
-.Dq nodump
-flag
-.Pq Dv UF_NODUMP
-set.
 .It Fl r
 Generate messages about directories that cannot be read, files
 that cannot be opened, and so on.
--- src.orig/coreutils/du/du.c
+++ src.freebsd/coreutils/du/du.c
@@ -54,6 +54,7 @@
 #include <getopt.h>
 #include <libutil.h>
 #include <locale.h>
+#include <signal.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -80,7 +81,6 @@
 static int	ignorep(FTSENT *);
 static void	siginfo(int __unused);
 
-static int	nodumpflag = 0;
 static int	Aflag, hflag;
 static long	blocksize, cblocksize;
 static volatile sig_atomic_t info;
@@ -119,7 +119,7 @@
 	depth = INT_MAX;
 	SLIST_INIT(&ignores);
 
-	while ((ch = getopt_long(argc, argv, "+AB:HI:LPasd:cghklmnrt:x",
+	while ((ch = getopt_long(argc, argv, "+AB:HI:LPasd:cghklmrt:x",
 	    long_options, NULL)) != -1)
 		switch (ch) {
 		case 'A':
@@ -185,19 +185,23 @@
 			hflag = 0;
 			blocksize = 1048576;
 			break;
-		case 'n':
-			nodumpflag = 1;
-			break;
 		case 'r':		 /* Compatibility. */
 			break;
-		case 't' :
-			if (expand_number(optarg, &threshold) != 0 ||
-			    threshold == 0) {
+		case 't' : {
+			uint64_t thresh;
+			/* expand_number takes an unsigned pointer but will happily store
+			 * negative values (represented as values beyond signed maximum)
+			 * store in unsigned and then copy to avoid UB
+			 */
+			int ret = expand_number(optarg, &thresh);
+			memcpy(&threshold, &thresh, sizeof(threshold));
+			if (ret != 0 || threshold == 0) {
 				warnx("invalid threshold: %s", optarg);
 				usage();
 			} else if (threshold < 0)
 				threshold_sign = -1;
 			break;
+		}
 		case 'x':
 			ftsoptions |= FTS_XDEV;
 			break;
@@ -279,18 +283,18 @@
 			curblocks = Aflag ?
 			    howmany(p->fts_statp->st_size, cblocksize) :
 			    howmany(p->fts_statp->st_blocks, cblocksize);
-			p->fts_parent->fts_bignum += p->fts_bignum +=
+			p->fts_parent->fts_number += p->fts_number +=
 			    curblocks;
 
 			if (p->fts_level <= depth && threshold <=
-			    threshold_sign * howmany(p->fts_bignum *
+			    threshold_sign * howmany(p->fts_number *
 			    cblocksize, blocksize)) {
 				if (hflag > 0) {
-					prthumanval(p->fts_bignum);
+					prthumanval(p->fts_number);
 					(void)printf("\t%s\n", p->fts_path);
 				} else {
 					(void)printf("%jd\t%s\n",
-					    (intmax_t)howmany(p->fts_bignum *
+					    (intmax_t)howmany(p->fts_number *
 					    cblocksize, blocksize),
 					    p->fts_path);
 				}
@@ -332,9 +336,9 @@
 				}
 			}
 
-			p->fts_parent->fts_bignum += curblocks;
+			p->fts_parent->fts_number += curblocks;
 		}
-		savednumber = p->fts_parent->fts_bignum;
+		savednumber = p->fts_parent->fts_number;
 	}
 
 	if (errno)
@@ -545,8 +549,6 @@
 {
 	struct ignentry *ign;
 
-	if (nodumpflag && (ent->fts_statp->st_flags & UF_NODUMP))
-		return 1;
 	SLIST_FOREACH(ign, &ignores, next)
 		if (fnmatch(ign->mask, ent->fts_name, 0) != FNM_NOMATCH)
 			return 1;
--- src.orig/coreutils/env/env.1
+++ src.freebsd/coreutils/env/env.1
@@ -39,12 +39,10 @@
 .Sh SYNOPSIS
 .Nm
 .Op Fl 0iv
-.Op Fl L Ns | Ns Fl U Ar user Ns Op / Ns Ar class
 .Op Fl u Ar name
 .Op Ar name Ns = Ns Ar value ...
 .Nm
 .Op Fl iv
-.Op Fl L Ns | Ns Fl U Ar user Ns Op / Ns Ar class
 .Op Fl P Ar altpath
 .Op Fl S Ar string
 .Op Fl u Ar name
@@ -81,34 +79,6 @@
 by
 .Nm
 is ignored completely.
-.\"	-L | -U
-.It Fl L | Fl U Ar user Ns Op / Ns Ar class
-Add the environment variable definitions from
-.Xr login.conf 5
-for the specified user and login class to the environment, after
-processing any
-.Fl i
-or
-.Fl u
-options, but before processing any
-.Ar name Ns = Ns Ar value
-options.
-If
-.Fl L
-is used, only the system-wide
-.Pa /etc/login.conf.db
-file is read; if
-.Fl U
-is used, then the specified user's
-.Pa ~/.login_conf
-is read as well.
-The user may be specified by name or by uid.
-If a username of
-.Sq Li \&-
-is given, then no user lookup will be done, the login class will default to
-.Sq Li default
-if not explicitly given, and no substitutions will be done on the values.
-.\"	-P
 .It Fl P Ar altpath
 Search the set of directories as specified by
 .Ar altpath
--- src.orig/coreutils/env/env.c
+++ src.freebsd/coreutils/env/env.c
@@ -46,7 +46,6 @@
 
 #include <err.h>
 #include <errno.h>
-#include <login_cap.h>
 #include <pwd.h>
 #include <stdbool.h>
 #include <stdio.h>
@@ -74,23 +73,18 @@
 {
 	char *altpath, **ep, *p, **parg, term;
 	char *cleanenv[1];
-	char *login_class, *login_name;
+	char *login_name;
 	struct passwd *pw;
-	login_cap_t *lc;
-	bool login_as_user;
 	uid_t uid;
 	int ch, want_clear;
 	int rtrn;
 
 	altpath = NULL;
-	login_class = NULL;
 	login_name = NULL;
 	pw = NULL;
-	lc = NULL;
-	login_as_user = false;
 	want_clear = 0;
 	term = '\n';
-	while ((ch = getopt(argc, argv, "-0iL:P:S:U:u:v")) != -1)
+	while ((ch = getopt(argc, argv, "0iP:S:u:v")) != -1)
 		switch(ch) {
 		case '-':
 		case 'i':
@@ -99,12 +93,6 @@
 		case '0':
 			term = '\0';
 			break;
-		case 'U':
-			login_as_user = true;
-			/* FALLTHROUGH */
-		case 'L':
-			login_name = optarg;
-			break;
 		case 'P':
 			altpath = strdup(optarg);
 			break;
@@ -132,6 +120,10 @@
 		default:
 			usage();
 		}
+	if (optind < argc && !strcmp(argv[optind], "-")) {
+		want_clear = 1;
+		++argv; /* skip the initial - during later scan */
+	}
 	if (want_clear) {
 		environ = cleanenv;
 		cleanenv[0] = NULL;
@@ -139,9 +131,6 @@
 			fprintf(stderr, "#env clearing environ\n");
 	}
 	if (login_name != NULL) {
-		login_class = strchr(login_name, '/');
-		if (login_class)
-			*login_class++ = '\0';
 		if (*login_name != '\0' && strcmp(login_name, "-") != 0) {
 			pw = getpwnam(login_name);
 			if (pw == NULL) {
@@ -154,38 +143,8 @@
 			if (pw == NULL)
 				errx(EXIT_FAILURE, "no such user: %s", login_name);
 		}
-		/*
-		 * Note that it is safe for pw to be null here; the libutil
-		 * code handles that, bypassing substitution of $ and using
-		 * the class "default" if no class name is given either.
-		 */
-		if (login_class != NULL) {
-			lc = login_getclass(login_class);
-			if (lc == NULL)
-				errx(EXIT_FAILURE, "no such login class: %s",
-				    login_class);
-		} else {
-			lc = login_getpwclass(pw);
-			if (lc == NULL)
-				errx(EXIT_FAILURE, "login_getpwclass failed");
-		}
 
-		/*
-		 * This is not done with setusercontext() because that will
-		 * try and use ~/.login_conf even when we don't want it to.
-		 */
-		setclassenvironment(lc, pw, 1);
-		setclassenvironment(lc, pw, 0);
-		if (login_as_user) {
-			login_close(lc);
-			if ((lc = login_getuserclass(pw)) != NULL) {
-				setclassenvironment(lc, pw, 1);
-				setclassenvironment(lc, pw, 0);
-			}
-		}
 		endpwent();
-		if (lc != NULL)
-			login_close(lc);
 	}
 	for (argv += optind; *argv && (p = strchr(*argv, '=')); ++argv) {
 		if (env_verbosity)
--- src.orig/coreutils/env/envopts.c
+++ src.freebsd/coreutils/env/envopts.c
@@ -31,6 +31,7 @@
  */
 
 #include <sys/cdefs.h>
+#include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/param.h>
 #include <err.h>
--- src.orig/coreutils/expr/expr.y
+++ src.freebsd/coreutils/expr/expr.y
@@ -6,6 +6,7 @@
  * Largely rewritten by J.T. Conklin (jtc@wimsey.com)
  */
 
+#include <sys/cdefs.h>
 #include <sys/types.h>
 
 #include <ctype.h>
@@ -268,8 +269,7 @@
 	int c;
 
 	setlocale(LC_ALL, "");
-	if (getenv("EXPR_COMPAT") != NULL
-	    || check_utility_compat("expr")) {
+	if (getenv("EXPR_COMPAT") != NULL) {
 		av = argv + 1;
 		nonposix = 1;
 	} else {
--- src.orig/coreutils/factor/factor.c
+++ src.freebsd/coreutils/factor/factor.c
@@ -65,6 +65,7 @@
  * If no args are given, the list of numbers are read from stdin.
  */
 
+#include <sys/types.h>
 #include <ctype.h>
 #include <err.h>
 #include <errno.h>
--- src.orig/coreutils/fmt/fmt.c
+++ src.freebsd/coreutils/fmt/fmt.c
@@ -183,6 +183,7 @@
 #include <unistd.h>
 #include <wchar.h>
 #include <wctype.h>
+#include <stdint.h>
 
 /* Something that, we hope, will never be a genuine line length,
  * indentation etc.
@@ -378,7 +379,7 @@
 		goal_length = 65;
 	if (max_length == 0)
 		max_length = goal_length + 10;
-	if (max_length >= SIZE_T_MAX / sizeof(wchar_t))
+	if (max_length >= SIZE_MAX / sizeof(wchar_t))
 		errx(EX_USAGE, "max length too large");
 	/* really needn't be longer */
 	output_buffer = XMALLOC((max_length + 1) * sizeof(wchar_t));
--- src.orig/coreutils/head/head.c
+++ src.freebsd/coreutils/head/head.c
@@ -87,6 +87,7 @@
 	FILE *fp;
 	off_t bytecnt;
 	intmax_t linecnt;
+	uint64_t ucnt;
 	int ch, first, eval;
 	fileargs_t *fa;
 	cap_rights_t rights;
@@ -101,12 +102,14 @@
 	while ((ch = getopt_long(argc, argv, "+n:c:qv", long_opts, NULL)) != -1) {
 		switch(ch) {
 		case 'c':
-			if (expand_number(optarg, &bytecnt) || bytecnt <= 0)
+			if (expand_number(optarg, &ucnt))
 				errx(1, "illegal byte count -- %s", optarg);
+			bytecnt = ucnt;
 			break;
 		case 'n':
-			if (expand_number(optarg, &linecnt) || linecnt <= 0)
+			if (expand_number(optarg, &ucnt))
 				errx(1, "illegal line count -- %s", optarg);
+			linecnt = ucnt;
 			break;
 		case 'q':
 			qflag = 1;
@@ -168,15 +171,17 @@
 static void
 head(FILE *fp, intmax_t cnt)
 {
-	char *cp;
-	size_t error, readlen;
+	char *cp = NULL;
+	size_t error, bufsize = 0;
+	ssize_t readlen;
 
-	while (cnt != 0 && (cp = fgetln(fp, &readlen)) != NULL) {
+	while (cnt != 0 && (readlen = getline(&cp, &bufsize, fp)) >= 0) {
 		error = fwrite(cp, sizeof(char), readlen, stdout);
-		if (error != readlen)
+		if ((ssize_t)error != readlen)
 			err(1, "stdout");
 		cnt--;
 	}
+	free(cp);
 }
 
 static void
--- src.orig/coreutils/id/id.1
+++ src.freebsd/coreutils/id/id.1
@@ -40,18 +40,12 @@
 .Nm
 .Op Ar user
 .Nm
-.Fl A
-.Nm
 .Fl G Op Fl n
 .Op Ar user
 .Nm
-.Fl M
-.Nm
 .Fl P
 .Op Ar user
 .Nm
-.Fl c
-.Nm
 .Fl g Op Fl nr
 .Op Ar user
 .Nm
@@ -76,22 +70,15 @@
 .Pp
 The options are as follows:
 .Bl -tag -width indent
-.It Fl A
-Display the process audit user ID and other process audit properties, which
-requires privilege.
 .It Fl G
 Display the different group IDs (effective, real and supplementary)
 as white-space separated numbers, in no particular order.
-.It Fl M
-Display the MAC label of the current process.
 .It Fl P
 Display the id as a password file entry.
 .It Fl a
 Ignored for compatibility with other
 .Nm
 implementations.
-.It Fl c
-Display current login class.
 .It Fl g
 Display the effective group ID as a number.
 .It Fl n
--- src.orig/coreutils/id/id.c
+++ src.freebsd/coreutils/id/id.c
@@ -41,13 +41,9 @@
 #endif
 #endif /* not lint */
 #include <sys/cdefs.h>
+#include <sys/types.h>
 #include <sys/param.h>
-#include <sys/mac.h>
 
-#ifdef USE_BSM_AUDIT
-#include <bsm/audit.h>
-#endif
-
 #include <err.h>
 #include <errno.h>
 #include <grp.h>
@@ -65,7 +61,6 @@
 static void	auditid(void);
 #endif
 static void	group(struct passwd *, int);
-static void	maclabel(void);
 static void	usage(void);
 static struct passwd *who(char *);
 
@@ -76,14 +71,10 @@
 {
 	struct group *gr;
 	struct passwd *pw;
-	int Gflag, Mflag, Pflag, ch, gflag, id, nflag, pflag, rflag, uflag;
-	int Aflag, cflag;
-	int error;
+	int Gflag, Pflag, ch, gflag, id, nflag, pflag, rflag, uflag;
 	const char *myname;
-	char loginclass[MAXLOGNAME];
 
-	Gflag = Mflag = Pflag = gflag = nflag = pflag = rflag = uflag = 0;
-	Aflag = cflag = 0;
+	Gflag = Pflag = gflag = nflag = pflag = rflag = uflag = 0;
 
 	myname = strrchr(argv[0], '/');
 	myname = (myname != NULL) ? myname + 1 : argv[0];
@@ -97,27 +88,16 @@
 	}
 
 	while ((ch = getopt(argc, argv,
-	    (isgroups || iswhoami) ? "" : "APGMacgnpru")) != -1)
+	    (isgroups || iswhoami) ? "" : "PGagnpru")) != -1)
 		switch(ch) {
-#ifdef USE_BSM_AUDIT
-		case 'A':
-			Aflag = 1;
-			break;
-#endif
 		case 'G':
 			Gflag = 1;
 			break;
-		case 'M':
-			Mflag = 1;
-			break;
 		case 'P':
 			Pflag = 1;
 			break;
 		case 'a':
 			break;
-		case 'c':
-			cflag = 1;
-			break;
 		case 'g':
 			gflag = 1;
 			break;
@@ -142,10 +122,8 @@
 
 	if (iswhoami && argc > 0)
 		usage();
-	if ((cflag || Aflag || Mflag) && argc > 0)
-		usage();
 
-	switch(Aflag + Gflag + Mflag + Pflag + gflag + pflag + uflag) {
+	switch(Gflag + Pflag + gflag + pflag + uflag) {
 	case 1:
 		break;
 	case 0:
@@ -158,24 +136,6 @@
 
 	pw = *argv ? who(*argv) : NULL;
 
-	if (Mflag && pw != NULL)
-		usage();
-
-#ifdef USE_BSM_AUDIT
-	if (Aflag) {
-		auditid();
-		exit(0);
-	}
-#endif
-
-	if (cflag) {
-		error = getloginclass(loginclass, sizeof(loginclass));
-		if (error != 0)
-			err(1, "loginclass");
-		(void)printf("%s\n", loginclass);
-		exit(0);
-	}
-
 	if (gflag) {
 		id = pw ? pw->pw_gid : rflag ? getgid() : getegid();
 		if (nflag && (gr = getgrgid(id)))
@@ -199,11 +159,6 @@
 		exit(0);
 	}
 
-	if (Mflag) {
-		maclabel();
-		exit(0);
-	}
-
 	if (Pflag) {
 		pline(pw);
 		exit(0);
@@ -416,30 +371,6 @@
 	free(groups);
 }
 
-static void
-maclabel(void)
-{
-	char *string;
-	mac_t label;
-	int error;
-
-	error = mac_prepare_process_label(&label);
-	if (error == -1)
-		errx(1, "mac_prepare_type: %s", strerror(errno));
-
-	error = mac_get_proc(label);
-	if (error == -1)
-		errx(1, "mac_get_proc: %s", strerror(errno));
-
-	error = mac_to_text(label, &string);
-	if (error == -1)
-		errx(1, "mac_to_text: %s", strerror(errno));
-
-	(void)printf("%s\n", string);
-	mac_free(label);
-	free(string);
-}
-
 static struct passwd *
 who(char *u)
 {
@@ -469,9 +400,9 @@
 			err(1, "getpwuid");
 	}
 
-	(void)printf("%s:%s:%d:%d:%s:%ld:%ld:%s:%s:%s\n", pw->pw_name,
-			pw->pw_passwd, pw->pw_uid, pw->pw_gid, pw->pw_class,
-			(long)pw->pw_change, (long)pw->pw_expire, pw->pw_gecos,
+	(void)printf("%s:%s:%d:%d:%s:%s:%s\n", pw->pw_name,
+			pw->pw_passwd, pw->pw_uid, pw->pw_gid,
+			pw->pw_gecos,
 			pw->pw_dir, pw->pw_shell);
 }
 
@@ -485,7 +416,7 @@
 	else if (iswhoami)
 		(void)fprintf(stderr, "usage: whoami\n");
 	else
-		(void)fprintf(stderr, "%s\n%s%s\n%s\n%s\n%s\n%s\n%s\n%s\n",
+		(void)fprintf(stderr, "%s\n%s%s\n%s\n%s\n%s\n%s\n",
 		    "usage: id [user]",
 #ifdef USE_BSM_AUDIT
 		    "       id -A\n",
@@ -493,9 +424,7 @@
 		    "",
 #endif
 		    "       id -G [-n] [user]",
-		    "       id -M",
 		    "       id -P [user]",
-		    "       id -c",
 		    "       id -g [-nr] [user]",
 		    "       id -p [user]",
 		    "       id -u [-nr] [user]");
--- src.orig/coreutils/join/join.c
+++ src.freebsd/coreutils/join/join.c
@@ -46,6 +46,7 @@
 #endif /* not lint */
 #include <sys/cdefs.h>
 #include <sys/param.h>
+#include <sys/types.h>
 
 #include <err.h>
 #include <errno.h>
@@ -274,9 +275,10 @@
 slurp(INPUT *F)
 {
 	LINE *lp, *lastlp, tmp;
-	size_t len;
+	size_t blen = 0;
+	ssize_t len;
 	int cnt;
-	char *bp, *fieldp;
+	char *bp, *buf = NULL, *fieldp;
 
 	/*
 	 * Read all of the lines from an input file that have the same
@@ -319,21 +321,21 @@
 			F->pushbool = 0;
 			continue;
 		}
-		if ((bp = fgetln(F->fp, &len)) == NULL)
+		if ((len = getline(&buf, &blen, F->fp)) < 0) {
+			free(buf);
 			return;
-		if (lp->linealloc <= len + 1) {
+		}
+		if (lp->linealloc <= (size_t)(len + 1)) {
 			lp->linealloc += MAX(100, len + 1 - lp->linealloc);
 			if ((lp->line =
 			    realloc(lp->line, lp->linealloc)) == NULL)
 				err(1, NULL);
 		}
-		memmove(lp->line, bp, len);
+		memmove(lp->line, buf, len);
 
 		/* Replace trailing newline, if it exists. */
-		if (bp[len - 1] == '\n')
+		if (buf[len - 1] == '\n')
 			lp->line[len - 1] = '\0';
-		else
-			lp->line[len] = '\0';
 		bp = lp->line;
 
 		/* Split the line into fields, allocate space as necessary. */
@@ -357,6 +359,7 @@
 			break;
 		}
 	}
+	free(buf);
 }
 
 static char *
--- src.orig/coreutils/ln/ln.c
+++ src.freebsd/coreutils/ln/ln.c
@@ -146,6 +146,7 @@
 	switch(argc) {
 	case 0:
 		usage();
+		break;
 		/* NOTREACHED */
 	case 1:				/* ln source */
 		exit(linkit(argv[0], ".", 1));
--- src.orig/coreutils/ls/cmp.c
+++ src.freebsd/coreutils/ls/cmp.c
@@ -136,7 +136,7 @@
 int
 birthcmp(const FTSENT *a, const FTSENT *b)
 {
-
+#if 0
 	if (b->fts_statp->st_birthtim.tv_sec >
 	    a->fts_statp->st_birthtim.tv_sec)
 		return (1);
@@ -149,6 +149,7 @@
 	if (b->fts_statp->st_birthtim.tv_nsec <
 	    a->fts_statp->st_birthtim.tv_nsec)
 		return (-1);
+#endif
 	if (f_samesort)
 		return (strcoll(b->fts_name, a->fts_name));
 	else
--- src.orig/coreutils/ls/ls.1
+++ src.freebsd/coreutils/ls/ls.1
@@ -39,7 +39,7 @@
 .Nd list directory contents
 .Sh SYNOPSIS
 .Nm
-.Op Fl ABCFGHILPRSTUWZabcdfghiklmnopqrstuvwxy1\&,
+.Op Fl ABCFGHILPRSTWabcdfghiklmnpqrstuvwxy1\&,
 .Op Fl -color Ns = Ns Ar when
 .Op Fl D Ar format
 .Op Ar
@@ -99,7 +99,7 @@
 to format the date and time output.
 The argument
 .Ar format
-is a string used by
+is a string used by FreeBSD
 .Xr strftime 3 .
 Depending on the choice of format string, this may result in a
 different number of columns in the output.
@@ -121,9 +121,6 @@
 an equals sign
 .Pq Ql =
 after each socket,
-a percent sign
-.Pq Ql %
-after each whiteout,
 and a vertical bar
 .Pq Ql \&|
 after each that is a
@@ -184,19 +181,6 @@
 option gives even more control over the output format.
 This option is not defined in
 .St -p1003.1-2008 .
-.It Fl U
-Use time when file was created for sorting or printing.
-This option is not defined in
-.St -p1003.1-2008 .
-.It Fl W
-Display whiteouts when scanning directories.
-This option is not defined in
-.St -p1003.1-2008 .
-.It Fl Z
-Display each file's MAC label; see
-.Xr maclabel 7 .
-This option is not defined in
-.St -p1003.1-2008 .
 .It Fl a
 Include directory entries whose names begin with a
 dot
@@ -332,15 +316,6 @@
 or group name in a long
 .Pq Fl l
 output.
-.It Fl o
-Include the file flags in a long
-.Pq Fl l
-output.
-This option is incompatible with
-.St -p1003.1-2008 .
-See
-.Xr chflags 1
-for a list of file flags and their meanings.
 .It Fl p
 Write a slash
 .Pq Ql /
@@ -502,7 +477,6 @@
 is displayed for each file:
 file mode,
 number of links, owner name, group name,
-MAC label,
 number of bytes in the file, abbreviated
 month, day-of-month file was last modified,
 hour file last modified, minute file last
@@ -569,8 +543,6 @@
 .Tn FIFO .
 .It Sy s
 Socket.
-.It Sy w
-Whiteout.
 .El
 .Pp
 The next three fields
@@ -862,11 +834,10 @@
 .Dl $ ls -l
 .Pp
 In addition to listing the contents of the current working directory in
-long format, show inode numbers, file flags (see
-.Xr chflags 1 ) ,
+long format, show inode numbers,
 and suffix each filename with a symbol representing its file type:
 .Pp
-.Dl $ ls -lioF
+.Dl $ ls -liF
 .Pp
 List the files in
 .Pa /var/log ,
@@ -880,7 +851,6 @@
 .St -p1003.2
 specification.
 .Sh SEE ALSO
-.Xr chflags 1 ,
 .Xr chmod 1 ,
 .Xr getfacl 1 ,
 .Xr sort 1 ,
@@ -891,15 +861,14 @@
 .Xr strmode 3 ,
 .Xr strverscmp 3 ,
 .Xr termcap 5 ,
-.Xr maclabel 7 ,
 .Xr sticky 7 ,
 .Xr symlink 7 ,
 .Xr getfmac 8
 .Sh STANDARDS
 With the exception of options
-.Fl g , n
+.Fl g
 and
-.Fl o ,
+.Fl n,
 the
 .Nm
 utility conforms to
@@ -907,7 +876,7 @@
 and
 .St -p1003.1-2008 .
 The options
-.Fl B , D , G , I , T , U , W , Z , b , h , v , w , y
+.Fl B , D , G , I , T , b , h , v , w , y
 and
 .Fl ,
 are non-standard extensions.
--- src.orig/coreutils/ls/ls.c
+++ src.freebsd/coreutils/ls/ls.c
@@ -47,7 +47,7 @@
 #include <sys/param.h>
 #include <sys/stat.h>
 #include <sys/ioctl.h>
-#include <sys/mac.h>
+#include <sys/types.h>
 
 #include <ctype.h>
 #include <dirent.h>
@@ -96,7 +96,7 @@
 	} while(0)
 
 static void	 display(const FTSENT *, FTSENT *, int);
-static int	 mastercmp(const FTSENT * const *, const FTSENT * const *);
+static int	 mastercmp(const FTSENT **, const FTSENT **);
 static void	 traverse(int, char **, int);
 
 #define	COLOR_OPT	(CHAR_MAX + 1)
@@ -275,7 +275,7 @@
 		colorflag = COLORFLAG_AUTO;
 #endif
 	while ((ch = getopt_long(argc, argv,
-	    "+1ABCD:FGHILPRSTUWXZabcdfghiklmnopqrstuvwxy,", long_opts,
+	    "+1ABCD:FGHILPRSTXabcdfghiklmnpqrstuvwxy,", long_opts,
 	    NULL)) != -1) {
 		switch (ch) {
 		/*
@@ -469,8 +469,6 @@
 				errx(2, "unsupported --color value '%s' (must be always, auto, or never)",
 				    optarg);
 			break;
-#else
-			warnx("color support not compiled in");
 #endif
 		default:
 		case '?':
@@ -708,7 +706,7 @@
  * points to the parent directory of the display list.
  */
 static void
-display(const FTSENT *p, FTSENT *list, int options)
+display(const FTSENT *p, FTSENT *list, int options __unused)
 {
 	struct stat *sp;
 	DISPLAY d;
@@ -726,8 +724,9 @@
 	size_t flen, ulen, glen;
 	char *initmax;
 	int entries, needstats;
+	struct passwd *pwentry = NULL;
+	struct group *grentry = NULL;
 	const char *user, *group;
-	char *flags, *labelstr = NULL;
 	char ngroup[STRBUF_SIZEOF(uid_t) + 1];
 	char nuser[STRBUF_SIZEOF(gid_t) + 1];
 	u_long width[9];
@@ -736,6 +735,7 @@
 	needstats = f_inode || f_longform || f_size;
 	flen = 0;
 	btotal = 0;
+	labelstrlen = 0;
 
 #define LS_COLWIDTHS_FIELDS	9
 	initmax = getenv("LS_COLWIDTHS");
@@ -784,7 +784,6 @@
 
 	d.s_size = 0;
 	sizelen = 0;
-	flags = NULL;
 	for (cur = list, entries = 0; cur; cur = cur->fts_link) {
 		if (cur->fts_info == FTS_ERR || cur->fts_info == FTS_NS) {
 			warnx("%s: %s",
@@ -839,27 +838,33 @@
 					user = nuser;
 					group = ngroup;
 				} else {
-					user = user_from_uid(sp->st_uid, 0);
+					pwentry = getpwuid(sp->st_uid);
 					/*
-					 * user_from_uid(..., 0) only returns
-					 * NULL in OOM conditions.  We could
-					 * format the uid here, but (1) in
-					 * general ls(1) exits on OOM, and (2)
-					 * there is another allocation/exit
-					 * path directly below, which will
-					 * likely exit anyway.
+					 * getpwuid and getgrgid are allowed to
+					 * return NULL when the information is
+					 * not known (i.e. not in /etc/passwd)
+					 * so fall back to numeric IDs if needed
 					 */
-					if (user == NULL)
-						err(1, "user_from_uid");
-					group = group_from_gid(sp->st_gid, 0);
+					if (pwentry == NULL) {
+						(void)snprintf(nuser, sizeof(nuser),
+						    "%u", sp->st_uid);
+						user = nuser;
+					} else
+						user = pwentry->pw_name;
+					grentry = getgrgid(sp->st_gid);
 					/* Ditto. */
-					if (group == NULL)
-						err(1, "group_from_gid");
+					if (grentry == NULL) {
+						(void)snprintf(ngroup, sizeof(ngroup),
+						    "%u", sp->st_gid);
+						group = ngroup;
+					} else
+						group = grentry->gr_name;
 				}
 				if ((ulen = strlen(user)) > maxuser)
 					maxuser = ulen;
 				if ((glen = strlen(group)) > maxgroup)
 					maxgroup = glen;
+#if 0
 				if (f_flags) {
 					flags = fflagstostr(sp->st_flags);
 					if (flags != NULL && *flags == '\0') {
@@ -927,7 +932,7 @@
 						maxlabelstr = labelstrlen;
 				} else
 					labelstrlen = 0;
-
+#endif
 				if ((np = malloc(sizeof(NAMES) + labelstrlen +
 				    ulen + glen + flen + 4)) == NULL)
 					err(1, "malloc");
@@ -945,17 +950,6 @@
 						d.s_size = sizelen;
 				}
 
-				if (f_flags) {
-					np->flags = &np->data[ulen + glen + 2];
-					(void)strcpy(np->flags, flags);
-					free(flags);
-				}
-				if (f_label) {
-					np->label = &np->data[ulen + glen + 2
-					    + (f_flags ? flen + 1 : 0)];
-					(void)strcpy(np->label, labelstr);
-					free(labelstr);
-				}
 				cur->fts_pointer = np;
 			}
 		}
@@ -1005,7 +999,7 @@
  * All other levels use the sort function.  Error entries remain unsorted.
  */
 static int
-mastercmp(const FTSENT * const *a, const FTSENT * const *b)
+mastercmp(const FTSENT **a, const FTSENT **b)
 {
 	int a_info, b_info;
 
--- src.orig/coreutils/ls/print.c
+++ src.freebsd/coreutils/ls/print.c
@@ -41,6 +41,7 @@
 #include <sys/param.h>
 #include <sys/stat.h>
 #include <sys/acl.h>
+#include <acl/libacl.h>
 
 #include <err.h>
 #include <errno.h>
@@ -52,7 +53,7 @@
 #include <stdint.h>
 #include <stdlib.h>
 #include <string.h>
-#include <time.h>
+#include <time_bsd.h>
 #include <unistd.h>
 #include <wchar.h>
 #ifdef COLORLS
@@ -248,7 +249,7 @@
 		if (f_accesstime)
 			printtime(sp->st_atime);
 		else if (f_birthtime)
-			printtime(sp->st_birthtime);
+			printtime(sp->st_ctime);
 		else if (f_statustime)
 			printtime(sp->st_ctime);
 		else
@@ -453,7 +454,7 @@
 		}
 	}
 	if (tm != NULL)
-		strftime(str, len, format, tm);
+		strftime_bsd(str, len, format, tm);
 	else
 		strlcpy(str, "bad date val", len);
 }
@@ -466,8 +467,11 @@
 	const char *format;
 	static int d_first = -1;
 
-	if (d_first < 0)
-		d_first = (*nl_langinfo(D_MD_ORDER) == 'd');
+	if (d_first < 0) {
+		d_first = 0;
+		if (strlen(nl_langinfo(D_FMT)) >= 2 && nl_langinfo(D_FMT)[1] == 'd')
+			d_first = 1;
+	}
 	if (now == 0)
 		now = time(NULL);
 
@@ -513,9 +517,6 @@
 	case S_IFSOCK:
 		(void)putchar('=');
 		return (1);
-	case S_IFWHT:
-		(void)putchar('%');
-		return (1);
 	default:
 		break;
 	}
@@ -775,18 +776,12 @@
 aclmode(char *buf, const FTSENT *p)
 {
 	char name[MAXPATHLEN + 1];
-	int ret, trivial;
-	static dev_t previous_dev = NODEV;
+	int ret, trivial = -1;
+	static dev_t previous_dev = (dev_t)-1;
 	static int supports_acls = -1;
-	static int type = ACL_TYPE_ACCESS;
-	acl_t facl;
 
-	/*
-	 * XXX: ACLs are not supported on whiteouts and device files
-	 * residing on UFS.
-	 */
 	if (S_ISCHR(p->fts_statp->st_mode) || S_ISBLK(p->fts_statp->st_mode) ||
-	    S_ISWHT(p->fts_statp->st_mode))
+	    S_ISLNK(p->fts_statp->st_mode))
 		return;
 
 	if (previous_dev == p->fts_statp->st_dev && supports_acls == 0)
@@ -801,7 +796,7 @@
 	if (previous_dev != p->fts_statp->st_dev) {
 		previous_dev = p->fts_statp->st_dev;
 		supports_acls = 0;
-
+#if 0
 		ret = lpathconf(name, _PC_ACL_NFS4);
 		if (ret > 0) {
 			type = ACL_TYPE_NFS4;
@@ -810,30 +805,24 @@
 			warn("%s", name);
 			return;
 		}
+#endif
 		if (supports_acls == 0) {
-			ret = lpathconf(name, _PC_ACL_EXTENDED);
-			if (ret > 0) {
-				type = ACL_TYPE_ACCESS;
+			ret = acl_extended_file(name);
+			if (ret >= 0) {
 				supports_acls = 1;
-			} else if (ret < 0 && errno != EINVAL) {
+				trivial = !ret;
+			} else if (ret < 0 && errno != ENOTSUP) {
 				warn("%s", name);
 				return;
+			} else {
+				supports_acls = 0;
 			}
 		}
 	}
 	if (supports_acls == 0)
 		return;
-	facl = acl_get_link_np(name, type);
-	if (facl == NULL) {
-		warn("%s", name);
-		return;
-	}
-	if (acl_is_trivial_np(facl, &trivial)) {
-		acl_free(facl);
-		warn("%s", name);
-		return;
-	}
+	if (trivial < 0)
+		trivial = !(acl_extended_file(name) > 0);
 	if (!trivial)
 		buf[10] = '+';
-	acl_free(facl);
 }
--- src.orig/coreutils/ls/util.c
+++ src.freebsd/coreutils/ls/util.c
@@ -225,9 +225,9 @@
 {
 	(void)fprintf(stderr,
 #ifdef COLORLS
-	"usage: ls [-ABCFGHILPRSTUWZabcdfghiklmnopqrstuvwxy1,] [--color=when] [-D format]"
+	"usage: ls [-ABCFGHILPRSTabcdfghiklmnpqrstuvwxy1,] [--color=when] [-D format]"
 #else
-	"usage: ls [-ABCFHILPRSTUWZabcdfghiklmnopqrstuvwxy1,] [-D format]"
+	"usage: ls [-ABCFHILPRSTabcdfghiklmnpqrstuvwxy1,] [-D format]"
 #endif
 		      " [file ...]\n");
 	exit(1);
--- src.orig/coreutils/md5/md5.1
+++ src.freebsd/coreutils/md5/md5.1
@@ -4,10 +4,8 @@
 .Sh NAME
 .Nm md5 , sha1 , sha224 , sha256 , sha384 ,
 .Nm sha512 , sha512t224 , sha512t256 ,
-.Nm rmd160 , skein256 , skein512 , skein1024 ,
 .Nm md5sum , sha1sum , sha224sum , sha256sum , sha384sum ,
 .Nm sha512sum , sha512t224sum , sha512t256sum ,
-.Nm rmd160sum , skein256sum , skein512sum , skein1024sum ,
 .Nm shasum
 .Nd calculate a message-digest fingerprint (checksum) for a file
 .Sh SYNOPSIS
@@ -54,10 +52,9 @@
 .Op Ar
 .Sh DESCRIPTION
 The
-.Nm md5 , sha1 , sha224 , sha256 , sha384 , sha512 , sha512t224 , sha512t256 ,
-.Nm rmd160 , skein256 , skein512 ,
+.Nm md5 , sha1 , sha224 , sha256 , sha384 , sha512 , sha512t224 ,
 and
-.Nm skein1024
+.Nm sha512t256
 utilities take as input a message of arbitrary length and produce as
 output a
 .Dq fingerprint
@@ -67,9 +64,9 @@
 .Pp
 The
 .Nm md5sum , sha1sum , sha224sum , sha256sum , sha384sum , sha512sum ,
-.Nm sha512t224sum , sha512t256sum , rmd160sum , skein256sum , skein512sum ,
+.Nm sha512t224sum ,
 and
-.Nm skein1024sum
+.Nm sha512t256sum
 utilities do the same, but with command-line options and an output
 format that match those of their similary named GNU utilities.
 .Pp
@@ -82,8 +79,7 @@
 It is conjectured that it is computationally infeasible to
 produce two messages having the same message digest, or to produce any
 message having a given prespecified target message digest.
-The SHA-224 , SHA-256 , SHA-384 , SHA-512, RIPEMD-160,
-and SKEIN
+The SHA-224 , SHA-256 , SHA-384 , and SHA-512
 algorithms are intended for digital signature applications, where a
 large file must be
 .Dq compressed
@@ -107,7 +103,7 @@
 SHA-512t224 is identical to SHA-512t256, but with the digest truncated
 to 224 bits.
 .Pp
-It is recommended that all new applications use SHA-512 or SKEIN-512
+It is recommended that all new applications use SHA-512
 instead of one of the other hash functions.
 .Ss BSD OPTIONS
 The following options are available in BSD mode, i.e. when the program
@@ -272,11 +268,9 @@
 .El
 .Sh EXIT STATUS
 The
-.Nm md5 , sha1 , sha224 , sha256 , sha384 , sha512 ,
-.Nm sha512t224 , sha512t256 ,
-.Nm rmd160 , skein256 , skein512 ,
+.Nm md5 , sha1 , sha224 , sha256 , sha384 , sha512 , sha512t224 ,
 and
-.Nm skein1024
+.Nm sha512t256
 utilities exit 0 on success,
 1 if at least one of the input files could not be read,
 and 2 if at least one file does not have the same hash as the
@@ -285,10 +279,9 @@
 .Pp
 The
 .Nm md5sum , sha1sum , sha224sum , sha256sum , sha384sum , sha512sum ,
-.Nm sha512t224sum , sha512t256sum ,
-.Nm rmd160 , skein256 , skein512 , skein1024
+.Nm sha512t224sum ,
 and
-.Nm shasum
+.Nm sha512t256sum
 utilities exit 0 on success and 1 if at least one of the input files
 could not be read or, when verifying checksums, does not have the
 expected checksum.
@@ -373,12 +366,10 @@
 .Sh SEE ALSO
 .Xr cksum 1 ,
 .Xr md5 3 ,
-.Xr ripemd 3 ,
 .Xr sha 3 ,
 .Xr sha256 3 ,
 .Xr sha384 3 ,
 .Xr sha512 3 ,
-.Xr skein 3
 .Rs
 .%A R. Rivest
 .%T The MD5 Message-Digest Algorithm
@@ -395,15 +386,8 @@
 .%O RFC 3174
 .Re
 .Pp
-RIPEMD-160 is part of the ISO draft standard
-.Qq ISO/IEC DIS 10118-3
-on dedicated hash functions.
-.Pp
 Secure Hash Standard (SHS):
 .Pa https://www.nist.gov/publications/secure-hash-standard-shs
-.Pp
-The RIPEMD-160 page:
-.Pa https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
 .Sh BUGS
 In bits mode, the original
 .Nm shasum
@@ -415,15 +399,12 @@
 This utility was originally derived from a program which was placed in
 the public domain for free general use by RSA Data Security.
 .Pp
-Support for SHA-1 and RIPEMD-160 was added by
+Support for SHA-1 was added by
 .An Oliver Eikemeier Aq Mt eik@FreeBSD.org .
 .Pp
 Support for SHA-2 was added by
 .An Colin Percival Aq Mt cperciva@FreeBSD.org
 and
-.An Allan Jude Aq Mt allanjude@FreeBSD.org .
-.Pp
-Support for SKEIN was added by
 .An Allan Jude Aq Mt allanjude@FreeBSD.org .
 .Pp
 Compatibility with GNU coreutils was added by
--- src.orig/coreutils/md5/md5.c
+++ src.freebsd/coreutils/md5/md5.c
@@ -17,6 +17,8 @@
  *  documentation and/or software.
  */
 
+#include "config-compat.h"
+
 #include <sys/cdefs.h>
 #include <sys/param.h>
 #include <sys/resource.h>
@@ -28,15 +30,12 @@
 #include <fcntl.h>
 #include <getopt.h>
 #include <md5.h>
-#include <osreldate.h>
-#include <ripemd.h>
 #include <sha.h>
 #include <sha224.h>
 #include <sha256.h>
 #include <sha384.h>
 #include <sha512.h>
 #include <sha512t.h>
-#include <skein.h>
 #include <stdbool.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -71,9 +70,9 @@
 static bool failed;
 static int endl = '\n';
 
-typedef void (DIGEST_Init)(void *);
-typedef void (DIGEST_Update)(void *, const unsigned char *, size_t);
-typedef char *(DIGEST_End)(void *, char *);
+typedef void (DIGEST_Init)(EVP_MD_CTX **);
+typedef void (DIGEST_Update)(EVP_MD_CTX **, const void *, size_t);
+typedef char *(DIGEST_End)(EVP_MD_CTX **, char *);
 
 extern const char *MD5TestOutput[MDTESTCOUNT];
 extern const char *SHA1_TestOutput[MDTESTCOUNT];
@@ -83,10 +82,12 @@
 extern const char *SHA512_TestOutput[MDTESTCOUNT];
 extern const char *SHA512t224_TestOutput[MDTESTCOUNT];
 extern const char *SHA512t256_TestOutput[MDTESTCOUNT];
+#if 0
 extern const char *RIPEMD160_TestOutput[MDTESTCOUNT];
 extern const char *SKEIN256_TestOutput[MDTESTCOUNT];
 extern const char *SKEIN512_TestOutput[MDTESTCOUNT];
 extern const char *SKEIN1024_TestOutput[MDTESTCOUNT];
+#endif
 
 typedef struct Algorithm_t {
 	const char *progname;
@@ -99,7 +100,6 @@
 	char *(*Data)(const void *, unsigned int, char *);
 } Algorithm_t;
 
-static void MD5_Update(MD5_CTX *, const unsigned char *, size_t);
 static char *MDInput(const Algorithm_t *, FILE *, char *, bool);
 static void MDOutput(const Algorithm_t *, char *, const char *);
 static void MDTimeTrial(const Algorithm_t *);
@@ -107,6 +107,7 @@
 static void usage(const Algorithm_t *);
 static void version(void);
 
+#if 0
 typedef union {
 	MD5_CTX md5;
 	SHA1_CTX sha1;
@@ -119,6 +120,8 @@
 	SKEIN512_CTX skein512;
 	SKEIN1024_CTX skein1024;
 } DIGEST_CTX;
+#endif
+typedef EVP_MD_CTX *DIGEST_CTX;
 
 /* max(MD5_DIGEST_LENGTH, SHA_DIGEST_LENGTH,
 	SHA256_DIGEST_LENGTH, SHA512_DIGEST_LENGTH,
@@ -160,6 +163,7 @@
 		&SHA512t256_TestOutput, (DIGEST_Init*)&SHA512_256_Init,
 		(DIGEST_Update*)&SHA512_256_Update, (DIGEST_End*)&SHA512_256_End,
 		&SHA512_256_Data },
+#if 0
 	{ "rmd160", NULL, "RMD160",
 		&RIPEMD160_TestOutput,
 		(DIGEST_Init*)&RIPEMD160_Init, (DIGEST_Update*)&RIPEMD160_Update,
@@ -176,6 +180,7 @@
 		&SKEIN1024_TestOutput,
 		(DIGEST_Init*)&SKEIN1024_Init, (DIGEST_Update*)&SKEIN1024_Update,
 		(DIGEST_End*)&SKEIN1024_End, &SKEIN1024_Data },
+#endif
 	{ }
 };
 
@@ -278,11 +283,13 @@
 };
 static const char *perl_shortopts = "0a:bchqstUvw";
 
+#if 0
 static void
 MD5_Update(MD5_CTX *c, const unsigned char *data, size_t len)
 {
 	MD5Update(c, data, len);
 }
+#endif
 
 struct chksumrec {
 	char	*filename;
@@ -393,7 +400,7 @@
 	char   *p, *string = NULL;
 	char	buf[HEX_DIGEST_LENGTH];
 	size_t	len;
-	struct chksumrec	*rec;
+	struct chksumrec	*rec = NULL;
 
 	if ((progname = strrchr(argv[0], '/')) == NULL)
 		progname = argv[0];
@@ -677,7 +684,7 @@
 	DIGEST_CTX context;
 	char *end, *p, *q;
 	size_t len;
-	int bits;
+	int bits = 0;
 	uint8_t byte;
 	bool cr = false;
 
@@ -942,6 +949,7 @@
 	"dd095fc859b336c30a52548b3dc59fcc0d1be8616ebcf3368fad23107db2d736"
 };
 
+#if 0
 const char *RIPEMD160_TestOutput[MDTESTCOUNT] = {
 	"9c1185a5c5e9fc54612808977ee8f548b2258d31",
 	"0bdc9d2d256b3ee9daae347be6f4dc835a467ffe",
@@ -985,6 +993,7 @@
 	"cf21a613620e6c119eca31fdfaad449a8e02f95ca256c21d2a105f8e4157048f9fe1e897893ea18b64e0e37cb07d5ac947f27ba544caf7cbc1ad094e675aed77a366270f7eb7f46543bccfa61c526fd628408058ed00ed566ac35a9761d002e629c4fb0d430b2f4ad016fcc49c44d2981c4002da0eecc42144160e2eaea4855a",
 	"e6799b78db54085a2be7ff4c8007f147fa88d326abab30be0560b953396d8802feee9a15419b48a467574e9283be15685ca8a079ee52b27166b64dd70b124b1d4e4f6aca37224c3f2685e67e67baef9f94b905698adc794a09672aba977a61b20966912acdb08c21a2c37001785355dc884751a21f848ab36e590331ff938138"
 };
+#endif
 
 static void
 MDTestSuite(const Algorithm_t *alg)
@@ -1028,8 +1037,6 @@
 {
 	if (mode == mode_gnu)
 		printf("%s (FreeBSD) ", progname);
-	printf("%d.%d\n",
-	    __FreeBSD_version / 100000,
-	    (__FreeBSD_version / 1000) % 100);
+	printf("%s\n", PROJECT_VERSION);
 	exit(0);
 }
--- src.orig/coreutils/mknod/mknod.c
+++ src.freebsd/coreutils/mknod/mknod.c
@@ -48,6 +48,7 @@
 
 #include <sys/types.h>
 #include <sys/stat.h>
+#include <sys/sysmacros.h>
 
 #include <err.h>
 #include <errno.h>
--- src.orig/coreutils/mktemp/mktemp.c
+++ src.freebsd/coreutils/mktemp/mktemp.c
@@ -36,6 +36,7 @@
  * more like the OpenBSD version - which was first to publish the interface.
  */
 
+#include <sys/cdefs.h>
 #include <err.h>
 #include <getopt.h>
 #include <paths.h>
--- src.orig/coreutils/mv/mv.c
+++ src.freebsd/coreutils/mv/mv.c
@@ -50,7 +50,10 @@
 #include <sys/time.h>
 #include <sys/wait.h>
 #include <sys/stat.h>
+#include <sys/xattr.h>
 #include <sys/mount.h>
+#include <sys/statvfs.h>
+#include <acl/libacl.h>
 
 #include <err.h>
 #include <errno.h>
@@ -76,6 +79,8 @@
 static void	usage(void);
 static void	preserve_fd_acls(int source_fd, int dest_fd, const char *source_path,
 		    const char *dest_path);
+static void	preserve_fd_xattrs(int source_fd, int dest_fd, const char *source_path,
+		    const char *dest_path);
 
 int
 main(int argc, char *argv[])
@@ -176,6 +181,8 @@
 	struct stat sb;
 	int ask, ch, first;
 	char modep[15];
+	struct passwd *pw = NULL;
+	struct group *gr = NULL;
 
 	/*
 	 * Check access.  If interactive and file exists, ask user if it
@@ -201,10 +208,15 @@
 			ask = 1;
 		} else if (access(to, W_OK) && !stat(to, &sb) && isatty(STDIN_FILENO)) {
 			strmode(sb.st_mode, modep);
+			pw = getpwuid(sb.st_uid);
+			if (pw == NULL)
+				err(EXIT_FAILURE, "getpwuid");
+			gr = getgrgid(sb.st_gid);
+			if (gr == NULL)
+				err(EXIT_FAILURE, "getgrgid");
 			(void)fprintf(stderr, "override %s%s%s/%s for %s? %s",
 			    modep + 1, modep[9] == ' ' ? "" : " ",
-			    user_from_uid((unsigned long)sb.st_uid, 0),
-			    group_from_gid((unsigned long)sb.st_gid, 0), to, YESNO);
+			    pw->pw_name, gr->gr_name, to, YESNO);
 			ask = 1;
 		}
 		if (ask) {
@@ -229,7 +241,6 @@
 	}
 
 	if (errno == EXDEV) {
-		struct statfs sfs;
 		char path[PATH_MAX];
 
 		/*
@@ -246,11 +257,6 @@
 				warn("cannot resolve %s: %s", from, path);
 				return (1);
 			}
-			if (!statfs(path, &sfs) &&
-			    !strcmp(path, sfs.f_mntonname)) {
-				warnx("cannot rename a mount point");
-				return (1);
-			}
 		}
 	} else {
 		warn("rename %s to %s", from, to);
@@ -278,7 +284,6 @@
 	static char *bp = NULL;
 	mode_t oldmode;
 	int nread, from_fd, to_fd;
-	struct stat tsb;
 
 	if ((from_fd = open(from, O_RDONLY, 0)) < 0) {
 		warn("fastcopy: open() failed (from): %s", from);
@@ -324,6 +329,7 @@
 	}
 	if (fchmod(to_fd, sbp->st_mode))
 		warn("%s: set mode (was: 0%03o)", to, oldmode);
+	preserve_fd_xattrs(from_fd, to_fd, from, to);
 	/*
 	 * POSIX 1003.2c states that if _POSIX_ACL_EXTENDED is in effect
 	 * for dest_file, then its ACLs shall reflect the ACLs of the
@@ -338,6 +344,7 @@
 	 * if the server supports flags and we were trying to *remove* flags
 	 * on a file that we copied, i.e., that we didn't create.)
 	 */
+#if 0
 	if (fstat(to_fd, &tsb) == 0) {
 		if ((sbp->st_flags  & ~UF_ARCHIVE) !=
 		    (tsb.st_flags & ~UF_ARCHIVE)) {
@@ -350,7 +357,7 @@
 		}
 	} else
 		warn("%s: cannot stat", to);
-
+#endif
 	ts[0] = sbp->st_atim;
 	ts[1] = sbp->st_mtim;
 	if (futimens(to_fd, ts))
@@ -453,9 +460,9 @@
     const char *dest_path)
 {
 	acl_t acl;
-	acl_type_t acl_type;
-	int acl_supported = 0, ret, trivial;
+	int acl_supported = 0, ret;
 
+#if 0
 	ret = fpathconf(source_fd, _PC_ACL_NFS4);
 	if (ret > 0 ) {
 		acl_supported = 1;
@@ -465,13 +472,13 @@
 		    source_path);
 		return;
 	}
+#endif
 	if (acl_supported == 0) {
-		ret = fpathconf(source_fd, _PC_ACL_EXTENDED);
+		ret = acl_extended_fd(source_fd);
 		if (ret > 0 ) {
 			acl_supported = 1;
-			acl_type = ACL_TYPE_ACCESS;
-		} else if (ret < 0 && errno != EINVAL) {
-			warn("fpathconf(..., _PC_ACL_EXTENDED) failed for %s",
+		} else if (ret < 0 && errno != ENOTSUP) {
+			warn("acl_extended_fd() failed for %s",
 			    source_path);
 			return;
 		}
@@ -479,26 +486,80 @@
 	if (acl_supported == 0)
 		return;
 
-	acl = acl_get_fd_np(source_fd, acl_type);
+	acl = acl_get_fd(source_fd);
 	if (acl == NULL) {
 		warn("failed to get acl entries for %s", source_path);
 		return;
 	}
-	if (acl_is_trivial_np(acl, &trivial)) {
-		warn("acl_is_trivial() failed for %s", source_path);
-		acl_free(acl);
-		return;
-	}
-	if (trivial) {
-		acl_free(acl);
-		return;
-	}
-	if (acl_set_fd_np(dest_fd, acl, acl_type) < 0) {
+	if (acl_set_fd(dest_fd, acl) < 0) {
 		warn("failed to set acl entries for %s", dest_path);
 		acl_free(acl);
 		return;
 	}
 	acl_free(acl);
+}
+
+static void
+preserve_fd_xattrs(int source_fd, int dest_fd, const char *source_path,
+    const char *dest_path)
+{
+    ssize_t size;
+    char buf[256], vbuf[128];
+    char *names, *name, *nend;
+    char *value = vbuf;
+    size_t vbufs = sizeof(vbuf);
+
+    size = flistxattr(source_fd, NULL, 0);
+    if (size < 0) {
+        if (errno != ENOTSUP) warn("failed to get xattrs for %s", source_path);
+        return;
+    }
+
+    if (size < (ssize_t)sizeof(buf)) {
+        names = buf;
+    } else {
+        names = malloc(size + 1);
+        if (!names) err(1, "Not enough memory");
+    }
+
+    size = flistxattr(source_fd, names, size);
+    if (size < 0) {
+        if (errno != ENOTSUP) warn("failed to get xattrs for %s", source_path);
+        if (names != buf) free(names);
+        return;
+    }
+    names[size] = '\0';
+    nend = names + size;
+
+    for (name = names; name != nend; name = strchr(name, '\0') + 1) {
+        size = fgetxattr(source_fd, name, NULL, 0);
+        if (size < 0) {
+            if (errno != ENOTSUP)
+                warn("failed to get xattr %s for %s", name, source_path);
+            continue;
+        }
+        if (size > (ssize_t)vbufs) {
+            if (value == vbuf) value = NULL;
+            value = realloc(value, size);
+            if (!value) {
+                err(1, "Not enough memory");
+            }
+            vbufs = size;
+        }
+        size = fgetxattr(source_fd, name, value, size);
+        if (size < 0) {
+            if (errno != ENOTSUP)
+                warn("failed to get xattr %s for %s", name, source_path);
+            continue;
+        }
+        if (fsetxattr(dest_fd, name, value, size, 0)) {
+            if (errno != ENOTSUP)
+                warn("failed to set xattr %s for %s", name, dest_path);
+        }
+    }
+
+    if (names != buf) free(names);
+    if (value != vbuf) free(value);
 }
 
 static void
--- src.orig/coreutils/pr/pr.c
+++ src.freebsd/coreutils/pr/pr.c
@@ -63,6 +63,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <time_bsd.h>
 
 #include "pr.h"
 #include "extern.h"
@@ -1399,7 +1400,7 @@
 	/*
 	 * set up time field used in header
 	 */
-	if (strftime(buf, HDBUF, timefrmt, timeptr) <= 0) {
+	if (strftime_bsd(buf, HDBUF, timefrmt, timeptr) <= 0) {
 		++errcnt;
 		if (inf != stdin)
 			(void)fclose(inf);
@@ -1855,7 +1856,9 @@
 
 	(void) setlocale(LC_TIME, (Lflag != NULL) ? Lflag : "");
 
-	d_first = (*nl_langinfo(D_MD_ORDER) == 'd');
+	d_first = 0;
+	if (strlen(nl_langinfo(D_FMT)) >= 2 && nl_langinfo(D_FMT)[1] == 'd')
+		d_first = 1;
 	timefrmt = strdup(d_first ? TIMEFMTD : TIMEFMTM);
 
 	return(0);
--- src.orig/coreutils/rm/rm.1
+++ src.freebsd/coreutils/rm/rm.1
@@ -41,7 +41,7 @@
 .Sh SYNOPSIS
 .Nm
 .Op Fl f | i
-.Op Fl dIRrvWx
+.Op Fl dIRrvx
 .Ar
 .Nm unlink
 .Op Fl -
@@ -109,11 +109,6 @@
 .Fl R .
 .It Fl v
 Be verbose when deleting files, showing them as they are removed.
-.It Fl W
-Attempt to undelete the named files.
-Currently, this option can only be used to recover
-files covered by whiteouts in a union file system (see
-.Xr undelete 2 ) .
 .It Fl x
 When removing a hierarchy, do not cross mount points.
 .El
@@ -210,9 +205,7 @@
 .Fx 13
 and may be removed in the future.
 .Sh SEE ALSO
-.Xr chflags 1 ,
 .Xr rmdir 1 ,
-.Xr undelete 2 ,
 .Xr unlink 2 ,
 .Xr fts 3 ,
 .Xr getopt 3 ,
--- src.orig/coreutils/rm/rm.c
+++ src.freebsd/coreutils/rm/rm.c
@@ -52,13 +52,14 @@
 #include <grp.h>
 #include <locale.h>
 #include <pwd.h>
+#include <signal.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <sysexits.h>
 #include <unistd.h>
 
-static int dflag, eval, fflag, iflag, vflag, Wflag, stdin_ok;
+static int dflag, eval, fflag, iflag, vflag, stdin_ok;
 static int rflag, Iflag, xflag;
 static uid_t uid;
 static volatile sig_atomic_t info;
@@ -107,7 +108,7 @@
 	}
 
 	rflag = xflag = 0;
-	while ((ch = getopt(argc, argv, "dfiIPRrvWx")) != -1)
+	while ((ch = getopt(argc, argv, "dfiIPRrvx")) != -1)
 		switch(ch) {
 		case 'd':
 			dflag = 1;
@@ -133,9 +134,6 @@
 		case 'v':
 			vflag = 1;
 			break;
-		case 'W':
-			Wflag = 1;
-			break;
 		case 'x':
 			xflag = 1;
 			break;
@@ -196,8 +194,6 @@
 	flags = FTS_PHYSICAL;
 	if (!needstat)
 		flags |= FTS_NOSTAT;
-	if (Wflag)
-		flags |= FTS_WHITEOUT;
 	if (xflag)
 		flags |= FTS_XDEV;
 	if (!(fts = fts_open(argv, flags, NULL))) {
@@ -236,12 +232,6 @@
 				(void)fts_set(fts, p, FTS_SKIP);
 				p->fts_number = SKIPPED;
 			}
-			else if (!uid &&
-				 (p->fts_statp->st_flags & (UF_APPEND|UF_IMMUTABLE)) &&
-				 !(p->fts_statp->st_flags & (SF_APPEND|SF_IMMUTABLE)) &&
-				 lchflags(p->fts_accpath,
-					 p->fts_statp->st_flags &= ~(UF_APPEND|UF_IMMUTABLE)) < 0)
-				goto err;
 			continue;
 		case FTS_DP:
 			/* Post-order: see if user skipped. */
@@ -255,11 +245,13 @@
 		}
 
 		rval = 0;
+#if 0
 		if (!uid &&
 		    (p->fts_statp->st_flags & (UF_APPEND|UF_IMMUTABLE)) &&
 		    !(p->fts_statp->st_flags & (SF_APPEND|SF_IMMUTABLE)))
 			rval = lchflags(p->fts_accpath,
 				       p->fts_statp->st_flags &= ~(UF_APPEND|UF_IMMUTABLE));
+#endif
 		if (rval == 0) {
 			/*
 			 * If we can't read or search the directory, may still be
@@ -282,7 +274,7 @@
 					continue;
 				}
 				break;
-
+#if 0
 			case FTS_W:
 				rval = undelete(p->fts_accpath);
 				if (rval == 0 && (fflag && errno == ENOENT)) {
@@ -297,7 +289,7 @@
 					continue;
 				}
 				break;
-
+#endif
 			case FTS_NS:
 				/*
 				 * Assume that since fts_read() couldn't stat
@@ -306,7 +298,6 @@
 				if (fflag)
 					continue;
 				/* FALLTHROUGH */
-
 			case FTS_F:
 			case FTS_NSOK:
 			default:
@@ -324,7 +315,6 @@
 				}
 			}
 		}
-err:
 		warn("%s", p->fts_path);
 		eval = 1;
 	}
@@ -347,18 +337,10 @@
 	while ((f = *argv++) != NULL) {
 		/* Assume if can't stat the file, can't unlink it. */
 		if (lstat(f, &sb)) {
-			if (Wflag) {
-				sb.st_mode = S_IFWHT|S_IWUSR|S_IRUSR;
-			} else {
-				if (!fflag || errno != ENOENT) {
-					warn("%s", f);
-					eval = 1;
-				}
-				continue;
+			if (!fflag || errno != ENOENT) {
+				warn("%s", f);
+				eval = 1;
 			}
-		} else if (Wflag) {
-			warnx("%s: %s", f, strerror(EEXIST));
-			eval = 1;
 			continue;
 		}
 
@@ -367,21 +349,12 @@
 			eval = 1;
 			continue;
 		}
-		if (!fflag && !S_ISWHT(sb.st_mode) && !check(f, f, &sb))
+		if (!fflag && !check(f, f, &sb))
 			continue;
-		rval = 0;
-		if (!uid && !S_ISWHT(sb.st_mode) &&
-		    (sb.st_flags & (UF_APPEND|UF_IMMUTABLE)) &&
-		    !(sb.st_flags & (SF_APPEND|SF_IMMUTABLE)))
-			rval = lchflags(f, sb.st_flags & ~(UF_APPEND|UF_IMMUTABLE));
-		if (rval == 0) {
-			if (S_ISWHT(sb.st_mode))
-				rval = undelete(f);
-			else if (S_ISDIR(sb.st_mode))
-				rval = rmdir(f);
-			else
-				rval = unlink(f);
-		}
+		if (S_ISDIR(sb.st_mode))
+			rval = rmdir(f);
+		else
+			rval = unlink(f);
 		if (rval && (!fflag || errno != ENOENT)) {
 			warn("%s", f);
 			eval = 1;
@@ -399,7 +372,9 @@
 check(const char *path, const char *name, struct stat *sp)
 {
 	int ch, first;
-	char modep[15], *flagsp;
+	char modep[15];
+	struct passwd *pw = NULL;
+	struct group *gr = NULL;
 
 	/* Check -i first. */
 	if (iflag)
@@ -411,21 +386,20 @@
 		 * because their permissions are meaningless.  Check stdin_ok
 		 * first because we may not have stat'ed the file.
 		 */
-		if (!stdin_ok || S_ISLNK(sp->st_mode) ||
-		    (!access(name, W_OK) &&
-		    !(sp->st_flags & (SF_APPEND|SF_IMMUTABLE)) &&
-		    (!(sp->st_flags & (UF_APPEND|UF_IMMUTABLE)) || !uid)))
+		if (!stdin_ok || S_ISLNK(sp->st_mode) || !access(name, W_OK))
 			return (1);
 		strmode(sp->st_mode, modep);
-		if ((flagsp = fflagstostr(sp->st_flags)) == NULL)
-			err(1, "fflagstostr");
-		(void)fprintf(stderr, "override %s%s%s/%s %s%sfor %s? ",
+		pw = getpwuid(sp->st_uid);
+		if (pw == NULL)
+			err(EXIT_FAILURE, "getpwuid");
+		gr = getgrgid(sp->st_gid);
+		if (gr == NULL)
+			err(EXIT_FAILURE, "getgrgid");
+		(void)fprintf(stderr, "override %s%s%s/%s for %s? ",
 		    modep + 1, modep[10] == ' ' ? "" : " ",
-		    user_from_uid(sp->st_uid, 0),
-		    group_from_gid(sp->st_gid, 0),
-		    *flagsp ? flagsp : "", *flagsp ? " " : "",
+		    pw->pw_name,
+		    gr->gr_name,
 		    path);
-		free(flagsp);
 	}
 	(void)fflush(stderr);
 
--- src.orig/coreutils/seq/seq.1
+++ src.freebsd/coreutils/seq/seq.1
@@ -95,7 +95,10 @@
 defined in
 .St -ansiC .
 The default is
-.Cm %g .
+.Cm %g ,
+unless all numbers are integers representable losslessly as floating
+point (with mantissa bits), in which case the default is
+.Cm %.0f .
 .It Fl s Ar string , Fl -separator Ar string
 Use
 .Ar string
--- src.orig/coreutils/seq/seq.c
+++ src.freebsd/coreutils/seq/seq.c
@@ -36,6 +36,7 @@
 #include <errno.h>
 #include <getopt.h>
 #include <math.h>
+#include <float.h>
 #include <locale.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -49,12 +50,17 @@
 #define ISSIGN(c)	((int)(c) == '-' || (int)(c) == '+')
 #define ISEXP(c)	((int)(c) == 'e' || (int)(c) == 'E')
 #define ISODIGIT(c)	((int)(c) >= '0' && (int)(c) <= '7')
+#define VALID_INT(v)	(floor(v) == (v) && fabs(v) <= abs_int_max)
 
 /* Globals */
 
 static const char *decimal_point = ".";	/* default */
 static char default_format[] = { "%g" };	/* default */
+static char integer_format[] = { "%.0f" };	/* for integer printing */
 
+/* largest representable integer in a double */
+static const double abs_int_max = (double)(1ULL << DBL_MANT_DIG);
+
 static const struct option long_opts[] = {
 	{"format",	required_argument,	NULL, 'f'},
 	{"separator",	required_argument,	NULL, 's'},
@@ -71,7 +77,7 @@
 static int numeric(const char *);
 static int valid_format(const char *);
 
-static char *generate_format(double, double, double, int, char);
+static char *generate_format(double, double, double, int, char, int *);
 static char *unescape(char *);
 
 /*
@@ -87,7 +93,7 @@
 	struct lconv *locale;
 	char pad, *fmt, *cur_print, *last_print, *prev_print;
 	double first, last, incr, prev, cur, step;
-	int c, errflg, equalize;
+	int c, errflg, equalize, may_trunc = 1;
 
 	pad = ZERO;
 	fmt = NULL;
@@ -177,7 +183,7 @@
 		 * newline if none found at the end of the format string.
 		 */
 	} else
-		fmt = generate_format(first, incr, last, equalize, pad);
+		fmt = generate_format(first, incr, last, equalize, pad, &may_trunc);
 
 	for (step = 1, cur = first; incr > 0 ? cur <= last : cur >= last;
 	    cur = first + incr * step++) {
@@ -187,6 +193,13 @@
 	}
 
 	/*
+	 * If we guarantee no truncation (which happens when only integers are
+	 * used), skip the code below in order to avoid extra allocations.
+	 */
+	if (!may_trunc)
+		goto do_term;
+
+	/*
 	 * Did we miss the last value of the range in the loop above?
 	 *
 	 * We might have, so check if the printable version of the last
@@ -209,6 +222,7 @@
 	free(last_print);
 	free(prev_print);
 
+do_term:
 	if (term != NULL)
 		fputs(term, stdout);
 
@@ -456,27 +470,36 @@
  * when "%g" prints as "%e" (this way no width adjustments are made)
  */
 static char *
-generate_format(double first, double incr, double last, int equalize, char pad)
+generate_format(double first, double incr, double last, int equalize, char pad, int *may_trunc)
 {
 	static char buf[256];
 	char cc = '\0';
 	int precision, width1, width2, places;
+	int do_ints = 0;
+	char *def_fmt;
 
-	if (equalize == 0)
-		return (default_format);
-
 	/* figure out "last" value printed */
 	if (first > last)
 		last = first - incr * floor((first - last) / incr);
 	else
 		last = first + incr * floor((last - first) / incr);
 
-	sprintf(buf, "%g", incr);
+	do_ints = VALID_INT(first) && VALID_INT(last) && VALID_INT(incr);
+	if (do_ints) {
+		*may_trunc = 0;
+		def_fmt = (integer_format);
+	} else
+		def_fmt = (default_format);
+
+	if (equalize == 0)
+		return def_fmt;
+
+	sprintf(buf, def_fmt, incr);
 	if (strchr(buf, 'e'))
 		cc = 'e';
 	precision = decimal_places(buf);
 
-	width1 = sprintf(buf, "%g", first);
+	width1 = sprintf(buf, def_fmt, first);
 	if (strchr(buf, 'e'))
 		cc = 'e';
 	if ((places = decimal_places(buf)))
@@ -484,7 +507,7 @@
 
 	precision = MAX(places, precision);
 
-	width2 = sprintf(buf, "%g", last);
+	width2 = sprintf(buf, def_fmt, last);
 	if (strchr(buf, 'e'))
 		cc = 'e';
 	if ((places = decimal_places(buf)))
@@ -494,6 +517,8 @@
 		sprintf(buf, "%%%c%d.%d%c", pad,
 		    MAX(width1, width2) + (int) strlen(decimal_point) +
 		    precision, precision, (cc) ? cc : 'f');
+	} else if (do_ints) {
+		sprintf(buf, "%%%c%d.0f", pad, MAX(width1, width2));
 	} else {
 		sprintf(buf, "%%%c%d%c", pad, MAX(width1, width2),
 		    (cc) ? cc : 'g');
--- src.orig/coreutils/sleep/sleep.1
+++ src.freebsd/coreutils/sleep/sleep.1
@@ -60,7 +60,7 @@
 .Nm
 command receives a signal, it takes the standard action.
 When the
-.Dv SIGINFO
+.Dv SIGUSR1
 signal is received, the estimate of the amount of seconds left to
 sleep is printed on the standard output.
 .Sh IMPLEMENTATION NOTES
--- src.orig/coreutils/sort/coll.c
+++ src.freebsd/coreutils/sort/coll.c
@@ -35,7 +35,9 @@
 #include <langinfo.h>
 #include <limits.h>
 #include <math.h>
+#ifndef WITHOUT_LIBCRYPTO
 #include <md5.h>
+#endif
 #include <stdlib.h>
 #include <string.h>
 #include <wchar.h>
@@ -58,7 +60,9 @@
 static int monthcoll(struct key_value*, struct key_value *, size_t offset);
 static int numcoll(struct key_value*, struct key_value *, size_t offset);
 static int hnumcoll(struct key_value*, struct key_value *, size_t offset);
+#ifndef WITHOUT_LIBCRYPTO
 static int randomcoll(struct key_value*, struct key_value *, size_t offset);
+#endif
 static int versioncoll(struct key_value*, struct key_value *, size_t offset);
 
 /*
@@ -469,8 +473,10 @@
 		return (gnumcoll);
 	else if (sm->Mflag)
 		return (monthcoll);
+#ifndef WITHOUT_LIBCRYPTO
 	else if (sm->Rflag)
 		return (randomcoll);
+#endif
 	else if (sm->Vflag)
 		return (versioncoll);
 	else
@@ -603,18 +609,18 @@
  * Compare two sort list items, according to the sort specs.
  */
 int
-list_coll(struct sort_list_item **ss1, struct sort_list_item **ss2)
+list_coll(const void *ss1, const void *ss2)
 {
 
-	return (list_coll_offset(ss1, ss2, 0));
+	return (list_coll_offset((struct sort_list_item **)ss1, (struct sort_list_item **)ss2, 0));
 }
 
 #define	LSCDEF(N)							\
 static int 								\
-list_coll_##N(struct sort_list_item **ss1, struct sort_list_item **ss2)	\
+list_coll_##N(const void *ss1, const void *ss2)	\
 {									\
 									\
-	return (list_coll_offset(ss1, ss2, N));				\
+	return (list_coll_offset((struct sort_list_item **)ss1, (struct sort_list_item **)ss2, N)); \
 }
 
 LSCDEF(1)
@@ -658,9 +664,10 @@
  * Compare two sort list items, only by their original string.
  */
 int
-list_coll_by_str_only(struct sort_list_item **ss1, struct sort_list_item **ss2)
+list_coll_by_str_only(const void *a1, const void *a2)
 {
-
+	struct sort_list_item **ss1 = (struct sort_list_item **)a1;
+	struct sort_list_item **ss2 = (struct sort_list_item **)a2;
 	return (top_level_str_coll(((*ss1)->str), ((*ss2)->str)));
 }
 
@@ -977,6 +984,7 @@
 	return (numcoll_impl(kv1, kv2, offset, true));
 }
 
+#ifndef WITHOUT_LIBCRYPTO
 /* Use hint space to memoize md5 computations, at least. */
 static void
 randomcoll_init_hint(struct key_value *kv, void *hash)
@@ -1033,6 +1041,7 @@
 
 	return (memcmp(hash1, hash2, sizeof(hash1)));
 }
+#endif /* WITHOUT_LIBCRYPTO */
 
 /*
  * Implements version sort (-V).
--- src.orig/coreutils/sort/coll.h
+++ src.freebsd/coreutils/sort/coll.h
@@ -104,7 +104,7 @@
 {
 	struct bwstring		*k; /* key string */
 	struct key_hint		 hint[0]; /* key sort hint */
-} __packed;
+} __attribute__((packed));
 
 /*
  * Set of keys container object.
@@ -140,7 +140,7 @@
 /*
  * Function type, used to compare two list objects
  */
-typedef int (*listcoll_t)(struct sort_list_item **ss1, struct sort_list_item **ss2);
+typedef int (*listcoll_t)(const void *ss1, const void *ss2);
 
 extern struct key_specs *keys;
 extern size_t keys_num;
@@ -172,8 +172,8 @@
 int top_level_str_coll(const struct bwstring *, const struct bwstring *);
 int key_coll(struct keys_array *ks1, struct keys_array *ks2, size_t offset);
 int str_list_coll(struct bwstring *str1, struct sort_list_item **ss2);
-int list_coll_by_str_only(struct sort_list_item **ss1, struct sort_list_item **ss2);
-int list_coll(struct sort_list_item **ss1, struct sort_list_item **ss2);
+int list_coll_by_str_only(const void *ss1, const void *ss2);
+int list_coll(const void *ss1, const void *ss2);
 int list_coll_offset(struct sort_list_item **ss1, struct sort_list_item **ss2, size_t offset);
 
 listcoll_t get_list_call_func(size_t offset);
--- src.orig/coreutils/sort/file.c
+++ src.freebsd/coreutils/sort/file.c
@@ -37,6 +37,7 @@
 #include <fcntl.h>
 #if defined(SORT_THREADS)
 #include <pthread.h>
+#include <sched.h>
 #endif
 #include <semaphore.h>
 #include <stdio.h>
@@ -609,7 +610,7 @@
 			size_t sz = 0;
 			int fd, flags;
 
-			flags = MAP_NOCORE | MAP_NOSYNC;
+			flags = MAP_PRIVATE;
 
 			fd = open(fsrc, O_RDONLY);
 			if (fd < 0)
@@ -631,6 +632,7 @@
 				close(fd);
 				break;
 			}
+			madvise(addr, sz, MADV_DONTDUMP);
 
 			ret->fd = fd;
 			ret->mmapaddr = addr;
@@ -687,7 +689,7 @@
 		}
 		if (len > 0 && fr->buffer[len - 1] == fr->elsymb)
 			len--;
-		ret = bwscsbdup(fr->buffer, len);
+		ret = bwscsbdup((unsigned char *)fr->buffer, len);
 	}
 
 	return (ret);
@@ -1449,7 +1451,7 @@
 			pthread_attr_t attr;
 
 			pthread_attr_init(&attr);
-			pthread_attr_setdetachstate(&attr, PTHREAD_DETACHED);
+			pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
 
 			for (;;) {
 				int res = pthread_create(&pth, &attr,
@@ -1458,7 +1460,7 @@
 				if (res >= 0)
 					break;
 				if (errno == EAGAIN) {
-					pthread_yield();
+					sched_yield();
 					continue;
 				}
 				err(2, NULL);
--- src.orig/coreutils/sort/radixsort.c
+++ src.freebsd/coreutils/sort/radixsort.c
@@ -35,6 +35,7 @@
 #if defined(SORT_THREADS)
 #include <pthread.h>
 #include <semaphore.h>
+#include <sched.h>
 #endif
 #include <stdlib.h>
 #include <string.h>
@@ -642,7 +643,7 @@
 			pthread_t pth;
 
 			pthread_attr_init(&attr);
-			pthread_attr_setdetachstate(&attr, PTHREAD_DETACHED);
+			pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
 
 			for (;;) {
 				int res = pthread_create(&pth, &attr,
@@ -650,7 +651,7 @@
 				if (res >= 0)
 					break;
 				if (errno == EAGAIN) {
-					pthread_yield();
+					sched_yield();
 					continue;
 				}
 				err(2, NULL);
@@ -679,7 +680,9 @@
 		pthread_mutexattr_t mattr;
 
 		pthread_mutexattr_init(&mattr);
+#ifdef PTHREAD_MUTEX_ADAPTIVE_NP
 		pthread_mutexattr_settype(&mattr, PTHREAD_MUTEX_ADAPTIVE_NP);
+#endif
 
 		pthread_mutex_init(&g_ls_mutex, &mattr);
 		pthread_cond_init(&g_ls_cond, NULL);
--- src.orig/coreutils/sort/sort.1
+++ src.freebsd/coreutils/sort/sort.1
@@ -327,9 +327,9 @@
 .It Fl Fl debug
 Print some extra information about the sorting process to the
 standard output.
-%%THREADS%%.It Fl Fl parallel
-%%THREADS%%Set the maximum number of execution threads.
-%%THREADS%%Default number equals to the number of CPUs.
+.It Fl Fl parallel
+Set the maximum number of execution threads.
+Default number equals to the number of CPUs.
 .It Fl Fl files0-from Ns = Ns Ar filename
 Take the input file list from the file
 .Ar filename .
--- src.orig/coreutils/sort/sort.c
+++ src.freebsd/coreutils/sort/sort.c
@@ -29,7 +29,6 @@
 
 #include <sys/cdefs.h>
 #include <sys/stat.h>
-#include <sys/sysctl.h>
 #include <sys/types.h>
 
 #include <err.h>
@@ -38,7 +37,9 @@
 #include <getopt.h>
 #include <limits.h>
 #include <locale.h>
+#ifndef WITHOUT_LIBCRYPTO
 #include <md5.h>
+#endif
 #include <regex.h>
 #include <signal.h>
 #include <stdbool.h>
@@ -55,9 +56,11 @@
 
 #define	OPTIONS	"bcCdfghik:Mmno:RrsS:t:T:uVz"
 
+#ifndef WITHOUT_LIBCRYPTO
 static bool need_random;
 
 MD5_CTX md5_ctx;
+#endif
 
 /*
  * Default messages to use
@@ -83,7 +86,11 @@
       "[--parallel thread_no] "
 #endif
       "[--human-numeric-sort] "
+#ifndef WITHOUT_LIBCRYPTO
+      "[--version-sort]] "
+#else
       "[--version-sort] [--random-sort [--random-source file]] "
+#endif
       "[--compress-program program] [file ...]\n" };
 
 struct sort_opts sort_opts_vals;
@@ -125,7 +132,9 @@
 #if defined(SORT_THREADS)
 	PARALLEL_OPT,
 #endif
+#ifndef WITHOUT_LIBCRYPTO
 	RANDOMSOURCE_OPT,
+#endif
 	COMPRESSPROGRAM_OPT,
 	QSORT_OPT,
 	MERGESORT_OPT,
@@ -166,8 +175,10 @@
 #endif
 				{ "qsort", no_argument, NULL, QSORT_OPT },
 				{ "radixsort", no_argument, NULL, RADIXSORT_OPT },
+#ifndef WITHOUT_LIBCRYPTO
 				{ "random-sort", no_argument, NULL, 'R' },
 				{ "random-source", required_argument, NULL, RANDOMSOURCE_OPT },
+#endif
 				{ "reverse", no_argument, NULL, 'r' },
 				{ "sort", required_argument, NULL, SORT_OPT },
 				{ "stable", no_argument, NULL, 's' },
@@ -321,16 +332,24 @@
 	lc = localeconv();
 
 	if (lc) {
+		wchar_t sym_decimal_point;
+		wchar_t sym_thousands_sep;
+		wchar_t sym_positive_sign;
+		wchar_t sym_negative_sign;
 		/* obtain LC_NUMERIC info */
 		/* Convert to wide char form */
-		conv_mbtowc(&symbol_decimal_point, lc->decimal_point,
+		conv_mbtowc(&sym_decimal_point, lc->decimal_point,
 		    symbol_decimal_point);
-		conv_mbtowc(&symbol_thousands_sep, lc->thousands_sep,
+		conv_mbtowc(&sym_thousands_sep, lc->thousands_sep,
 		    symbol_thousands_sep);
-		conv_mbtowc(&symbol_positive_sign, lc->positive_sign,
+		conv_mbtowc(&sym_positive_sign, lc->positive_sign,
 		    symbol_positive_sign);
-		conv_mbtowc(&symbol_negative_sign, lc->negative_sign,
+		conv_mbtowc(&sym_negative_sign, lc->negative_sign,
 		    symbol_negative_sign);
+		symbol_decimal_point = sym_decimal_point;
+		symbol_thousands_sep = sym_thousands_sep;
+		symbol_positive_sign = sym_positive_sign;
+		symbol_negative_sign = sym_negative_sign;
 	}
 
 	if (getenv("GNUSORT_NUMERIC_COMPATIBILITY"))
@@ -577,11 +596,13 @@
 	case 'i':
 		sm->iflag = true;
 		break;
+#ifndef WITHOUT_LIBCRYPTO
 	case 'R':
 		sm->Rflag = true;
 		need_hint = true;
 		need_random = true;
 		break;
+#endif
 	case 'M':
 		initialise_months();
 		sm->Mflag = true;
@@ -847,7 +868,7 @@
 void
 fix_obsolete_keys(int *argc, char **argv)
 {
-	char sopt[129];
+	char sopt[304];
 
 	for (int i = 1; i < *argc; i++) {
 		char *arg1;
@@ -903,6 +924,7 @@
 	}
 }
 
+#ifndef WITHOUT_LIBCRYPTO
 /*
  * Seed random sort
  */
@@ -975,6 +997,7 @@
 	MD5Init(&md5_ctx);
 	MD5Update(&md5_ctx, randseed, rd);
 }
+#endif /* WITHOUT_LIBCRYPTO */
 
 /*
  * Main function.
@@ -983,7 +1006,9 @@
 main(int argc, char **argv)
 {
 	char *outfile, *real_outfile;
+#ifndef WITHOUT_LIBCRYPTO
 	char *random_source = NULL;
+#endif
 	int c, result;
 	bool mef_flags[NUMBER_OF_MUTUALLY_EXCLUSIVE_FLAGS] =
 	    { false, false, false, false, false, false };
@@ -1110,8 +1135,10 @@
 						set_sort_modifier(sm, 'n');
 					else if (!strcmp(optarg, "month"))
 						set_sort_modifier(sm, 'M');
+#ifndef WITHOUT_LIBCRYPTO
 					else if (!strcmp(optarg, "random"))
 						set_sort_modifier(sm, 'R');
+#endif
 					else
 						unknown(optarg);
 				}
@@ -1140,9 +1167,11 @@
 			case RADIXSORT_OPT:
 				sort_opts_vals.sort_method = SORT_RADIXSORT;
 				break;
+#ifndef WITHOUT_LIBCRYPTO
 			case RANDOMSOURCE_OPT:
 				random_source = strdup(optarg);
 				break;
+#endif
 			case COMPRESSPROGRAM_OPT:
 				compress_program = strdup(optarg);
 				break;
@@ -1235,8 +1264,10 @@
 		}
 	}
 
+#ifndef WITHOUT_LIBCRYPTO
 	if (need_random)
 		get_random_seed(random_source);
+#endif
 
 	/* Case when the outfile equals one of the input files: */
 	if (strcmp(outfile, "-")) {
--- src.orig/coreutils/sort/sort.h
+++ src.freebsd/coreutils/sort/sort.h
@@ -38,7 +38,9 @@
 #include <wchar.h>
 
 #include <sys/types.h>
+#ifndef WITHOUT_LIBCRYPTO
 #include <md5.h>
+#endif
 
 #define	VERSION	"2.3-FreeBSD"
 
@@ -57,10 +59,12 @@
  */
 extern bool debug_sort;
 
+#ifndef WITHOUT_LIBCRYPTO
 /*
  * MD5 context for random hash function
  */
 extern MD5_CTX md5_ctx;
+#endif
 
 /*
  * sort.c
--- src.orig/coreutils/split/split.c
+++ src.freebsd/coreutils/split/split.c
@@ -60,6 +60,10 @@
 #include <regex.h>
 #include <sysexits.h>
 
+#ifndef REG_STARTEND
+#define REG_STARTEND 0
+#endif
+
 #define DEFLINE	1000			/* Default num lines per file. */
 
 static off_t	 bytecnt;		/* Byte count to split on. */
@@ -87,6 +91,7 @@
 	const char *p;
 	char *ep;
 	int ch, error;
+	uint64_t ubytecnt;
 
 	setlocale(LC_ALL, "");
 
@@ -117,7 +122,8 @@
 			break;
 		case 'b':		/* Byte count. */
 			errno = 0;
-			error = expand_number(optarg, &bytecnt);
+			error = expand_number(optarg, &ubytecnt);
+			bytecnt = ubytecnt;
 			if (error == -1)
 				errx(EX_USAGE, "%s: offset too large", optarg);
 			break;
--- src.orig/coreutils/stat/stat.1
+++ src.freebsd/coreutils/stat/stat.1
@@ -36,7 +36,7 @@
 .Nd display file status
 .Sh SYNOPSIS
 .Nm
-.Op Fl FHLnq
+.Op Fl FLnq
 .Op Fl f Ar format | Fl l | r | s | x
 .Op Fl t Ar timefmt
 .Op Ar
@@ -88,11 +88,9 @@
 .Fa st_atime ,
 .Fa st_mtime ,
 .Fa st_ctime ,
-.Fa st_birthtime ,
 .Fa st_blksize ,
-.Fa st_blocks ,
 and
-.Fa st_flags
+.Fa st_blocks
 fields, in that order.
 .Pp
 The options are as follows:
@@ -122,13 +120,6 @@
 .Fl F
 implies
 .Fl l .
-.It Fl H
-Treat each argument as the hexadecimal representation of an NFS file handle,
-and use
-.Xr fhstat 2
-instead of
-.Xr lstat 2 .
-This requires root privileges.
 .It Fl L
 Use
 .Xr stat 2
@@ -180,7 +171,7 @@
 .It Fl t Ar timefmt
 Display timestamps using the specified format.
 This format is
-passed directly to
+passed directly to FreeBSD
 .Xr strftime 3 .
 .It Fl x
 Display information in a more verbose way as known from some
@@ -266,16 +257,11 @@
 May be used in combination with:
 .Bl -tag -width indent
 .It Cm amc
-Display date in
+Display date in FreeBSD
 .Xr strftime 3
 format.
 .It Cm dr
 Display actual device name.
-.It Cm f
-Display the flags of
-.Ar file
-as in
-.Nm ls Fl lTdo .
 .It Cm gu
 Display group or user name.
 .It Cm p
@@ -394,12 +380,11 @@
 .It Cm r
 Device number for character and block device special files
 .Pq Fa st_rdev .
-.It Cm a , m , c , B
+.It Cm a , m , c
 The time
 .Ar file
-was last accessed or modified, or when the inode was last changed, or
-the birth time of the inode
-.Pq Fa st_atime , st_mtime , st_ctime , st_birthtime .
+was last accessed or modified or when the inode was last changed
+.Pq Fa st_atime , st_mtime , st_ctime .
 .It Cm z
 The size of
 .Ar file
@@ -412,9 +397,6 @@
 .It Cm k
 Optimal file system I/O operation block size
 .Pq Fa st_blksize .
-.It Cm f
-User defined flags for
-.Ar file .
 .It Cm v
 Inode generation number
 .Pq Fa st_gen .
--- src.orig/coreutils/stat/stat.c
+++ src.freebsd/coreutils/stat/stat.c
@@ -39,17 +39,18 @@
 #if HAVE_CONFIG_H
 #include "config.h" 
 #else  /* HAVE_CONFIG_H */
-#define HAVE_STRUCT_STAT_ST_FLAGS 1
-#define HAVE_STRUCT_STAT_ST_GEN 1
-#define HAVE_STRUCT_STAT_ST_BIRTHTIME 1
+#define HAVE_STRUCT_STAT_ST_FLAGS 0
+#define HAVE_STRUCT_STAT_ST_GEN 0
+#define HAVE_STRUCT_STAT_ST_BIRTHTIME 0
 #define HAVE_STRUCT_STAT_ST_MTIMENSEC 1
-#define HAVE_DEVNAME 1
+#define HAVE_DEVNAME 0
 #endif /* HAVE_CONFIG_H */
 
 #include <sys/param.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/mount.h>
+#include <sys/sysmacros.h>
 
 #include <ctype.h>
 #include <err.h>
@@ -62,7 +63,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <time.h>
+#include <time_bsd.h>
 #include <unistd.h>
 
 #if HAVE_STRUCT_STAT_ST_FLAGS
@@ -79,10 +80,12 @@
 #define DEF_B "\"%SB\" "
 #define RAW_B "%B "
 #define SHELL_B "st_birthtime=%B "
+#define STR_B "%SB"
 #else /* HAVE_STRUCT_STAT_ST_BIRTHTIME */
 #define DEF_B
 #define RAW_B
 #define SHELL_B
+#define STR_B "-"
 #endif /* HAVE_STRUCT_STAT_ST_BIRTHTIME */
 
 #if HAVE_STRUCT_STAT_ST_ATIM
@@ -111,7 +114,7 @@
 	"Access: %Sa%n" \
 	"Modify: %Sm%n" \
 	"Change: %Sc%n"	\
-	" Birth: %SB"
+	" Birth: " STR_B
 
 #define TIME_FORMAT	"%b %e %T %Y"
 
@@ -206,17 +209,14 @@
 {
 	struct stat st;
 	int ch, rc, errs, am_readlink;
-	int lsF, fmtchar, usestat, nfs_handle, fn, nonl, quiet;
+	int lsF, fmtchar, usestat, fn, nonl, quiet;
 	const char *statfmt, *options, *synopsis;
-	char dname[sizeof _PATH_DEV + SPECNAMELEN] = _PATH_DEV;
-	fhandle_t fhnd;
 	const char *file;
 
 	am_readlink = 0;
 	lsF = 0;
 	fmtchar = '\0';
 	usestat = 0;
-	nfs_handle = 0;
 	nonl = 0;
 	quiet = 0;
 	linkfail = 0;
@@ -231,7 +231,7 @@
 		fmtchar = 'f';
 		quiet = 1;
 	} else {
-		options = "f:FHlLnqrst:x";
+		options = "f:FlLnqrst:x";
 		synopsis = "[-FLnq] [-f format | -l | -r | -s | -x] "
 		    "[-t timefmt] [file|handle ...]";
 	}
@@ -241,9 +241,6 @@
 		case 'F':
 			lsF = 1;
 			break;
-                case 'H':
-			nfs_handle = 1;
-			break;
 		case 'L':
 			usestat = 1;
 			break;
@@ -321,37 +318,11 @@
 	errs = 0;
 	do {
 		if (argc == 0) {
-			if (fdevname_r(STDIN_FILENO, dname +
-			    sizeof _PATH_DEV - 1, SPECNAMELEN) != NULL)
-				file = dname;
-			else
-				file = "(stdin)";
+			file = "(stdin)";
 			rc = fstat(STDIN_FILENO, &st);
 		} else {
-			int j;
-
 			file = argv[0];
-			if (nfs_handle) {
-				rc = 0;
-				bzero(&fhnd, sizeof(fhnd));
-				j = MIN(2 * sizeof(fhnd), strlen(file));
-				if ((j & 1) != 0) {
-					rc = -1;
-				} else {
-					while (j) {
-						rc = hex2byte(&file[j - 2]);
-						if (rc == -1)
-							break;
-						((char*) &fhnd)[j / 2 - 1] = rc;
-						j -= 2;
-					}
-				}
-				if (rc == -1)
-					errno = EINVAL;
-				else
-					rc = fhstat(&fhnd, &st);
-
-			} else if (usestat) {
+			if (usestat) {
 				/*
 				 * Try stat() and if it fails, fall back to
 				 * lstat() just in case we're examining a
@@ -616,8 +587,10 @@
 {
 	u_int64_t data;
 	char *stmp, lfmt[24], tmp[20];
-	const char *sdata;
-	char smode[12], sid[12], path[PATH_MAX + 4];
+	struct passwd *pw = NULL;
+	struct group *gr = NULL;
+	const char *sdata = NULL;
+	char smode[12], sid[13], path[PATH_MAX + 4];
 	const struct timespec *tsp;
 	struct timespec ts;
 	struct tm *tm;
@@ -709,10 +682,12 @@
 	case SHOW_st_uid:
 		small = (sizeof(st->st_uid) == 4);
 		data = st->st_uid;
-		sdata = user_from_uid(st->st_uid, 1);
-		if (sdata == NULL) {
+		pw = getpwuid(st->st_uid);
+		if (pw == NULL) {
 			snprintf(sid, sizeof(sid), "(%ld)", (long)st->st_uid);
 			sdata = sid;
+		} else {
+			sdata = pw->pw_name;
 		}
 		formats = FMTF_DECIMAL | FMTF_OCTAL | FMTF_UNSIGNED | FMTF_HEX |
 		    FMTF_STRING;
@@ -722,10 +697,12 @@
 	case SHOW_st_gid:
 		small = (sizeof(st->st_gid) == 4);
 		data = st->st_gid;
-		sdata = group_from_gid(st->st_gid, 1);
-		if (sdata == NULL) {
+		gr = getgrgid(st->st_gid);
+		if (gr == NULL) {
 			snprintf(sid, sizeof(sid), "(%ld)", (long)st->st_gid);
 			sdata = sid;
+		} else {
+			sdata = gr->gr_name;
 		}
 		formats = FMTF_DECIMAL | FMTF_OCTAL | FMTF_UNSIGNED | FMTF_HEX |
 		    FMTF_STRING;
@@ -733,15 +710,15 @@
 			ofmt = FMTF_UNSIGNED;
 		break;
 	case SHOW_st_atime:
-		tsp = &st->st_atimespec;
+		tsp = &st->st_atim;
 		/* FALLTHROUGH */
 	case SHOW_st_mtime:
 		if (tsp == NULL)
-			tsp = &st->st_mtimespec;
+			tsp = &st->st_mtim;
 		/* FALLTHROUGH */
 	case SHOW_st_ctime:
 		if (tsp == NULL)
-			tsp = &st->st_ctimespec;
+			tsp = &st->st_ctim;
 		/* FALLTHROUGH */
 #if HAVE_STRUCT_STAT_ST_BIRTHTIME
 	case SHOW_st_btime:
@@ -757,7 +734,7 @@
 			tm = localtime(&ts.tv_sec);
 		}
 		(void)setlocale(LC_TIME, "");
-		(void)strftime(path, sizeof(path), timefmt, tm);
+		(void)strftime_bsd(path, sizeof(path), timefmt, tm);
 		sdata = path;
 		formats = FMTF_DECIMAL | FMTF_OCTAL | FMTF_UNSIGNED | FMTF_HEX |
 		    FMTF_FLOAT | FMTF_STRING;
@@ -1085,7 +1062,7 @@
 #define hex2nibble(c) (c <= '9' ? c - '0' : toupper(c) - 'A' + 10)
 int
 hex2byte(const char c[2]) {
-	if (!(ishexnumber(c[0]) && ishexnumber(c[1])))
+	if (!(isxdigit(c[0]) && isxdigit(c[1])))
 		return -1;
 	return (hex2nibble(c[0]) << 4) + hex2nibble(c[1]);
 }
--- src.orig/coreutils/stty/cchar.c
+++ src.freebsd/coreutils/stty/cchar.c
@@ -34,11 +34,14 @@
 #endif /* not lint */
 #include <sys/cdefs.h>
 #include <sys/types.h>
+#include <sys/ttydefaults.h>
 
 #include <err.h>
 #include <limits.h>
 #include <stdlib.h>
 #include <string.h>
+#include <unistd.h>
+#include <termios.h>
 
 #include "stty.h"
 #include "extern.h"
@@ -54,12 +57,10 @@
  */
 struct cchar cchars1[] = {
 	{ "discard",	VDISCARD, 	CDISCARD },
-	{ "dsusp", 	VDSUSP,		CDSUSP },
 	{ "eof",	VEOF,		CEOF },
 	{ "eol",	VEOL,		CEOL },
 	{ "eol2",	VEOL2,		CEOL },
 	{ "erase",	VERASE,		CERASE },
-	{ "erase2",	VERASE2,	CERASE2 },
 	{ "intr",	VINTR,		CINTR },
 	{ "kill",	VKILL,		CKILL },
 	{ "lnext",	VLNEXT,		CLNEXT },
@@ -67,11 +68,11 @@
 	{ "quit",	VQUIT,		CQUIT },
 	{ "reprint",	VREPRINT, 	CREPRINT },
 	{ "start",	VSTART,		CSTART },
-	{ "status",	VSTATUS, 	CSTATUS },
 	{ "stop",	VSTOP,		CSTOP },
 	{ "susp",	VSUSP,		CSUSP },
 	{ "time",	VTIME,		CTIME },
 	{ "werase",	VWERASE,	CWERASE },
+	{ "swtc",	VSWTC,		CEOL },
 	{ NULL,		0,		0},
 };
 
--- src.orig/coreutils/stty/extern.h
+++ src.freebsd/coreutils/stty/extern.h
@@ -41,4 +41,7 @@
 void	print(struct termios *, struct winsize *, int, enum FMT);
 void	usage(void) __dead2;
 
+int get_baud(speed_t s);
+speed_t get_speed(unsigned long b);
+
 extern struct cchar cchars1[], cchars2[];
--- src.orig/coreutils/stty/gfmt.c
+++ src.freebsd/coreutils/stty/gfmt.c
@@ -38,7 +38,9 @@
 #include <err.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <unistd.h>
 #include <string.h>
+#include <termios.h>
 
 #include "stty.h"
 #include "extern.h"
@@ -65,7 +67,7 @@
 	for (cp = cchars1; cp->name; ++cp)
 		(void)printf("%s=%x:", cp->name, tp->c_cc[cp->sub]);
 	(void)printf("ispeed=%lu:ospeed=%lu\n",
-	    (u_long)cfgetispeed(tp), (u_long)cfgetospeed(tp));
+	    (u_long)get_baud(cfgetispeed(tp)), (u_long)get_baud(cfgetospeed(tp)));
 }
 
 void
@@ -97,7 +99,7 @@
 		}
 		if (CHK("ispeed")) {
 			tmp = strtoul(ep, NULL, 10);
-			tp->c_ispeed = tmp;
+			cfsetispeed(tp, tmp);
 			continue;
 		}
 		if (CHK("lflag")) {
@@ -110,7 +112,7 @@
 		}
 		if (CHK("ospeed")) {
 			tmp = strtoul(ep, NULL, 10);
-			tp->c_ospeed = tmp;
+			cfsetospeed(tp, tmp);
 			continue;
 		}
 		for (cp = cchars1; cp->name != NULL; ++cp)
--- src.orig/coreutils/stty/key.c
+++ src.freebsd/coreutils/stty/key.c
@@ -34,11 +34,15 @@
 #endif /* not lint */
 #include <sys/cdefs.h>
 #include <sys/types.h>
+#include <sys/ttydefaults.h>
 
 #include <err.h>
+#include <errno.h>
 #include <stdlib.h>
 #include <stdio.h>
+#include <unistd.h>
 #include <string.h>
+#include <termios.h>
 
 #include "stty.h"
 #include "extern.h"
@@ -189,14 +193,24 @@
 void
 f_extproc(struct info *ip)
 {
+	struct termios tio;
+	errno = 0;
 
+	if (tcgetattr(ip->fd, &tio) == -1) {
+		err(1, "extproc");
+		return;
+	}
+
 	if (ip->off) {
-		int tmp = 0;
-		(void)ioctl(ip->fd, TIOCEXT, &tmp);
+		tio.c_lflag &= ~EXTPROC;
 	} else {
-		int tmp = 1;
-		(void)ioctl(ip->fd, TIOCEXT, &tmp);
+		tio.c_lflag |= EXTPROC;
 	}
+
+	if (tcsetattr(ip->fd, TCSANOW, &tio) == -1) {
+		err(1, "extproc");
+		return;
+	}
 }
 
 void
@@ -256,11 +270,16 @@
 {
 	struct termios def;
 
-	cfmakesane(&def);
+	def.c_cflag = TTYDEF_CFLAG;
+	def.c_iflag = TTYDEF_IFLAG;
+	def.c_lflag = TTYDEF_LFLAG;
+	def.c_oflag = TTYDEF_OFLAG;
+	cfsetispeed(&def, TTYDEF_SPEED);
+	cfsetospeed(&def, TTYDEF_SPEED);
 	ip->t.c_cflag = def.c_cflag | (ip->t.c_cflag & CLOCAL);
 	ip->t.c_iflag = def.c_iflag;
 	/* preserve user-preference flags in lflag */
-#define	LKEEP	(ECHOKE|ECHOE|ECHOK|ECHOPRT|ECHOCTL|ALTWERASE|TOSTOP|NOFLSH)
+#define	LKEEP	(ECHOKE|ECHOE|ECHOK|ECHOPRT|ECHOCTL|VWERASE|TOSTOP|NOFLSH)
 	ip->t.c_lflag = def.c_lflag | (ip->t.c_lflag & LKEEP);
 	ip->t.c_oflag = def.c_oflag;
 	ip->set = 1;
@@ -277,7 +296,7 @@
 f_speed(struct info *ip)
 {
 
-	(void)printf("%lu\n", (u_long)cfgetospeed(&ip->t));
+	(void)printf("%lu\n", (u_long)get_baud(cfgetospeed(&ip->t)));
 }
 
 void
@@ -285,7 +304,7 @@
 {
 	int tmp;
 
-	tmp = TTYDISC;
+	tmp = N_TTY;
 	if (ioctl(ip->fd, TIOCSETD, &tmp) < 0)
 		err(1, "TIOCSETD");
 }
--- src.orig/coreutils/stty/modes.c
+++ src.freebsd/coreutils/stty/modes.c
@@ -34,7 +34,9 @@
 #endif /* not lint */
 #include <sys/cdefs.h>
 #include <sys/types.h>
+#include <unistd.h>
 #include <string.h>
+#include <termios.h>
 #include "stty.h"
 
 int msearch(char ***, struct info *);
@@ -78,18 +80,6 @@
 	{ "-clocal",	0, CLOCAL },
 	{ "crtscts",	CRTSCTS, 0 },
 	{ "-crtscts",	0, CRTSCTS },
-	{ "ctsflow",	CCTS_OFLOW, 0 },
-	{ "-ctsflow",	0, CCTS_OFLOW },
-	{ "dsrflow",	CDSR_OFLOW, 0 },
-	{ "-dsrflow",	0, CDSR_OFLOW },
-	{ "dtrflow",	CDTR_IFLOW, 0 },
-	{ "-dtrflow",	0, CDTR_IFLOW },
-	{ "rtsflow",	CRTS_IFLOW, 0 },
-	{ "-rtsflow",	0, CRTS_IFLOW },
-	{ "mdmbuf",	MDMBUF, 0 },
-	{ "-mdmbuf",	0, MDMBUF },
-	{ "rtsdtr",	0, CNO_RTSDTR },
-	{ "-rtsdtr",	CNO_RTSDTR, 0 },
 	{ NULL,		0, 0 },
 };
 
@@ -146,8 +136,8 @@
 	{ "-echoke",	0, ECHOKE },
 	{ "crtkill",	ECHOKE, 0 },
 	{ "-crtkill",	0, ECHOKE },
-	{ "altwerase",	ALTWERASE, 0 },
-	{ "-altwerase",	0, ALTWERASE },
+	{ "altwerase",	VWERASE, 0 },
+	{ "-altwerase",	0, VWERASE },
 	{ "iexten",	IEXTEN, 0 },
 	{ "-iexten",	0, IEXTEN },
 	{ "echonl",	ECHONL, 0 },
@@ -176,10 +166,6 @@
 	{ "-crt",	ECHOK, ECHOE|ECHOKE|ECHOCTL },
 	{ "newcrt",	ECHOE|ECHOKE|ECHOCTL, ECHOK|ECHOPRT },
 	{ "-newcrt",	ECHOK, ECHOE|ECHOKE|ECHOCTL },
-	{ "nokerninfo",	NOKERNINFO, 0 },
-	{ "-nokerninfo",0, NOKERNINFO },
-	{ "kerninfo",	0, NOKERNINFO },
-	{ "-kerninfo",	NOKERNINFO, 0 },
 	{ NULL,		0, 0 },
 };
 
--- src.orig/coreutils/stty/print.c
+++ src.freebsd/coreutils/stty/print.c
@@ -38,6 +38,8 @@
 #include <stddef.h>
 #include <stdio.h>
 #include <string.h>
+#include <unistd.h>
+#include <termios.h>
 
 #include "stty.h"
 #include "extern.h"
@@ -58,12 +60,12 @@
 	cnt = 0;
 
 	/* Line discipline. */
-	if (ldisc != TTYDISC) {
+	if (ldisc != N_TTY) {
 		switch(ldisc) {
-		case SLIPDISC:
+		case N_SLIP:
 			cnt += printf("slip disc; ");
 			break;
-		case PPPDISC:
+		case N_PPP:
 			cnt += printf("ppp disc; ");
 			break;
 		default:
@@ -77,9 +79,9 @@
 	ospeed = cfgetospeed(tp);
 	if (ispeed != ospeed)
 		cnt +=
-		    printf("ispeed %d baud; ospeed %d baud;", ispeed, ospeed);
+		    printf("ispeed %d baud; ospeed %d baud;", get_baud(ispeed), get_baud(ospeed));
 	else
-		cnt += printf("speed %d baud;", ispeed);
+		cnt += printf("speed %d baud;", get_baud(ispeed));
 	if (fmt >= BSD)
 		cnt += printf(" %d rows; %d columns;", wp->ws_row, wp->ws_col);
 	if (cnt)
@@ -103,12 +105,11 @@
 	put("-echonl", ECHONL, 0);
 	put("-echoctl", ECHOCTL, 0);
 	put("-echoprt", ECHOPRT, 0);
-	put("-altwerase", ALTWERASE, 0);
+	put("-altwerase", VWERASE, 0);
 	put("-noflsh", NOFLSH, 0);
 	put("-tostop", TOSTOP, 0);
 	put("-flusho", FLUSHO, 0);
 	put("-pendin", PENDIN, 0);
-	put("-nokerninfo", NOKERNINFO, 0);
 	put("-extproc", EXTPROC, 0);
 
 	/* input flags */
@@ -169,26 +170,7 @@
 	put("-hupcl", HUPCL, 1);
 	put("-clocal", CLOCAL, 0);
 	put("-cstopb", CSTOPB, 0);
-	switch(tmp & (CCTS_OFLOW | CRTS_IFLOW)) {
-	case CCTS_OFLOW:
-		bput("ctsflow");
-		break;
-	case CRTS_IFLOW:
-		bput("rtsflow");
-		break;
-	default:
-		put("-crtscts", CCTS_OFLOW | CRTS_IFLOW, 0);
-		break;
-	}
-	put("-dsrflow", CDSR_OFLOW, 0);
-	put("-dtrflow", CDTR_IFLOW, 0);
-	put("-mdmbuf", MDMBUF, 0);	/* XXX mdmbuf ==  dtrflow */
-	if (on(CNO_RTSDTR))
-		bput("-rtsdtr");
-	else {
-		if (fmt >= BSD)
-			bput("rtsdtr");
-	}
+	put("-crtscts", CRTSCTS, 0);
 
 	/* special control characters */
 	cc = tp->c_cc;
--- src.orig/coreutils/stty/stty.1
+++ src.freebsd/coreutils/stty/stty.1
@@ -355,13 +355,6 @@
 erased with simply an
 .Dv ERASE
 character.)
-.It Cm mdmbuf Pq Fl mdmbuf
-If set, flow control output based on condition of Carrier Detect.
-Otherwise
-writes return an error if Carrier Detect is low (and Carrier is not being
-ignored with the
-.Dv CLOCAL
-flag.)
 .It Cm flusho Pq Fl flusho
 Indicates output is (is not) being discarded.
 .It Cm pendin Pq Fl pendin
@@ -395,7 +388,6 @@
 .It eol Ta Tn VEOL Ta EOL No character
 .It eol2 Ta Tn VEOL2 Ta EOL2 No character
 .It erase Ta Tn VERASE Ta ERASE No character
-.It erase2 Ta Tn VERASE2 Ta ERASE2 No character
 .It werase Ta Tn VWERASE Ta WERASE No character
 .It intr Ta Tn VINTR Ta INTR No character
 .It kill Ta Tn VKILL Ta KILL No character
@@ -403,10 +395,10 @@
 .It susp Ta Tn VSUSP Ta SUSP No character
 .It start Ta Tn VSTART Ta START No character
 .It stop Ta Tn VSTOP Ta STOP No character
-.It dsusp Ta Tn VDSUSP Ta DSUSP No character
+.It dsusp Ta Tn CDSUSP Ta DSUSP No character
 .It lnext Ta Tn VLNEXT Ta LNEXT No character
 .It reprint Ta Tn VREPRINT Ta REPRINT No character
-.It status Ta Tn VSTATUS Ta STATUS No character
+.It status Ta Tn CSTATUS Ta STATUS No character
 .El
 .Ed
 .It Cm min Ar number
@@ -454,22 +446,6 @@
 .Dv TTYDISC .
 .It Cm crt Pq Fl crt
 Set (disable) all modes suitable for a CRT display device.
-.It Cm kerninfo Pq Fl kerninfo
-Enable (disable) the system generated status line associated with
-processing a
-.Dv STATUS
-character (usually set to ^T).
-The status line consists of the
-system load average, the current command name, its process ID, the
-event the process is waiting on (or the status of the process), the user
-and system times, percent cpu, and current memory usage.
-.Pp
-If the
-.Xr sysctl 8
-variable
-.Va kern.tty_info_kstacks
-is set to a non-zero value, the status message also includes the kernel program
-stack of the foreground thread.
 .It Cm columns Ar number
 The terminal size is recorded as having
 .Ar number
--- src.orig/coreutils/stty/stty.c
+++ src.freebsd/coreutils/stty/stty.c
@@ -49,6 +49,8 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <errno.h>
+#include <termios.h>
 
 #include "stty.h"
 #include "extern.h"
@@ -127,10 +129,11 @@
 
 		if (isdigit(**argv)) {
 			speed_t speed;
-
-			speed = strtonum(*argv, 0, UINT_MAX, &errstr);
+			unsigned int baud;
+			baud = (unsigned int)strtonum(*argv, 0, UINT_MAX, &errstr);
 			if (errstr)
 				err(1, "speed");
+			speed = get_speed(baud);
 			cfsetospeed(&i.t, speed);
 			cfsetispeed(&i.t, speed);
 			i.set = 1;
--- src.orig/coreutils/stty/util.c
+++ src.freebsd/coreutils/stty/util.c
@@ -38,6 +38,7 @@
 
 #include <err.h>
 #include <unistd.h>
+#include <termios.h>
 
 #include "stty.h"
 #include "extern.h"
@@ -57,4 +58,32 @@
 	    !fstat(STDOUT_FILENO, &sb1) && !fstat(STDERR_FILENO, &sb2) &&
 	    (sb1.st_rdev != sb2.st_rdev))
 warnx("stdout appears redirected, but stdin is the control descriptor");
+}
+
+static const int baudlist[] = {
+	0, 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800, 9600,
+	19200, 38400, 57600, 115200, 230400, 460800, 500000, 576000, 921600,
+	1000000, 1152000, 1500000, 2000000, 2500000, 3000000, 3500000, 4000000,
+};
+
+static const speed_t baudvals[] = {
+	B0, B50, B75, B110, B134, B150, B200, B300, B600, B1200, B1800, B2400,
+	B4800, B9600, B19200, B38400, B57600, B115200, B230400, B460800, B500000,
+	B576000, B921600, B1000000, B1152000, B1500000, B2000000, B2500000,
+	B3000000, B3500000, B4000000,
+};
+
+int get_baud(speed_t s) {
+	if (s & CBAUDEX)
+		s = (s & ~CBAUDEX) + 15;
+	return baudlist[s];
+}
+
+speed_t get_speed(unsigned long b) {
+	for (size_t i = 0; i < (sizeof(baudlist) / sizeof(int)); ++i) {
+		if ((unsigned long)baudlist[i] != b)
+			continue;
+		return baudvals[i];
+	}
+	errx(1, "unknown speed for baud %lu", b);
 }
--- src.orig/coreutils/tail/forward.c
+++ src.freebsd/coreutils/tail/forward.c
@@ -43,7 +43,6 @@
 #include <sys/stat.h>
 #include <sys/time.h>
 #include <sys/mman.h>
-#include <sys/event.h>
 
 #include <err.h>
 #include <errno.h>
@@ -61,17 +60,7 @@
 
 static void rlines(FILE *, const char *fn, off_t, struct stat *);
 static int show(file_info_t *);
-static void set_events(file_info_t *files);
 
-/* defines for inner loop actions */
-#define USE_SLEEP	0
-#define USE_KQUEUE	1
-#define ADD_EVENTS	2
-
-static struct kevent *ev;
-static int action = USE_SLEEP;
-static int kq;
-
 static const file_info_t *last;
 
 /*
@@ -262,44 +251,6 @@
 	return 1;
 }
 
-static void
-set_events(file_info_t *files)
-{
-	int i, n = 0;
-	file_info_t *file;
-	struct timespec ts;
-	struct statfs sf;
-
-	ts.tv_sec = 0;
-	ts.tv_nsec = 0;
-
-	action = USE_KQUEUE;
-	for (i = 0, file = files; i < no_files; i++, file++) {
-		if (! file->fp)
-			continue;
-
-		if (fstatfs(fileno(file->fp), &sf) == 0 &&
-		    (sf.f_flags & MNT_LOCAL) == 0) {
-			action = USE_SLEEP;
-			return;
-		}
-
-		if (Fflag && fileno(file->fp) != STDIN_FILENO) {
-			EV_SET(&ev[n], fileno(file->fp), EVFILT_VNODE,
-			    EV_ADD | EV_ENABLE | EV_CLEAR,
-			    NOTE_DELETE | NOTE_RENAME, 0, 0);
-			n++;
-		}
-		EV_SET(&ev[n], fileno(file->fp), EVFILT_READ,
-		    EV_ADD | EV_ENABLE | EV_CLEAR, 0, 0, 0);
-		n++;
-	}
-
-	if (kevent(kq, ev, n, NULL, 0, &ts) < 0) {
-		action = USE_SLEEP;
-	}
-}
-
 /*
  * follow -- display the file, from an offset, forward.
  *
@@ -307,26 +258,21 @@
 void
 follow(file_info_t *files, enum STYLE style, off_t off)
 {
-	int active, ev_change, i, n = -1;
+	int active, i;
 	struct stat sb2;
 	file_info_t *file;
 	FILE *ftmp;
-	struct timespec ts;
 
 	/* Position each of the files */
 
 	file = files;
 	active = 0;
-	n = 0;
 	for (i = 0; i < no_files; i++, file++) {
 		if (file->fp) {
 			active = 1;
-			n++;
 			if (vflag || (qflag == 0 && no_files > 1))
 				printfn(file->file_name, 1);
 			forward(file->fp, file->file_name, style, off, &file->st);
-			if (Fflag && fileno(file->fp) != STDIN_FILENO)
-				n++;
 		}
 	}
 	if (!Fflag && !active)
@@ -334,16 +280,7 @@
 
 	last = --file;
 
-	kq = kqueue();
-	if (kq < 0)
-		err(1, "kqueue");
-	ev = malloc(n * sizeof(struct kevent));
-	if (! ev)
-	    err(1, "Couldn't allocate memory for kevents.");
-	set_events(files);
-
 	for (;;) {
-		ev_change = 0;
 		if (Fflag) {
 			for (i = 0, file = files; i < no_files; i++, file++) {
 				if (!file->fp) {
@@ -356,8 +293,6 @@
 						fclose(file->fp);
 						file->fp = NULL;
 					}
-					if (file->fp != NULL)
-						ev_change++;
 					continue;
 				}
 				if (fileno(file->fp) == STDIN_FILENO)
@@ -375,7 +310,6 @@
 					if (ftmp != NULL) {
 						fclose(ftmp);
 					}
-					ev_change++;
 					continue;
 				}
 
@@ -387,7 +321,6 @@
 					file->fp = ftmp;
 					memcpy(&file->st, &sb2,
 					    sizeof(struct stat));
-					ev_change++;
 				} else {
 					fclose(ftmp);
 				}
@@ -395,44 +328,8 @@
 		}
 
 		for (i = 0, file = files; i < no_files; i++, file++)
-			if (file->fp && !show(file))
-				ev_change++;
+			if (file->fp) show(file);
 
-		if (ev_change)
-			set_events(files);
-
-		switch (action) {
-		case USE_KQUEUE:
-			ts.tv_sec = 1;
-			ts.tv_nsec = 0;
-			/*
-			 * In the -F case we set a timeout to ensure that
-			 * we re-stat the file at least once every second.
-			 * If we've recieved EINTR, ignore it. Both reasons
-			 * for its generation are transient.
-			 */
-			do {
-				n = kevent(kq, NULL, 0, ev, 1, Fflag ? &ts : NULL);
-				if (n < 0 && errno == EINTR)
-					continue;
-				if (n < 0)
-					err(1, "kevent");
-			} while (n < 0);
-			if (n == 0) {
-				/* timeout */
-				break;
-			} else if (ev->filter == EVFILT_READ && ev->data < 0) {
-				/* file shrank, reposition to end */
-				if (lseek(ev->ident, (off_t)0, SEEK_END) == -1) {
-					ierr(file->file_name);
-					continue;
-				}
-			}
-			break;
-
-		case USE_SLEEP:
-			(void) usleep(250000);
-			break;
-		}
+		(void) usleep(250000);
 	}
 }
--- src.orig/coreutils/tail/tail.c
+++ src.freebsd/coreutils/tail/tail.c
@@ -43,6 +43,7 @@
 static const char sccsid[] = "@(#)tail.c	8.1 (Berkeley) 6/6/93";
 #endif
 
+#include <sys/cdefs.h>
 #include <sys/capsicum.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -87,6 +88,7 @@
 	const char *fn;
 	FILE *fp;
 	off_t off;
+	uint64_t uoff;
 	enum STYLE style;
 	int ch, first;
 	file_info_t file, *filep, *files;
@@ -107,10 +109,11 @@
 #define	ARG(units, forward, backward) {					\
 	if (style)							\
 		usage();						\
-	if (expand_number(optarg, &off))				\
+	if (expand_number(optarg, &uoff))				\
 		err(1, "illegal offset -- %s", optarg);			\
-	if (off > INT64_MAX / units || off < INT64_MIN / units )	\
+	if (uoff > INT64_MAX / units )	\
 		errx(1, "illegal offset -- %s", optarg);		\
+	off = uoff; \
 	switch(optarg[0]) {						\
 	case '+':							\
 		if (off)						\
--- src.orig/coreutils/tee/tee.c
+++ src.freebsd/coreutils/tee/tee.c
@@ -43,6 +43,7 @@
   "$FreeBSD$";
 #endif /* not lint */
 
+#include <sys/cdefs.h>
 #include <sys/capsicum.h>
 #include <sys/queue.h>
 #include <sys/stat.h>
--- src.orig/coreutils/timeout/timeout.c
+++ src.freebsd/coreutils/timeout/timeout.c
@@ -26,10 +26,11 @@
  */
 
 #include <sys/cdefs.h>
-#include <sys/procctl.h>
+#include <sys/prctl.h>
 #include <sys/time.h>
 #include <sys/wait.h>
 
+#include <sysexits.h>
 #include <err.h>
 #include <errno.h>
 #include <getopt.h>
@@ -101,16 +102,19 @@
 {
 	int sig, i;
 	const char *errstr;
+	const char *signame;
 
-	sig = strtonum(str, 1, sys_nsig - 1, &errstr);
+	sig = strtonum(str, 1, NSIG, &errstr);
 
 	if (errstr == NULL)
 		return (sig);
+
 	if (strncasecmp(str, "SIG", 3) == 0)
 		str += 3;
 
-	for (i = 1; i < sys_nsig; i++) {
-		if (strcasecmp(str, sys_signame[i]) == 0)
+	for (i = 1; i < NSIG; i++) {
+		signame = signum_to_signame(i);
+		if (signame && strcasecmp(str, signame) == 0)
 			return (i);
 	}
 
@@ -171,8 +175,7 @@
 	bool do_second_kill = false;
 	bool child_done = false;
 	struct sigaction signals;
-	struct procctl_reaper_status info;
-	struct procctl_reaper_kill killemall;
+	unsigned long info;
 	int signums[] = {
 		-1,
 		SIGTERM,
@@ -225,8 +228,8 @@
 
 	if (!foreground) {
 		/* Acquire a reaper */
-		if (procctl(P_PID, getpid(), PROC_REAP_ACQUIRE, NULL) == -1)
-			err(EXIT_FAILURE, "Fail to acquire the reaper");
+		if (prctl(PR_SET_CHILD_SUBREAPER, 1, 0, 0) == -1)
+			err(EX_OSERR, "Fail to set the reaper");
 	}
 
 	memset(&signals, 0, sizeof(signals));
@@ -294,9 +297,8 @@
 				if (foreground) {
 					break;
 				} else {
-					procctl(P_PID, getpid(),
-					    PROC_REAP_STATUS, &info);
-					if (info.rs_children == 0)
+					prctl(PR_GET_CHILD_SUBREAPER, &info, 0, 0);
+					if (info == 0)
 						break;
 				}
 			}
@@ -305,10 +307,8 @@
 
 			timedout = true;
 			if (!foreground) {
-				killemall.rk_sig = killsig;
-				killemall.rk_flags = 0;
-				procctl(P_PID, getpid(), PROC_REAP_KILL,
-				    &killemall);
+				if (kill(getpid(), SIGKILL) == -1)
+					err(EXIT_FAILURE, "kill");
 			} else
 				kill(pid, killsig);
 
@@ -322,10 +322,8 @@
 
 		} else if (sig_term) {
 			if (!foreground) {
-				killemall.rk_sig = sig_term;
-				killemall.rk_flags = 0;
-				procctl(P_PID, getpid(), PROC_REAP_KILL,
-				    &killemall);
+				if (kill(getpid(), SIGTERM) == -1)
+					err(EXIT_FAILURE, "kill");
 			} else
 				kill(pid, sig_term);
 
@@ -345,7 +343,7 @@
 	}
 
 	if (!foreground)
-		procctl(P_PID, getpid(), PROC_REAP_RELEASE, NULL);
+		prctl(PR_SET_CHILD_SUBREAPER, 0, 0, 0);
 
 	if (WEXITSTATUS(pstat))
 		pstat = WEXITSTATUS(pstat);
--- src.orig/coreutils/touch/touch.c
+++ src.freebsd/coreutils/touch/touch.c
@@ -52,7 +52,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <time.h>
+#include <time_bsd.h>
 #include <unistd.h>
 
 static void	stime_arg1(const char *, struct timespec *);
@@ -330,7 +330,7 @@
 		goto bad;
 	fmt = strchr(arg, 'T') != NULL ? "%Y-%m-%dT%H:%M:%S" :
 	    "%Y-%m-%d %H:%M:%S";
-	p = strptime(arg, fmt, &t);
+	p = strptime_bsd(arg, fmt, &t);
 	if (p == NULL)
 		goto bad;
 	/* POSIX: must have at least one digit after dot */
--- src.orig/coreutils/tr/cmap.h
+++ src.freebsd/coreutils/tr/cmap.h
@@ -45,7 +45,7 @@
 	wint_t		cm_cache[CM_CACHE_SIZE];
 	bool		cm_havecache;
 	struct cmapnode	*cm_root;
-#define	CM_DEF_SELF	-2
+#define	CM_DEF_SELF	(wint_t)(-2)
 	wint_t		cm_def;
 	wint_t		cm_min;
 	wint_t		cm_max;
--- src.orig/coreutils/tr/extern.h
+++ src.freebsd/coreutils/tr/extern.h
@@ -34,7 +34,7 @@
 #include <limits.h>
 
 #define	NCHARS_SB	(UCHAR_MAX + 1)	/* Number of single-byte characters. */
-#define	OOBCH		-1		/* Out of band character value. */
+#define	OOBCH		(wint_t)(-1)		/* Out of band character value. */
 
 typedef struct {
 	enum { STRING1, STRING2 } which;
@@ -50,3 +50,5 @@
 
 wint_t	 next(STR *);
 int charcoll(const void *, const void *);
+
+#define iswrune(v) (iswprint(v) || iswcntrl(v))
--- src.orig/coreutils/tr/str.c
+++ src.freebsd/coreutils/tr/str.c
@@ -55,6 +55,44 @@
 static int      genrange(STR *, int);
 static void	genseq(STR *);
 
+static wint_t
+findwchar(wctype_t wct, wchar_t min, wchar_t max)
+{
+	for (; min <= max; ++min) {
+		if (iswctype(min, wct))
+			return min;
+	}
+	return (wint_t)-1;
+}
+
+/* we cannot reasonably implement this for wide characters/unicode, since
+ * the standard posix api has no way to find out the actual ranges, and
+ * doing binary search on the entire wchar range is inefficient (especially
+ * considering the character range does not have to be contiguous, which
+ * means doing a new search after we get to the end of the current part
+ * of the range)
+ *
+ * therefore, stick with what is representable in the C locale and do a
+ * simple linear search instead, this should always get us reliable results
+ */
+
+static wint_t
+nextwctype(wint_t ch, wctype_t wct)
+{
+	if (ch == (wint_t)-1) {
+		/* locate first character in the class */
+		return findwchar(wct, 0, UCHAR_MAX);
+	}
+
+	if ((ch == (wint_t)-1) || (ch >= UCHAR_MAX))
+		return (wint_t)-1;
+
+	if (!iswctype(++ch, wct))
+		return findwchar(wct, ch, UCHAR_MAX);
+
+	return ch;
+}
+
 wint_t
 next(STR *s)
 {
@@ -113,7 +151,7 @@
 	case CCLASS_LOWER:
 		s->cnt++;
 		ch = nextwctype(s->lastch, s->cclass);
-		if (ch == -1) {
+		if (ch == (wint_t)-1) {
 			s->state = NORMAL;
 			return (next(s));
 		}
@@ -238,9 +276,10 @@
 static int
 genrange(STR *s, int was_octal)
 {
-	int stopval, octal;
+	wint_t stopval;
+	int octal;
 	char *savestart;
-	int n, cnt, *p;
+	wint_t n, cnt, *p;
 	size_t clen;
 	wchar_t wc;
 
--- src.orig/coreutils/tr/tr.c
+++ src.freebsd/coreutils/tr/tr.c
@@ -40,6 +40,7 @@
 static const char sccsid[] = "@(#)tr.c	8.2 (Berkeley) 5/4/95";
 #endif
 
+#include <sys/cdefs.h>
 #include <sys/types.h>
 #include <sys/capsicum.h>
 
@@ -75,6 +76,7 @@
 	int n, *p;
 	int Cflag, cflag, dflag, sflag, isstring2;
 	wint_t ch, cnt, lastch;
+	int optc;
 
 	(void)setlocale(LC_ALL, "");
 
@@ -85,8 +87,8 @@
 		err(1, "unable to enter capability mode");
 
 	Cflag = cflag = dflag = sflag = 0;
-	while ((ch = getopt(argc, argv, "Ccdsu")) != -1)
-		switch((char)ch) {
+	while ((optc = getopt(argc, argv, "Ccdsu")) != -1)
+		switch(optc) {
 		case 'C':
 			Cflag = 1;
 			cflag = 0;
@@ -116,6 +118,7 @@
 	default:
 		usage();
 		/* NOTREACHED */
+		return 1;
 	case 1:
 		isstring2 = 0;
 		break;
@@ -304,7 +307,7 @@
 
 		s2.str = argv[1];
 		s2.state = NORMAL;
-		for (cnt = 0; cnt < n; cnt++) {
+		for (cnt = 0; cnt < (wint_t)n; cnt++) {
 			(void)next(&s2);
 			cmap_add(map, carray[cnt], s2.lastch);
 			/*
--- src.orig/coreutils/truncate/truncate.1
+++ src.freebsd/coreutils/truncate/truncate.1
@@ -225,7 +225,7 @@
 .Sh SEE ALSO
 .Xr dd 1 ,
 .Xr touch 1 ,
-.Xr fspacectl 2 ,
+.Xr fallocate 2 ,
 .Xr truncate 2
 .Sh STANDARDS
 The
--- src.orig/coreutils/truncate/truncate.c
+++ src.freebsd/coreutils/truncate/truncate.c
@@ -32,8 +32,10 @@
  *
  */
 
+#if 0
 static const char rcsid[] =
     "$FreeBSD$";
+#endif
 
 #include <sys/stat.h>
 
@@ -44,6 +46,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
+#include <stdint.h>
 
 #include <libutil.h>
 
@@ -65,7 +68,6 @@
 	int do_refer;
 	int got_size;
 	char *fname, *rname;
-	struct spacectl_range sr;
 
 	fd = -1;
 	rsize = tsize = sz = off = 0;
@@ -201,9 +203,7 @@
 			tsize = 0;
 
 		if (do_dealloc == 1) {
-			sr.r_offset = off;
-			sr.r_len = len;
-			r = fspacectl(fd, SPACECTL_DEALLOC, &sr, 0, &sr);
+			r = fallocate(fd, FALLOC_FL_PUNCH_HOLE, off, len);
 		}
 		if (do_truncate == 1)
 			r = ftruncate(fd, tsize);
--- src.orig/coreutils/tsort/tsort.c
+++ src.freebsd/coreutils/tsort/tsort.c
@@ -46,7 +46,6 @@
 #include <sys/types.h>
 
 #include <ctype.h>
-#include <db.h>
 #include <err.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -96,7 +95,83 @@
 	int b_bsize;
 } BUF;
 
-static DB *db;
+#define HASH_CHUNK_SIZE 64
+#define HASH_BUCKET_COUNT 1024
+
+struct hash_elem {
+	NODE *elem;
+	struct hash_elem *next;
+};
+
+struct hash_chunk {
+	struct hash_elem elems[HASH_CHUNK_SIZE];
+	struct hash_chunk *next;
+};
+
+struct hash {
+	struct hash_elem **elems;
+	struct hash_chunk *chunks;
+	struct hash_elem *top;
+};
+
+static void hash_init(struct hash *h) {
+	h->chunks = NULL;
+	h->top = NULL;
+	h->elems = calloc(1024, sizeof(struct hash_elem *));
+}
+
+static void hash_destroy(struct hash *h) {
+	for (size_t i = 0; i < HASH_BUCKET_COUNT; ++i) {
+		struct hash_elem *e = h->elems[i];
+		while (e) {
+			free(e->elem->n_arcs);
+			free(e->elem);
+			e = e->next;
+		}
+	}
+	free(h->elems);
+	while (h->chunks) {
+		struct hash_chunk *c = h->chunks;
+		h->chunks = h->chunks->next;
+		free(c);
+	}
+}
+
+static size_t hash_key(char *key) {
+	size_t h = 5381;
+	for (size_t i = 0, k; (k = key[i]); ++i)
+		h = ((h << 5) + h) ^ k;
+	return h;
+}
+
+static NODE *hash_find(struct hash *h, char *key) {
+	size_t hash = hash_key(key) & (HASH_BUCKET_COUNT - 1);
+	for (struct hash_elem *c = h->elems[hash]; c; c = c->next) {
+		if (!strcmp(key, c->elem->n_name))
+			return c->elem;
+	}
+	return NULL;
+}
+
+static struct hash_elem *hash_insert(struct hash *h, char *key) {
+	size_t hash = hash_key(key) & (HASH_BUCKET_COUNT - 1);
+	if (!h->top) {
+		struct hash_chunk *c = calloc(1, sizeof(struct hash_chunk));
+		c->next = h->chunks;
+		h->chunks = c;
+		for (size_t i = 0; i < (HASH_CHUNK_SIZE - 1); ++i) 
+			c->elems[i].next = &c->elems[i + 1];
+		c->elems[HASH_CHUNK_SIZE - 1].next = h->top;
+		h->top = c->elems;
+	}
+	struct hash_elem *hc = h->top;
+	h->top = h->top->next;
+	hc->next = h->elems[hash];
+	h->elems[hash] = hc;
+	return hc;
+}
+
+static struct hash db;
 static NODE *graph, **cycle_buf, **longest_cycle;
 static int debug, longest, quiet;
 
@@ -152,6 +227,8 @@
 	for (b = bufs, n = 2; --n >= 0; b++)
 		b->b_buf = grow_buf(NULL, b->b_bsize = 1024);
 
+	hash_init(&db);
+
 	/* parse input and build the graph */
 	for (n = 0, c = getc(fp);;) {
 		while (c != EOF && isspace(c))
@@ -181,6 +258,7 @@
 
 	/* do the sort */
 	tsort();
+	hash_destroy(&db);
 	if (ferror(stdout) != 0 || fflush(stdout) != 0)
 		err(1, "stdout");
 	exit(0);
@@ -237,28 +315,15 @@
 static NODE *
 get_node(char *name)
 {
-	DBT data, key;
-	NODE *n;
+	NODE *n = hash_find(&db, name);
+	size_t nlen;
 
-	if (db == NULL &&
-	    (db = dbopen(NULL, O_RDWR, 0, DB_HASH, NULL)) == NULL)
-		err(1, "db: %s", name);
+	if (n)
+		return n;
 
-	key.data = name;
-	key.size = strlen(name) + 1;
+	nlen = strlen(name) + 1;
 
-	switch ((*db->get)(db, &key, &data, 0)) {
-	case 0:
-		memcpy(&n, data.data, sizeof(n));
-		return (n);
-	case 1:
-		break;
-	default:
-	case -1:
-		err(1, "db: %s", name);
-	}
-
-	if ((n = malloc(sizeof(NODE) + key.size)) == NULL)
+	if ((n = malloc(sizeof(NODE) + nlen)) == NULL)
 		err(1, NULL);
 
 	n->n_narcs = 0;
@@ -266,7 +331,7 @@
 	n->n_arcs = NULL;
 	n->n_refcnt = 0;
 	n->n_flags = 0;
-	memcpy(n->n_name, name, key.size);
+	memcpy(n->n_name, name, nlen);
 
 	/* Add to linked list. */
 	if ((n->n_next = graph) != NULL)
@@ -275,10 +340,7 @@
 	graph = n;
 
 	/* Add to hash table. */
-	data.data = &n;
-	data.size = sizeof(n);
-	if ((*db->put)(db, &key, &data, 0))
-		err(1, "db: %s", name);
+	hash_insert(&db, name)->elem = n;
 	return (n);
 }
 
--- src.orig/coreutils/uname/uname.1
+++ src.freebsd/coreutils/uname/uname.1
@@ -83,8 +83,6 @@
 .It Fl r
 Write the current release level of the kernel
 to standard output.
-.Xr freebsd-version 1
-can be used to print the release level of the userland.
 .It Fl s
 Write the name of the operating system implementation to standard output.
 .It Fl U
@@ -133,13 +131,12 @@
 e.g., on 64-bit PowerPC,
 .Fl m
 would return
-.Va powerpc
+.Va ppc64
 and
 .Fl p
 would return
-.Va powerpc64 .
+.Va unknown .
 .Sh SEE ALSO
-.Xr freebsd-version 1 ,
 .Xr feature_present 3 ,
 .Xr getosreldate 3 ,
 .Xr sysctl 3 ,
--- src.orig/coreutils/uname/uname.c
+++ src.freebsd/coreutils/uname/uname.c
@@ -45,16 +45,16 @@
 static const char sccsid[] = "@(#)uname.c	8.2 (Berkeley) 5/4/95";
 #endif
 
+#include <sys/cdefs.h>
 #include <sys/param.h>
-#include <sys/sysctl.h>
+#include <sys/utsname.h>
+#include <sys/types.h>
 
 #include <err.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
 
-#include <osreldate.h>
-
 #define	MFLAG	0x01
 #define	NFLAG	0x02
 #define	PFLAG	0x04
@@ -202,94 +202,38 @@
 	printf("\n");
 }
 
-#define	NATIVE_SYSCTL2_GET(var,mib0,mib1)	\
-static void					\
-native_##var(void)				\
-{						\
-	int mib[] = { (mib0), (mib1) };		\
-	size_t len;				\
-	static char buf[1024];			\
-	char **varp = &(var);			\
-						\
-	len = sizeof buf;			\
-	if (sysctl(mib, sizeof mib / sizeof mib[0],	\
-	   &buf, &len, NULL, 0) == -1)		\
-		err(1, "sysctl");
-
-#define	NATIVE_SYSCTLNAME_GET(var,name)		\
-static void					\
-native_##var(void)				\
-{						\
-	size_t len;				\
-	static char buf[1024];			\
-	char **varp = &(var);			\
-						\
-	len = sizeof buf;			\
-	if (sysctlbyname(name, &buf, &len, NULL,\
-	    0) == -1)				\
-		err(1, "sysctlbyname");
-
-#define	NATIVE_SET				\
-	*varp = buf;				\
-	return;					\
-}	struct __hack
-
-#define	NATIVE_BUFFER	(buf)
-#define	NATIVE_LENGTH	(len)
-
-NATIVE_SYSCTL2_GET(sysname, CTL_KERN, KERN_OSTYPE) {
-} NATIVE_SET;
-
-NATIVE_SYSCTL2_GET(hostname, CTL_KERN, KERN_HOSTNAME) {
-} NATIVE_SET;
-
-NATIVE_SYSCTL2_GET(release, CTL_KERN, KERN_OSRELEASE) {
-} NATIVE_SET;
-
-NATIVE_SYSCTL2_GET(version, CTL_KERN, KERN_VERSION) {
-	size_t n;
-	char *p;
-
-	p = NATIVE_BUFFER;
-	n = NATIVE_LENGTH;
-	for (; n--; ++p)
-		if (*p == '\n' || *p == '\t') {
-			if (n > 1)
-				*p = ' ';
-			else
-				*p = '\0';
-		}
-} NATIVE_SET;
-
-NATIVE_SYSCTL2_GET(platform, CTL_HW, HW_MACHINE) {
-} NATIVE_SET;
-
-NATIVE_SYSCTL2_GET(arch, CTL_HW, HW_MACHINE_ARCH) {
-} NATIVE_SET;
-
-NATIVE_SYSCTLNAME_GET(ident, "kern.ident") {
-} NATIVE_SET;
-
-NATIVE_SYSCTLNAME_GET(buildid, "kern.build_id") {
-} NATIVE_SET;
-
-static void
-native_uservers(void)
-{
-	static char buf[128];
-
-	snprintf(buf, sizeof(buf), "%d", __FreeBSD_version);
-	uservers = buf;
+#define NATIVE_UNAME_GET(var,field) \
+static void \
+native_##var(void) \
+{ \
+	static char buf[1024]; \
+	struct utsname u; \
+ \
+	if (uname(&u) != 0) \
+		err(1, "uname"); \
+\
+	snprintf(buf, sizeof(buf), "%s", u.field); \
+	var = buf; \
 }
 
-static void
-native_kernvers(void)
-{
-	static char buf[128];
+NATIVE_UNAME_GET(sysname, sysname)
+NATIVE_UNAME_GET(hostname, nodename)
+NATIVE_UNAME_GET(release, release)
+NATIVE_UNAME_GET(version, version)
+NATIVE_UNAME_GET(platform, machine)
 
-	snprintf(buf, sizeof(buf), "%d", getosreldate());
-	kernvers = buf;
+#define UNKNOWN_GET(var) \
+static void \
+native_##var(void) \
+{ \
+	var = "unknown"; \
 }
+
+UNKNOWN_GET(arch)
+UNKNOWN_GET(ident)
+UNKNOWN_GET(buildid)
+UNKNOWN_GET(uservers)
+UNKNOWN_GET(kernvers)
 
 static void
 usage(void)
--- src.orig/coreutils/unexpand/unexpand.c
+++ src.freebsd/coreutils/unexpand/unexpand.c
@@ -40,6 +40,8 @@
 static const char sccsid[] = "@(#)unexpand.c	8.1 (Berkeley) 6/6/93";
 #endif
 
+#include <sys/cdefs.h>
+
 /*
  * unexpand - put tabs into a file replacing blanks
  */
--- src.orig/coreutils/uniq/uniq.c
+++ src.freebsd/coreutils/uniq/uniq.c
@@ -174,7 +174,7 @@
 	if (cap_rights_is_set(&rights, CAP_IOCTL)) {
 		unsigned long cmd;
 
-		cmd = TIOCGETA; /* required by isatty(3) in printf(3) */
+		cmd = 0; /* required by isatty(3) in printf(3) */
 
 		if (caph_ioctls_limit(fileno(ofp), &cmd, 1) < 0) {
 			err(1, "unable to limit ioctls for %s",
--- src.orig/coreutils/wc/wc.1
+++ src.freebsd/coreutils/wc/wc.1
@@ -129,7 +129,7 @@
 If
 .Nm
 receives a
-.Dv SIGINFO
+.Dv SIGUSR1
 (see the
 .Cm status
 argument for
--- src.orig/coreutils/wc/wc.c
+++ src.freebsd/coreutils/wc/wc.c
@@ -45,12 +45,14 @@
 #include <sys/capsicum.h>
 #include <sys/param.h>
 #include <sys/stat.h>
+#include <sys/types.h>
 
 #include <capsicum_helpers.h>
 #include <ctype.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <locale.h>
+#include <signal.h>
 #include <stdbool.h>
 #include <stdint.h>
 #include <stdio.h>
@@ -308,7 +310,7 @@
 			if (!domulti || MB_CUR_MAX == 1) {
 				clen = 1;
 				wch = (unsigned char)*p;
-			} else if ((clen = mbrtowc(&wch, p, len, &mbs)) == 0) {
+			} else if ((clen = mbrtowc(&wch, (char *)p, len, &mbs)) == 0) {
 				clen = 1;
 			} else if (clen == (size_t)-1) {
 				if (!warned) {
--- src.orig/coreutils/who/who.c
+++ src.freebsd/coreutils/who/who.c
@@ -42,8 +42,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <time.h>
-#include <timeconv.h>
+#include <time_bsd.h>
 #include <unistd.h>
 #include <utmpx.h>
 
@@ -116,7 +115,7 @@
 		usage();
 
 	if (*argv != NULL) {
-		if (setutxdb(UTXDB_ACTIVE, *argv) != 0)
+		if (utmpxname(*argv) == 0)
 			err(1, "%s", *argv);
 	}
 
@@ -169,8 +168,10 @@
 	struct tm *tm;
 	char state;
 
-	if (d_first < 0)
-		d_first = (*nl_langinfo(D_MD_ORDER) == 'd');
+	if (d_first < 0) {
+		char *s = nl_langinfo(D_FMT);
+		d_first = (strchr(s, 'd') < strchr(s, 'm'));
+	}
 
 	state = '?';
 	idle = 0;
@@ -192,7 +193,7 @@
 		printf("%-12s ", ut->ut_line);
 	t = ut->ut_tv.tv_sec;
 	tm = localtime(&t);
-	strftime(buf, sizeof(buf), d_first ? "%e %b %R" : "%b %e %R", tm);
+	strftime_bsd(buf, sizeof(buf), d_first ? "%e %b %R" : "%b %e %R", tm);
 	printf("%-*s ", 12, buf);
 	if (uflag) {
 		if (idle < 60)
@@ -289,7 +290,7 @@
 	else
 		name = "?";
 	strlcpy(ut.ut_user, name, sizeof ut.ut_user);
-	gettimeofday(&ut.ut_tv, NULL);
+	gettimeofday((struct timeval *)&ut.ut_tv, NULL);
 	row(&ut);
 }
 
--- src.orig/coreutils/xinstall/install.1
+++ src.freebsd/coreutils/xinstall/install.1
@@ -38,7 +38,6 @@
 .Op Fl bCcpSsUv
 .Op Fl B Ar suffix
 .Op Fl D Ar destdir
-.Op Fl f Ar flags
 .Op Fl g Ar group
 .Op Fl h Ar hash
 .Op Fl l Ar linkflags
@@ -52,7 +51,6 @@
 .Op Fl bCcpSsUv
 .Op Fl B Ar suffix
 .Op Fl D Ar destdir
-.Op Fl f Ar flags
 .Op Fl g Ar group
 .Op Fl h Ar hash
 .Op Fl l Ar linkflags
@@ -115,7 +113,7 @@
 Copy the file.
 If the target file already exists and the files are the same,
 then do not change the modification time of the target.
-If the target's file flags and mode need not to be changed,
+If the target's mode needs not to be changed,
 the target's inode change time is also unchanged.
 .It Fl c
 Copy the file.
@@ -137,10 +135,6 @@
 .It Fl d
 Create directories.
 Missing parent directories are created as required.
-.It Fl f Ar flags
-Specify the target's file flags; see
-.Xr chflags 1
-for a list of possible flags and their meanings.
 .It Fl g Ar group
 Specify a group.
 A numeric GID is allowed.
@@ -197,7 +191,7 @@
 .Dq full path
 specification line.
 The metadata includes: the file name and file type, and depending upon
-other options, the owner, group, file flags, modification time, and tags.
+other options, the owner, group, modification time, and tags.
 .It Fl m Ar mode
 Specify an alternate mode.
 The default mode is set to rwxr-xr-x (0755).
@@ -255,7 +249,7 @@
 .Fl M Ar metalog .
 .It Fl U
 Indicate that install is running unprivileged, and that it should not
-try to change the owner, the group, or the file flags of the destination.
+try to change the owner or the group of the destination.
 The information that would have been updated can be stored in a log
 file with
 .Fl M Ar metalog .
@@ -266,12 +260,6 @@
 showing files as they are installed or backed up.
 .El
 .Pp
-By default,
-.Nm
-preserves all file flags, with the exception of the
-.Dq nodump
-flag.
-.Pp
 The
 .Nm
 utility attempts to prevent moving a file onto itself.
@@ -327,7 +315,6 @@
 The default was changed to copy in
 .Fx 4.4 .
 .Sh SEE ALSO
-.Xr chflags 1 ,
 .Xr chgrp 1 ,
 .Xr chmod 1 ,
 .Xr cp 1 ,
@@ -356,15 +343,6 @@
 Temporary files may be left in the target directory if
 .Nm
 exits abnormally.
-.Pp
-File flags cannot be set by
-.Xr fchflags 2
-over a NFS file system.
-Other file systems do not have a concept of flags.
-The
-.Nm
-utility will only warn when flags could not be set on a file system
-that does not support them.
 .Pp
 The
 .Nm
--- src.orig/coreutils/xinstall/xinstall.c
+++ src.freebsd/coreutils/xinstall/xinstall.c
@@ -75,8 +75,6 @@
 #include <unistd.h>
 #include <vis.h>
 
-#include "mtree.h"
-
 /*
  * Memory strategy threshold, in pages: if physmem is larger then this, use a
  * large buffer.
@@ -190,7 +188,7 @@
 	fset = 0;
 	iflags = 0;
 	group = owner = NULL;
-	while ((ch = getopt(argc, argv, "B:bCcD:df:g:h:l:M:m:N:o:pSsT:Uv")) !=
+	while ((ch = getopt(argc, argv, "B:bCcD:dg:h:l:M:m:o:pSsT:Uv")) !=
 	     -1)
 		switch((char)ch) {
 		case 'B':
@@ -211,10 +209,12 @@
 		case 'd':
 			dodir = 1;
 			break;
+#if 0
 		case 'f':
 			haveopt_f = 1;
 			fflags = optarg;
 			break;
+#endif
 		case 'g':
 			haveopt_g = 1;
 			group = optarg;
@@ -261,11 +261,13 @@
 			mode = getmode(set, 0);
 			free(set);
 			break;
+#if 0
 		case 'N':
 			if (!setup_getid(optarg))
 				err(EX_OSERR, "Unable to use user and group "
 				    "databases in `%s'", optarg);
 			break;
+#endif
 		case 'o':
 			haveopt_o = 1;
 			owner = optarg;
@@ -339,30 +341,38 @@
 
 	/* get group and owner id's */
 	if (group != NULL && !dounpriv) {
-		if (gid_from_group(group, &gid) == -1) {
+		struct group *gr = getgrnam(group);
+		if (!gr) {
 			id_t id;
 			if (!parseid(group, &id))
 				errx(1, "unknown group %s", group);
 			gid = id;
+		} else {
+			gid = gr->gr_gid;
 		}
 	} else
 		gid = (gid_t)-1;
 
 	if (owner != NULL && !dounpriv) {
-		if (uid_from_user(owner, &uid) == -1) {
+		struct passwd *pw = getpwnam(owner);
+		if (!pw) {
 			id_t id;
 			if (!parseid(owner, &id))
 				errx(1, "unknown user %s", owner);
 			uid = id;
+		} else {
+			uid = pw->pw_uid;
 		}
 	} else
 		uid = (uid_t)-1;
 
+#if 0
 	if (fflags != NULL && !dounpriv) {
 		if (strtofflags(&fflags, &fset, NULL))
 			errx(EX_USAGE, "%s: invalid flag", fflags);
 		iflags |= SETFLAGS;
 	}
+#endif
 
 	if (metafile != NULL) {
 		if ((metafp = fopen(metafile, "a")) == NULL)
@@ -413,8 +423,7 @@
 		if (stat(*argv, &from_sb))
 			err(EX_OSERR, "%s", *argv);
 		if (!S_ISREG(to_sb.st_mode)) {
-			errno = EFTYPE;
-			err(EX_OSERR, "%s", to_name);
+			errx(EX_OSERR, "%s: not a regular file", to_name);
 		}
 		if (to_sb.st_dev == from_sb.st_dev &&
 		    to_sb.st_ino == from_sb.st_ino)
@@ -574,7 +583,7 @@
 do_link(const char *from_name, const char *to_name,
     const struct stat *target_sb)
 {
-	char tmpl[MAXPATHLEN];
+	char tmpl[MAXPATHLEN + 12];
 	int ret;
 
 	if (safecopy && target_sb != NULL) {
@@ -759,7 +768,6 @@
 				errx(1, "resolved pathname too long");
 		}
 		strcpy(to_name_copy, to_name);
-		cp = basename(to_name_copy);
 		if (strlcat(dst, cp, sizeof(dst)) > sizeof(dst))
 			errx(1, "resolved pathname too long");
 		free(to_name_copy);
@@ -808,7 +816,7 @@
  *	build a path name and install the file
  */
 static void
-install(const char *from_name, const char *to_name, u_long fset, u_int flags)
+install(const char *from_name, const char *to_name, u_long fset __unused, u_int flags)
 {
 	struct stat from_sb, temp_sb, to_sb;
 	struct timespec tsb[2];
@@ -828,8 +836,7 @@
 			if (stat(from_name, &from_sb))
 				err(EX_OSERR, "%s", from_name);
 			if (!S_ISREG(from_sb.st_mode)) {
-				errno = EFTYPE;
-				err(EX_OSERR, "%s", from_name);
+				errx(EX_OSERR, "%s: not a regular file", from_name);
 			}
 		}
 		/* Build the target path. */
@@ -863,8 +870,7 @@
 	}
 
 	if (target && !S_ISREG(to_sb.st_mode) && !S_ISLNK(to_sb.st_mode)) {
-		errno = EFTYPE;
-		warn("%s", to_name);
+		warnx("%s: not a regular file or a symlink", to_name);
 		return;
 	}
 
@@ -1195,13 +1201,13 @@
 			lseek(to_fd, 0, SEEK_SET);
 		}
 	} else
-		rv = 1;	/* don't bother in this case */
+		return 1;	/* don't bother in this case */
 
 	if (do_digest) {
 		if (rv == 0)
 			*dresp = digest_end(&ctx, NULL);
 		else
-			(void)digest_end(&ctx, NULL);
+			free(digest_end(&ctx, NULL));
 	}
 
 	return rv;
@@ -1232,7 +1238,7 @@
  *	create a new file, overwriting an existing one if necessary
  */
 static int
-create_newfile(const char *path, int target, struct stat *sbp)
+create_newfile(const char *path, int target, struct stat *sbp __unused)
 {
 	char backup[MAXPATHLEN];
 	int saved_errno = 0;
@@ -1447,7 +1453,7 @@
 	    __DECONST(char **, args), environ);
 	if (error != 0) {
 		(void)unlink(to_name);
-		errc(error == EAGAIN || error == EPROCLIM || error == ENOMEM ?
+		errc(error == EAGAIN || error == ENOMEM ?
 		    EX_TEMPFAIL : EX_OSERR, error, "spawn %s", stripbin);
 	}
 	free(prefixed_from_name);
--- src.orig/dbcompat/btree/bt_close.c
+++ src.freebsd/dbcompat/btree/bt_close.c
@@ -36,7 +36,6 @@
 static char sccsid[] = "@(#)bt_close.c	8.7 (Berkeley) 8/17/94";
 #endif /* LIBC_SCCS and not lint */
 #include <sys/cdefs.h>
-#include "namespace.h"
 #include <sys/param.h>
 
 #include <errno.h>
@@ -44,7 +43,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
-#include "un-namespace.h"
 
 #include <db.h>
 #include "btree.h"
@@ -102,7 +100,7 @@
 	fd = t->bt_fd;
 	free(t);
 	free(dbp);
-	return (_close(fd) ? RET_ERROR : RET_SUCCESS);
+	return (close(fd) ? RET_ERROR : RET_SUCCESS);
 }
 
 /*
--- src.orig/dbcompat/btree/bt_delete.c
+++ src.freebsd/dbcompat/btree/bt_delete.c
@@ -142,7 +142,7 @@
 	EPG *e;
 	EPGNO *parent;
 	PAGE *h;
-	indx_t idx;
+	indx_t idx = 0;
 	pgno_t pgno;
 	recno_t nextpg, prevpg;
 	int exact, level;
--- src.orig/dbcompat/btree/bt_open.c
+++ src.freebsd/dbcompat/btree/bt_open.c
@@ -44,7 +44,6 @@
  * is wholly independent of the Postgres code.
  */
 
-#include "namespace.h"
 #include <sys/param.h>
 #include <sys/stat.h>
 
@@ -56,8 +55,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
-#include "un-namespace.h"
-#include "libc_private.h"
 
 #include <db.h>
 #include "btree.h"
@@ -197,7 +194,7 @@
 			goto einval;
 		}
 
-		if ((t->bt_fd = _open(fname, flags | O_CLOEXEC, mode)) < 0)
+		if ((t->bt_fd = open(fname, flags | O_CLOEXEC, mode)) < 0)
 			goto err;
 
 	} else {
@@ -208,10 +205,10 @@
 		F_SET(t, B_INMEM);
 	}
 
-	if (_fstat(t->bt_fd, &sb))
+	if (fstat(t->bt_fd, &sb))
 		goto err;
 	if (sb.st_size) {
-		if ((nr = _read(t->bt_fd, &m, sizeof(BTMETA))) < 0)
+		if ((nr = read(t->bt_fd, &m, sizeof(BTMETA))) < 0)
 			goto err;
 		if (nr != sizeof(BTMETA))
 			goto eftype;
@@ -320,7 +317,7 @@
 einval:	errno = EINVAL;
 	goto err;
 
-eftype:	errno = EFTYPE;
+eftype:	errno = EINVAL;
 	goto err;
 
 err:	saved_errno = errno;
@@ -328,7 +325,7 @@
 		if (t->bt_dbp)
 			free(t->bt_dbp);
 		if (t->bt_fd != -1)
-			(void)_close(t->bt_fd);
+			(void)close(t->bt_fd);
 		free(t);
 	}
 	errno = saved_errno;
@@ -401,10 +398,10 @@
 	}
 
 	(void)sigfillset(&set);
-	(void)__libc_sigprocmask(SIG_BLOCK, &set, &oset);
+	(void)sigprocmask(SIG_BLOCK, &set, &oset);
 	if ((fd = mkostemp(path, O_CLOEXEC)) != -1)
 		(void)unlink(path);
-	(void)__libc_sigprocmask(SIG_SETMASK, &oset, NULL);
+	(void)sigprocmask(SIG_SETMASK, &oset, NULL);
 	return(fd);
 }
 
--- src.orig/dbcompat/btree/bt_put.c
+++ src.freebsd/dbcompat/btree/bt_put.c
@@ -66,7 +66,7 @@
 {
 	BTREE *t;
 	DBT tkey, tdata;
-	EPG *e;
+	EPG *e = NULL;
 	PAGE *h;
 	indx_t idx, nxtindex;
 	pgno_t pg;
--- src.orig/dbcompat/btree/bt_seq.c
+++ src.freebsd/dbcompat/btree/bt_seq.c
@@ -232,7 +232,7 @@
 {
 	CURSOR *c;
 	PAGE *h;
-	indx_t idx;
+	indx_t idx = 0;
 	pgno_t pg;
 	int exact;
 
--- src.orig/dbcompat/btree/bt_split.c
+++ src.freebsd/dbcompat/btree/bt_split.c
@@ -46,6 +46,10 @@
 #include <db.h>
 #include "btree.h"
 
+#ifndef __PAST_END
+#define __PAST_END(array, offset) (((__typeof__(*(array)) *)(array))[offset])
+#endif
+
 static int	 bt_broot(BTREE *, PAGE *, PAGE *, PAGE *);
 static PAGE	*bt_page(BTREE *, PAGE *, PAGE **, PAGE **, indx_t *, size_t);
 static int	 bt_preserve(BTREE *, pgno_t);
@@ -77,14 +81,14 @@
 __bt_split(BTREE *t, PAGE *sp, const DBT *key, const DBT *data, int flags,
     size_t ilen, u_int32_t argskip)
 {
-	BINTERNAL *bi;
-	BLEAF *bl, *tbl;
+	BINTERNAL *bi = NULL;
+	BLEAF *bl = NULL, *tbl;
 	DBT a, b;
 	EPGNO *parent;
 	PAGE *h, *l, *r, *lchild, *rchild;
 	indx_t nxtindex;
 	u_int16_t skip;
-	u_int32_t n, nbytes, nksize;
+	u_int32_t n, nbytes, nksize = 0;
 	int parentsplit;
 	char *dest;
 
--- src.orig/dbcompat/db.c
+++ src.freebsd/dbcompat/db.c
@@ -42,8 +42,6 @@
 
 #include <db.h>
 
-static int __dberr(void);
-
 #ifndef O_CLOEXEC
 #define O_CLOEXEC 0
 #endif
@@ -69,8 +67,13 @@
 			return (__bt_open(fname, flags & USE_OPEN_FLAGS,
 			    mode, openinfo, flags & DB_FLAGS));
 		case DB_HASH:
+#if 0
+/* libdbcompat: not supported */
 			return (__hash_open(fname, flags & USE_OPEN_FLAGS,
 			    mode, openinfo, flags & DB_FLAGS));
+#else
+			break;
+#endif
 		case DB_RECNO:
 			return (__rec_open(fname, flags & USE_OPEN_FLAGS,
 			    mode, openinfo, flags & DB_FLAGS));
@@ -80,11 +83,59 @@
 }
 
 static int
-__dberr(void)
+__dberr_del(const struct __db *db, const DBT *dbt, u_int flags)
 {
+	(void)db;
+	(void)dbt;
+	(void)flags;
 	return (RET_ERROR);
 }
 
+static int
+__dberr_fd(const struct __db *db)
+{
+	(void)db;
+	return (RET_ERROR);
+}
+
+static int
+__dberr_get(const struct __db *db, const DBT *key, DBT *data, u_int flags)
+{
+	(void)db;
+	(void)key;
+	(void)data;
+	(void)flags;
+	return (RET_ERROR);
+}
+
+static int
+__dberr_put(const struct __db *db, DBT *key, const DBT *data, u_int flags)
+{
+	(void)db;
+	(void)key;
+	(void)data;
+	(void)flags;
+	return (RET_ERROR);
+}
+
+static int
+__dberr_seq(const struct __db *db, DBT *key, DBT *data, u_int flags)
+{
+	(void)db;
+	(void)key;
+	(void)data;
+	(void)flags;
+	return (RET_ERROR);
+}
+
+static int
+__dberr_sync(const struct __db *db, u_int flags)
+{
+	(void)db;
+	(void)flags;
+	return (RET_ERROR);
+}
+
 /*
  * __DBPANIC -- Stop.
  *
@@ -95,10 +146,10 @@
 __dbpanic(DB *dbp)
 {
 	/* The only thing that can succeed is a close. */
-	dbp->del = (int (*)(const struct __db *, const DBT*, u_int))__dberr;
-	dbp->fd = (int (*)(const struct __db *))__dberr;
-	dbp->get = (int (*)(const struct __db *, const DBT*, DBT *, u_int))__dberr;
-	dbp->put = (int (*)(const struct __db *, DBT *, const DBT *, u_int))__dberr;
-	dbp->seq = (int (*)(const struct __db *, DBT *, DBT *, u_int))__dberr;
-	dbp->sync = (int (*)(const struct __db *, u_int))__dberr;
+	dbp->del = __dberr_del;
+	dbp->fd = __dberr_fd;
+	dbp->get = __dberr_get;
+	dbp->put = __dberr_put;
+	dbp->seq = __dberr_seq;
+	dbp->sync = __dberr_sync;
 }
--- src.orig/dbcompat/mpool.c
+++ src.freebsd/dbcompat/mpool.c
@@ -33,7 +33,6 @@
 static char sccsid[] = "@(#)mpool.c	8.7 (Berkeley) 11/2/95";
 #endif /* LIBC_SCCS and not lint */
 #include <sys/cdefs.h>
-#include "namespace.h"
 #include <sys/param.h>
 #include <sys/queue.h>
 #include <sys/stat.h>
@@ -43,7 +42,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
-#include "un-namespace.h"
 
 #include <db.h>
 
@@ -66,13 +64,15 @@
 	MPOOL *mp;
 	int entry;
 
+	(void)key;
+
 	/*
 	 * Get information about the file.
 	 *
 	 * XXX
 	 * We don't currently handle pipes, although we should.
 	 */
-	if (_fstat(fd, &sb))
+	if (fstat(fd, &sb))
 		return (NULL);
 	if (!S_ISREG(sb.st_mode)) {
 		errno = ESPIPE;
@@ -276,6 +276,8 @@
 
 #ifdef STATISTICS
 	++mp->pageput;
+#else
+	(void)mp;
 #endif
 	bp = (BKT *)((char *)page - sizeof(BKT));
 #ifdef DEBUG
@@ -328,7 +330,7 @@
 			return (RET_ERROR);
 
 	/* Sync the file descriptor. */
-	return (_fsync(mp->fd) ? RET_ERROR : RET_SUCCESS);
+	return (fsync(mp->fd) ? RET_ERROR : RET_SUCCESS);
 }
 
 /*
--- src.orig/dbcompat/recno/rec_close.c
+++ src.freebsd/dbcompat/recno/rec_close.c
@@ -33,7 +33,6 @@
 static char sccsid[] = "@(#)rec_close.c	8.6 (Berkeley) 8/18/94";
 #endif /* LIBC_SCCS and not lint */
 #include <sys/cdefs.h>
-#include "namespace.h"
 #include <sys/types.h>
 #include <sys/uio.h>
 #include <sys/mman.h>
@@ -42,7 +41,6 @@
 #include <limits.h>
 #include <stdio.h>
 #include <unistd.h>
-#include "un-namespace.h"
 
 #include <db.h>
 #include "recno.h"
@@ -83,7 +81,7 @@
 			if (fclose(t->bt_rfp))
 				status = RET_ERROR;
 		} else {
-			if (_close(t->bt_rfd))
+			if (close(t->bt_rfd))
 				status = RET_ERROR;
 		}
 	}
@@ -149,7 +147,7 @@
 		 */
 		status = (dbp->seq)(dbp, &key, &data, R_FIRST);
 		while (status == RET_SUCCESS) {
-			if (_write(t->bt_rfd, data.data, data.size) !=
+			if (write(t->bt_rfd, data.data, data.size) !=
 			    (ssize_t)data.size)
 				return (RET_ERROR);
 			status = (dbp->seq)(dbp, &key, &data, R_NEXT);
@@ -162,7 +160,7 @@
 		while (status == RET_SUCCESS) {
 			iov[0].iov_base = data.data;
 			iov[0].iov_len = data.size;
-			if (_writev(t->bt_rfd, iov, 2) != (ssize_t)(data.size + 1))
+			if (writev(t->bt_rfd, iov, 2) != (ssize_t)(data.size + 1))
 				return (RET_ERROR);
 			status = (dbp->seq)(dbp, &key, &data, R_NEXT);
 		}
--- src.orig/dbcompat/recno/rec_open.c
+++ src.freebsd/dbcompat/recno/rec_open.c
@@ -36,7 +36,6 @@
 static char sccsid[] = "@(#)rec_open.c	8.10 (Berkeley) 9/1/94";
 #endif /* LIBC_SCCS and not lint */
 #include <sys/cdefs.h>
-#include "namespace.h"
 #include <sys/types.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
@@ -47,7 +46,6 @@
 #include <stddef.h>
 #include <stdio.h>
 #include <unistd.h>
-#include "un-namespace.h"
 
 #include <db.h>
 #include "recno.h"
@@ -61,10 +59,10 @@
 	DB *dbp;
 	PAGE *h;
 	struct stat sb;
-	int rfd, sverrno;
+	int rfd = -1, sverrno;
 
 	/* Open the user's file -- if this fails, we're done. */
-	if (fname != NULL && (rfd = _open(fname, flags | O_CLOEXEC, mode)) < 0)
+	if (fname != NULL && (rfd = open(fname, flags | O_CLOEXEC, mode)) < 0)
 		return (NULL);
 
 	/* Create a btree in memory (backed by disk). */
@@ -142,7 +140,7 @@
 				goto einval;
 			}
 
-			if (_fstat(rfd, &sb))
+			if (fstat(rfd, &sb))
 				goto err;
 			/*
 			 * Kluge -- we'd like to test to see if the file is too
@@ -211,7 +209,7 @@
 	if (dbp != NULL)
 		(void)__bt_close(dbp);
 	if (fname != NULL)
-		(void)_close(rfd);
+		(void)close(rfd);
 	errno = sverrno;
 	return (NULL);
 }
--- src.orig/dbinclude/db.h
+++ src.freebsd/dbinclude/db.h
@@ -38,6 +38,7 @@
 #include <sys/cdefs.h>
 
 #include <limits.h>
+#include <stdint.h>
 
 #define	RET_ERROR	-1		/* Return values. */
 #define	RET_SUCCESS	 0
@@ -204,9 +205,7 @@
 #endif
 
 __BEGIN_DECLS
-#if __BSD_VISIBLE
 DB *dbopen(const char *, int, int, DBTYPE, const void *);
-#endif
 
 #ifdef __DBINTERFACE_PRIVATE
 DB	*__bt_open(const char *, int, int, const BTREEINFO *, int);
--- src.orig/diffutils/cmp/cmp.c
+++ src.freebsd/diffutils/cmp/cmp.c
@@ -55,6 +55,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <signal.h>
 
 #include <libutil.h>
 
@@ -87,7 +88,7 @@
 static void usage(void) __dead2;
 
 static bool
-parse_iskipspec(char *spec, off_t *skip1, off_t *skip2)
+parse_iskipspec(char *spec, uint64_t *skip1, uint64_t *skip2)
 {
 	char *colon;
 
@@ -109,7 +110,7 @@
 main(int argc, char *argv[])
 {
 	struct stat sb1, sb2;
-	off_t skip1, skip2, limit;
+	uint64_t skip1, skip2, limit;
 	int ch, fd1, fd2, oflag;
 	bool special;
 	const char *file1, *file2;
@@ -136,7 +137,7 @@
 			lflag = true;
 			break;
 		case 'n':		/* Limit */
-			if (expand_number(optarg, &limit) < 0 || limit < 0) {
+			if (expand_number(optarg, &limit) < 0) {
 				fprintf(stderr, "Invalid --bytes: %s\n",
 				    optarg);
 				usage();
--- src.orig/diffutils/cmp/extern.h
+++ src.freebsd/diffutils/cmp/extern.h
@@ -32,6 +32,8 @@
  *
  */
 
+#include <stdbool.h>
+
 #define OK_EXIT		0
 #define DIFF_EXIT	1
 #define ERR_EXIT	2	/* error exit code */
--- src.orig/diffutils/cmp/regular.c
+++ src.freebsd/diffutils/cmp/regular.c
@@ -39,6 +39,7 @@
 #include <sys/param.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
+#include <sys/types.h>
 
 #include <capsicum_helpers.h>
 #include <err.h>
--- src.orig/diffutils/diff/diff.c
+++ src.freebsd/diffutils/diff/diff.c
@@ -487,20 +487,23 @@
 read_excludes_file(char *file)
 {
 	FILE *fp;
-	char *buf, *pattern;
-	size_t len;
+	char *pattern = NULL;
+	size_t blen = 0;
+	ssize_t len;
 
 	if (strcmp(file, "-") == 0)
 		fp = stdin;
 	else if ((fp = fopen(file, "r")) == NULL)
 		err(2, "%s", file);
-	while ((buf = fgetln(fp, &len)) != NULL) {
-		if (buf[len - 1] == '\n')
-			len--;
-		if ((pattern = strndup(buf, len)) == NULL)
-			err(2, "xstrndup");
+	while ((len = getline(&pattern, &blen, fp)) >= 0) {
+		if ((len > 0) && (pattern[len - 1] == '\n'))
+			pattern[len - 1] = '\0';
 		push_excludes(pattern);
+		/* we allocate a new string per line */
+		pattern = NULL;
+		blen = 0;
 	}
+	free(pattern);
 	if (strcmp(file, "-") != 0)
 		fclose(fp);
 }
--- src.orig/diffutils/diff/diff.h
+++ src.freebsd/diffutils/diff/diff.h
@@ -114,3 +114,11 @@
 int	diffreg(char *, char *, int, int);
 void	diffdir(char *, char *, int);
 void	print_status(int, char *, char *, const char *);
+
+#ifndef MIN
+#define MIN(X, Y) (((X) < (Y)) ? (X) : (Y))
+#endif
+
+#ifndef MAX
+#define MAX(X, Y) (((X) > (Y)) ? (X) : (Y))
+#endif
--- src.orig/diffutils/diff/diffreg.c
+++ src.freebsd/diffutils/diff/diffreg.c
@@ -84,6 +84,9 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <unistd.h>
+#include <limits.h>
+#include <time_bsd.h>
 
 #include "pr.h"
 #include "diff.h"
@@ -1396,7 +1399,7 @@
 static char *
 match_function(const long *f, int pos, FILE *fp)
 {
-	unsigned char buf[FUNCTION_CONTEXT_SIZE];
+	char buf[FUNCTION_CONTEXT_SIZE];
 	size_t nc;
 	int last = lastline;
 	const char *state = NULL;
@@ -1638,11 +1641,11 @@
 		printf("%s %s\n", diff_format == D_CONTEXT ? "***" : "---",
 		    label[0]);
 	else {
-		strftime(buf, sizeof(buf), time_format, tm_ptr1);
+		strftime_bsd(buf, sizeof(buf), time_format, tm_ptr1);
 		printf("%s %s\t%s", diff_format == D_CONTEXT ? "***" : "---",
 		    file1, buf);
 		if (!cflag) {
-			strftime(buf, sizeof(buf), "%z", tm_ptr1);
+			strftime_bsd(buf, sizeof(buf), "%z", tm_ptr1);
 			printf(".%.9d %s", nsec1, buf);
 		}
 		printf("\n");
@@ -1651,11 +1654,11 @@
 		printf("%s %s\n", diff_format == D_CONTEXT ? "---" : "+++",
 		    label[1]);
 	else {
-		strftime(buf, sizeof(buf), time_format, tm_ptr2);
+		strftime_bsd(buf, sizeof(buf), time_format, tm_ptr2);
 		printf("%s %s\t%s", diff_format == D_CONTEXT ? "---" : "+++",
 		    file2, buf);
 		if (!cflag) {
-			strftime(buf, sizeof(buf), "%z", tm_ptr2);
+			strftime_bsd(buf, sizeof(buf), "%z", tm_ptr2);
 			printf(".%.9d %s", nsec2, buf);
 		}
 		printf("\n");
--- src.orig/diffutils/diff/pr.c
+++ src.freebsd/diffutils/diff/pr.c
@@ -25,7 +25,6 @@
  */
 
 #include <sys/cdefs.h>
-#include <sys/procdesc.h>
 #include <sys/wait.h>
 
 #include <err.h>
@@ -34,6 +33,9 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <poll.h>
 
 #include "pr.h"
 #include "diff.h"
@@ -41,11 +43,19 @@
 
 #define _PATH_PR "/usr/bin/pr"
 
+static int sigpipe[2] = {-1, -1};
+static struct pollfd poll_fd;
+
+static void
+handle_sig(int signo)
+{
+	write(sigpipe[1], &signo, sizeof(signo));
+}
+
 struct pr *
 start_pr(char *file1, char *file2)
 {
 	int pfd[2];
-	int pr_pd;
 	pid_t pid;
 	char *header;
 	struct pr *pr;
@@ -58,7 +68,20 @@
 	rewind(stdout);
 	if (pipe(pfd) == -1)
 		err(2, "pipe");
-	switch ((pid = pdfork(&pr_pd, PD_CLOEXEC))) {
+	if (sigpipe[0] < 0) {
+		if (pipe(sigpipe) == -1)
+			err(2, "pipe");
+		if (fcntl(sigpipe[0], F_SETFD, FD_CLOEXEC) == -1)
+			err(2, "fcntl");
+		if (fcntl(sigpipe[1], F_SETFD, FD_CLOEXEC) == -1)
+			err(2, "fcntl");
+		if (signal(SIGCHLD, handle_sig) == SIG_ERR)
+			err(2, "signal");
+		poll_fd.fd = sigpipe[0];
+		poll_fd.events = POLLIN;
+	}
+	poll_fd.revents = 0;
+	switch ((pid = fork())) {
 	case -1:
 		status |= 2;
 		free(header);
@@ -83,14 +106,7 @@
 		close(pfd[0]);
 		rewind(stdout);
 		free(header);
-		pr->kq = kqueue();
-		if (pr->kq == -1)
-			err(2, "kqueue");
-		pr->e = xmalloc(sizeof(struct kevent));
-		EV_SET(pr->e, pr_pd, EVFILT_PROCDESC, EV_ADD, NOTE_EXIT, 0,
-		    NULL);
-		if (kevent(pr->kq, pr->e, 1, NULL, 0, NULL) == -1)
-			err(2, "kevent");
+		pr->cpid = pid;
 	}
 	return (pr);
 }
@@ -100,6 +116,7 @@
 stop_pr(struct pr *pr)
 {
 	int wstatus;
+	int done = 0;
 
 	if (pr == NULL)
 		return;
@@ -110,14 +127,27 @@
 		dup2(pr->ostdout, STDOUT_FILENO);
 		close(pr->ostdout);
 	}
-	if (kevent(pr->kq, NULL, 0, pr->e, 1, NULL) == -1)
-		err(2, "kevent");
-	wstatus = pr->e[0].data;
-	close(pr->kq);
+	while (!done) {
+		pid_t wpid;
+		int npe = poll(&poll_fd, 1, -1);
+		if (npe == -1) {
+			if (errno == EINTR) continue;
+			err(2, "poll");
+		}
+		if (poll_fd.revents != POLLIN)
+			continue;
+		if (read(poll_fd.fd, &npe, sizeof(npe)) < 0)
+			err(2, "read");
+		while ((wpid = waitpid(-1, &wstatus, WNOHANG)) > 0) {
+			if (wpid != pr->cpid) continue;
+			if (WIFEXITED(wstatus) && WEXITSTATUS(wstatus) != 0)
+				errx(2, "pr exited abnormally");
+			else if (WIFSIGNALED(wstatus))
+				errx(2, "pr killed by signal %d",
+				    WTERMSIG(wstatus));
+			done = 1;
+			break;
+		}
+	}
 	free(pr);
-	if (WIFEXITED(wstatus) && WEXITSTATUS(wstatus) != 0)
-		errx(2, "pr exited abnormally");
-	else if (WIFSIGNALED(wstatus))
-		errx(2, "pr killed by signal %d",
-		    WTERMSIG(wstatus));
 }
--- src.orig/diffutils/diff/pr.h
+++ src.freebsd/diffutils/diff/pr.h
@@ -24,12 +24,9 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include <sys/event.h>
-
 struct pr {
 	int ostdout;
-	int kq;
-	struct kevent *e;
+	pid_t cpid;
 };
 
 struct pr *start_pr(char *file1, char *file2);
--- src.orig/diffutils/diff3/diff3.c
+++ src.freebsd/diffutils/diff3/diff3.c
@@ -71,9 +71,7 @@
 #endif /* not lint */
 #include <sys/cdefs.h>
 #include <sys/capsicum.h>
-#include <sys/procdesc.h>
 #include <sys/types.h>
-#include <sys/event.h>
 #include <sys/wait.h>
 
 #include <capsicum_helpers.h>
@@ -82,10 +80,13 @@
 #include <getopt.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <stdbool.h>
 #include <limits.h>
 #include <inttypes.h>
 #include <string.h>
 #include <unistd.h>
+#include <errno.h>
+#include <poll.h>
 
 
 /*
@@ -130,6 +131,7 @@
 static int  overlapcnt;
 static FILE *fp[3];
 static int cline[3];		/* # of the last-read line in each file (0-2) */
+static int sigpipe[2];
 /*
  * The latest known correspondence between line numbers of the 3 files
  * is stored in last[1-3];
@@ -245,12 +247,10 @@
 	return (i);
 }
 
-static int
+static void
 diffexec(const char *diffprog, char **diffargv, int fd[])
 {
-	int pd;
-
-	switch (pdfork(&pd, PD_CLOEXEC)) {
+	switch (fork()) {
 	case 0:
 		close(fd[0]);
 		if (dup2(fd[1], STDOUT_FILENO) == -1)
@@ -264,7 +264,6 @@
 		break;
 	}
 	close(fd[1]);
-	return (pd);
 }
 
 static char *
@@ -827,20 +826,25 @@
 	szchanges = newsz;
 }
 
+static void
+handle_sig(int signo)
+{
+    write(sigpipe[1], &signo, sizeof(signo));
+}
 
 int
 main(int argc, char **argv)
 {
-	int ch, nblabels, status, m, n, kq, nke, nleft, i;
+	int ch, nblabels, status, m, n, npe, nleft;
 	char *labels[] = { NULL, NULL, NULL };
 	const char *diffprog = DIFF_PATH;
 	char *file1, *file2, *file3;
 	char *diffargv[7];
 	int diffargc = 0;
-	int fd13[2], fd23[2];
-	int pd13, pd23;
+	int fd13[2], fd23[2], signo;
+	pid_t wpid;
+	struct pollfd pfd;
 	cap_rights_t rights_ro;
-	struct kevent *e;
 
 	nblabels = 0;
 	eflag = EFLAG_NONE;
@@ -921,14 +925,6 @@
 
 	cap_rights_init(&rights_ro, CAP_READ, CAP_FSTAT, CAP_SEEK);
 
-	kq = kqueue();
-	if (kq == -1)
-		err(2, "kqueue");
-
-	e = malloc(2 * sizeof(struct kevent));
-	if (e == NULL)
-		err(2, "malloc");
-
 	/* TODO stdio */
 	file1 = argv[0];
 	file2 = argv[1];
@@ -970,23 +966,30 @@
 		err(2, "pipe");
 	if (pipe(fd23))
 		err(2, "pipe");
+	if (pipe(sigpipe))
+		err(2, "pipe");
+	if (fcntl(sigpipe[0], F_SETFD, FD_CLOEXEC))
+		err(2, "fcntl");
+	if (fcntl(sigpipe[1], F_SETFD, FD_CLOEXEC))
+		err(2, "fcntl");
 
+	pfd.fd = sigpipe[0];
+	pfd.events = POLLIN;
+	pfd.revents = 0;
+
+	if (signal(SIGCHLD, handle_sig) == SIG_ERR)
+		err(2, "signal");
+
 	diffargv[diffargc] = file1;
 	diffargv[diffargc + 1] = file3;
 	diffargv[diffargc + 2] = NULL;
 
 	nleft = 0;
-	pd13 = diffexec(diffprog, diffargv, fd13);
-	EV_SET(e + nleft , pd13, EVFILT_PROCDESC, EV_ADD, NOTE_EXIT, 0, NULL);
-	if (kevent(kq, e + nleft, 1, NULL, 0, NULL) == -1)
-		err(2, "kevent1");
+	diffexec(diffprog, diffargv, fd13);
 	nleft++;
 
 	diffargv[diffargc] = file2;
-	pd23 = diffexec(diffprog, diffargv, fd23);
-	EV_SET(e + nleft , pd23, EVFILT_PROCDESC, EV_ADD, NOTE_EXIT, 0, NULL);
-	if (kevent(kq, e + nleft, 1, NULL, 0, NULL) == -1)
-		err(2, "kevent2");
+	diffexec(diffprog, diffargv, fd23);
 	nleft++;
 
 	caph_cache_catpages();
@@ -998,20 +1001,25 @@
 	m = readin(fd13[0], &d13);
 	n = readin(fd23[0], &d23);
 
-	/* waitpid cooked over pdforks */
+	/* waitpid */
 	while (nleft > 0) {
-		nke = kevent(kq, NULL, 0, e, nleft, NULL);
-		if (nke == -1)
-			err(2, "kevent");
-		for (i = 0; i < nke; i++) {
-			status = e[i].data;
+		npe = poll(&pfd, 1, -1);
+		if (npe == -1) {
+			if (errno == EINTR) continue;
+			err(2, "poll");
+		}
+		if (pfd.revents != POLLIN)
+			continue;
+		if (read(pfd.fd, &signo, sizeof(signo)) < 0)
+			err(2, "read");
+		while ((wpid = waitpid(-1, &status, WNOHANG)) > 0) {
 			if (WIFEXITED(status) && WEXITSTATUS(status) >= 2)
 				errx(2, "diff exited abnormally");
 			else if (WIFSIGNALED(status))
 				errx(2, "diff killed by signal %d",
 				    WTERMSIG(status));
+			--nleft;
 		}
-		nleft -= nke;
 	}
 	merge(m, n);
 
--- src.orig/diffutils/sdiff/sdiff.c
+++ src.freebsd/diffutils/sdiff/sdiff.c
@@ -258,16 +258,19 @@
 		case 'E':
 		case 'i':
 		case 't':
-		case 'W':
-			diffargv[1]  = realloc(diffargv[1], sizeof(char) * strlen(diffargv[1]) + 2);
+		case 'W': {
+			int alen = strlen(diffargv[1]);
+			diffargv[1] = realloc(diffargv[1], sizeof(char) * alen + 2);
 			/*
 			 * In diff, the 'W' option is 'w' and the 'w' is 'W'.
 			 */
 			if (ch == 'W')
-				sprintf(diffargv[1], "%sw", diffargv[1]);
+				diffargv[1][alen] = 'w';
 			else
-				sprintf(diffargv[1], "%s%c", diffargv[1], ch);
+				diffargv[1][alen] = ch;
+			diffargv[1][alen + 1] = '\0';
 			break;
+		}
 		case 'H':
 			diffargv[diffargc++] = speed_lf;
 			break;
--- src.orig/ed/main.c
+++ src.freebsd/ed/main.c
@@ -210,6 +210,7 @@
 		switch (status) {
 		case EOF:
 			quit(0);
+			break; /* unreachable */
 		case EMOD:
 			modified = 0;
 			fputs("?\n", stderr);		/* give warning */
@@ -229,6 +230,7 @@
 			} else if (garrulous)
 				fprintf(stderr, "%s\n", errmsg);
 			quit(3);
+			break; /* unreachable */
 		default:
 			fputs("?\n", stderr);
 			if (!isatty(0)) {
--- src.orig/fetch/fetch.c
+++ src.freebsd/fetch/fetch.c
@@ -32,6 +32,7 @@
 #include <sys/cdefs.h>
 #include <sys/param.h>
 #include <sys/socket.h>
+#include <sys/ioctl.h>
 #include <sys/stat.h>
 #include <sys/time.h>
 
@@ -52,6 +53,12 @@
 #define MINBUFSIZE	16384
 #define TIMEOUT		120
 
+#ifndef TCSASOFT
+#define TCSASOFT 0
+#endif
+
+#define setproctitle(...)
+
 /* Option flags */
 static int	 A_flag;	/*    -A: do not follow 302 redirects */
 static int	 a_flag;	/*    -a: auto retry */
@@ -281,7 +288,7 @@
 static void
 stat_display(struct xferstat *xs, int force)
 {
-	char bytes[16], bps[16], eta[16];
+	char bytes[16], bps[32], eta[32];
 	struct timeval now;
 	int ctty_pgrp;
 
@@ -431,11 +438,11 @@
 	struct xferstat xs;
 	FILE *f, *of;
 	size_t size, readcnt, wr;
-	off_t count, size_prev;
+	off_t count, size_prev = 0;
 	char flags[8];
 	const char *slash;
 	char *tmppath;
-	int r, tries;
+	int r, tries = 0;
 	unsigned timeout;
 	char *ptr;
 
@@ -637,6 +644,7 @@
 		if (!F_flag && us.mtime && sb.st_mtime != us.mtime && tries == 1) {
 			/* no match! have to refetch */
 			fclose(f);
+			f = NULL;
 			/* if precious, warn the user and give up */
 			if (R_flag) {
 				warnx("%s: local modification time "
--- src.orig/findutils/find/extern.h
+++ src.freebsd/findutils/find/extern.h
@@ -32,6 +32,7 @@
  */
 
 #include <sys/cdefs.h>
+#include <sys/types.h>
 
 void	 brace_subst(char *, char **, char *, size_t);
 PLAN	*find_create(char ***);
@@ -46,6 +47,7 @@
 int	 queryuser(char **);
 OPTION	*lookup_option(const char *);
 void	 finish_execplus(void);
+const char *f_fstypename(dev_t);
 
 creat_f	c_Xmin;
 creat_f	c_Xtime;
--- src.orig/findutils/find/find.1
+++ src.freebsd/findutils/find/find.1
@@ -201,35 +201,6 @@
 and neither means
 .Dq exactly n .
 .Bl -tag -width indent
-.It Ic -Bmin Ar n
-True if the difference between the time of a file's inode creation
-and the time
-.Nm
-was started, rounded up to the next full minute, is
-.Ar n
-minutes.
-.It Ic -Bnewer Ar file
-Same as
-.Ic -newerBm .
-.It Ic -Btime Ar n Ns Op Cm smhdw
-If no units are specified, this primary evaluates to
-true if the difference between the time of a file's inode creation
-and the time
-.Nm
-was started, rounded up to the next full 24-hour period, is
-.Ar n
-24-hour periods.
-.Pp
-If units are specified, this primary evaluates to
-true if the difference between the time of a file's inode creation
-and the time
-.Nm
-was started is exactly
-.Ar n
-units.
-Please refer to the
-.Ic -atime
-primary description for information on supported time units.
 .It Ic -acl
 May be used in conjunction with other primaries to locate
 files with extended ACLs.
@@ -451,50 +422,6 @@
 returns a non-zero exit status,
 .Nm
 will return a non-zero exit status.
-.It Ic -flags Oo Cm - Ns | Ns Cm + Oc Ns Ar flags , Ns Ar notflags
-The flags are specified using symbolic names (see
-.Xr chflags 1 ) .
-Those with the
-.Qq Li no
-prefix (except
-.Qq Li nodump )
-are said to be
-.Ar notflags .
-Flags in
-.Ar flags
-are checked to be set, and flags in
-.Ar notflags
-are checked to be not set.
-Note that this is different from
-.Ic -perm ,
-which only allows the user to specify mode bits that are set.
-.Pp
-If flags are preceded by a dash
-.Pq Dq Li - ,
-this primary evaluates to true
-if at least all of the bits in
-.Ar flags
-and none of the bits in
-.Ar notflags
-are set in the file's flags bits.
-If flags are preceded by a plus
-.Pq Dq Li + ,
-this primary evaluates to true
-if any of the bits in
-.Ar flags
-is set in the file's flags bits,
-or any of the bits in
-.Ar notflags
-is not set in the file's flags bits.
-Otherwise,
-this primary evaluates to true
-if the bits in
-.Ar flags
-exactly match the file's flags bits,
-and none of the
-.Ar flags
-bits match those of
-.Ar notflags .
 .It Ic -fstype Ar type
 True if the file is contained in a file system of type
 .Ar type .
@@ -502,15 +429,9 @@
 .Xr lsvfs 1
 command can be used to find out the types of file systems
 that are available on the system.
-In addition, there are two pseudo-types,
-.Dq Li local
-and
-.Dq Li rdonly .
-The former matches any file system physically mounted on the system where
-the
-.Nm
-is being executed and the latter matches any file system which is
-mounted read-only.
+In addition, there is a pseudotype
+.Dq Li rdonly
+that matches any file system which is mounted read-only.
 .It Ic -gid Ar gname
 The same thing as
 .Ic -group Ar gname
@@ -1018,7 +939,6 @@
 .Sx STANDARDS
 section below for details.
 .Sh SEE ALSO
-.Xr chflags 1 ,
 .Xr chmod 1 ,
 .Xr locate 1 ,
 .Xr lsvfs 1 ,
@@ -1049,9 +969,7 @@
 .Ic -amin , -anewer , -cmin , -cnewer , -delete , -empty , -fstype ,
 .Ic -iname , -inum , -iregex , -ls , -maxdepth , -mindepth , -mmin ,
 .Ic -not , -path , -print0 , -regex , -sparse
-and all of the
-.Fl B*
-birthtime related primaries are extensions to
+are extensions to
 .St -p1003.1-2001 .
 .Pp
 Historically, the
--- src.orig/findutils/find/find.c
+++ src.freebsd/findutils/find/find.c
@@ -50,7 +50,7 @@
 
 #include "find.h"
 
-static int find_compare(const FTSENT * const *s1, const FTSENT * const *s2);
+static int find_compare(const FTSENT **s1, const FTSENT **s2);
 
 /*
  * find_compare --
@@ -59,7 +59,7 @@
  *	order within each directory.
  */
 static int
-find_compare(const FTSENT * const *s1, const FTSENT * const *s2)
+find_compare(const FTSENT **s1, const FTSENT **s2)
 {
 
 	return (strcoll((*s1)->fts_name, (*s2)->fts_name));
@@ -235,5 +235,6 @@
 	finish_execplus();
 	if (e && (!ignore_readdir_race || e != ENOENT))
 		errc(1, e, "fts_read");
+	f_fstypename(0); /* free allocated filesystem type resources */
 	return (exitstatus);
 }
--- src.orig/findutils/find/find.h
+++ src.freebsd/findutils/find/find.h
@@ -55,11 +55,7 @@
 #else
 #define HAVE_STRUCT_STAT_ST_BIRTHTIME 0
 #endif
-#if defined(MFSNAMELEN) || defined(MFSTYPENAMELEN)
 #define HAVE_STRUCT_STATFS_F_FSTYPENAME 1
-#else
-#define HAVE_STRUCT_STATFS_F_FSTYPENAME 0
-#endif
 
 /* forward declarations */
 struct _plandata;
--- src.orig/findutils/find/function.c
+++ src.freebsd/findutils/find/function.c
@@ -38,12 +38,14 @@
 
 #include <sys/cdefs.h>
 #include <sys/param.h>
-#include <sys/ucred.h>
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <sys/acl.h>
 #include <sys/wait.h>
 #include <sys/mount.h>
+#include <sys/sysmacros.h>
+#include <sys/statvfs.h>
+#include <acl/libacl.h>
 
 #include <dirent.h>
 #include <err.h>
@@ -62,6 +64,10 @@
 
 #include "find.h"
 
+#ifndef REG_STARTEND
+#define REG_STARTEND 0
+#endif
+
 static PLAN *palloc(OPTION *);
 static long long find_parsenum(PLAN *, const char *, char *, char *);
 static long long find_parsetime(PLAN *, const char *, char *);
@@ -371,12 +377,11 @@
 int
 f_acl(PLAN *plan __unused, FTSENT *entry)
 {
-	acl_t facl;
-	acl_type_t acl_type;
-	int acl_supported = 0, ret, trivial;
+	int acl_supported = 0, ret;
 
 	if (S_ISLNK(entry->fts_statp->st_mode))
 		return 0;
+#if 0
 	ret = pathconf(entry->fts_accpath, _PC_ACL_NFS4);
 	if (ret > 0) {
 		acl_supported = 1;
@@ -385,16 +390,17 @@
 		warn("%s", entry->fts_accpath);
 		return (0);
 	}
+#endif
 	if (acl_supported == 0) {
-		ret = pathconf(entry->fts_accpath, _PC_ACL_EXTENDED);
+		ret = acl_extended_file(entry->fts_accpath);
 		if (ret > 0) {
 			acl_supported = 1;
-			acl_type = ACL_TYPE_ACCESS;
-		} else if (ret < 0 && errno != EINVAL) {
+		} else if (ret < 0 && errno != ENOTSUP) {
 			warn("%s", entry->fts_accpath);
 			return (0);
 		}
 	}
+#if 0
 	if (acl_supported == 0)
 		return (0);
 
@@ -412,6 +418,8 @@
 	if (trivial)
 		return (0);
 	return (1);
+#endif
+	return acl_supported;
 }
 #endif
 
@@ -872,6 +880,64 @@
 }
 
 #if HAVE_STRUCT_STATFS_F_FSTYPENAME
+struct mntinfo {
+    dev_t devn;
+    char fstype[64];
+};
+
+const char *
+f_fstypename(dev_t curdev)
+{
+	static struct mntinfo *minfo = NULL;
+	static size_t ninfos = 0;
+	char curfstype[64];
+	/* to be freed */
+	if (!curdev) {
+		free(minfo);
+		minfo = NULL;
+		ninfos = 0;
+		return NULL;
+	}
+	if (!minfo) {
+		FILE *f = fopen("/proc/self/mountinfo", "rb");
+		if (!f)
+			return NULL;
+		char *lbuf = NULL;
+		size_t lsize = 0, ncap = 64;
+		minfo = malloc(ncap * sizeof(struct mntinfo));
+		if (!minfo)
+			err(1, "malloc");
+		const char *rfs = NULL;
+		while (getline(&lbuf, &lsize, f) > 0) {
+			unsigned int maj, min;
+			if (sscanf(
+			    lbuf, "%*d %*d %u:%u %*s %*s %*s %*s - %63s %*s %*s",
+			    &maj, &min, curfstype
+			) <= 0)
+				continue;
+			if (ninfos == ncap) {
+				ncap *= 2;
+				minfo = realloc(minfo, ncap * sizeof(struct mntinfo));
+				if (!minfo)
+					err(1, "realloc");
+			}
+			minfo[ninfos].devn = makedev(maj, min);
+			memcpy(minfo[ninfos].fstype, curfstype, sizeof(curfstype));
+			if (minfo[ninfos].devn == curdev)
+				rfs = minfo[ninfos].fstype;
+			++ninfos;
+		}
+		free(lbuf);
+		fclose(f);
+		return rfs;
+	}
+	for (size_t i = 0; i < ninfos; ++i) {
+		if (minfo[i].devn == curdev)
+			return minfo[i].fstype;
+	}
+	return NULL;
+}
+
 /*
  * -fstype functions --
  *
@@ -882,9 +948,9 @@
 {
 	static dev_t curdev;	/* need a guaranteed illegal dev value */
 	static int first = 1;
-	struct statfs sb;
-	static int val_flags;
-	static char fstype[sizeof(sb.f_fstypename)];
+	struct statvfs sb;
+	static unsigned long val_flags;
+	static const char *fstype;
 	char *p, save[2] = {0,0};
 
 	if ((plan->flags & F_MTMASK) == F_MTUNKNOWN)
@@ -895,7 +961,7 @@
 		curdev = entry->fts_statp->st_dev;
 
 		/*
-		 * Statfs follows symlinks; find wants the link's filesystem,
+		 * Statvfs follows symlinks; find wants the link's filesystem,
 		 * not where it points.
 		 */
 		if (entry->fts_info == FTS_SL ||
@@ -911,7 +977,7 @@
 		} else
 			p = NULL;
 
-		if (statfs(entry->fts_accpath, &sb)) {
+		if (statvfs(entry->fts_accpath, &sb)) {
 			if (!ignore_readdir_race || errno != ENOENT) {
 				warn("statfs: %s", entry->fts_accpath);
 				exitstatus = 1;
@@ -930,14 +996,14 @@
 		 * Further tests may need both of these values, so
 		 * always copy both of them.
 		 */
-		val_flags = sb.f_flags;
-		strlcpy(fstype, sb.f_fstypename, sizeof(fstype));
+		val_flags = sb.f_flag;
+		fstype = f_fstypename(curdev);
 	}
 	switch (plan->flags & F_MTMASK) {
 	case F_MTFLAG:
 		return val_flags & plan->mt_data;
 	case F_MTTYPE:
-		return (strncmp(fstype, plan->c_data, sizeof(fstype)) == 0);
+		return fstype && (strcmp(fstype, plan->c_data) == 0);
 	default:
 		abort();
 	}
@@ -954,17 +1020,10 @@
 
 	new = palloc(option);
 	switch (*fsname) {
-	case 'l':
-		if (!strcmp(fsname, "local")) {
-			new->flags |= F_MTFLAG;
-			new->mt_data = MNT_LOCAL;
-			return new;
-		}
-		break;
 	case 'r':
 		if (!strcmp(fsname, "rdonly")) {
 			new->flags |= F_MTFLAG;
-			new->mt_data = MNT_RDONLY;
+			new->mt_data = ST_RDONLY;
 			return new;
 		}
 		break;
@@ -1259,7 +1318,9 @@
 int
 f_nogroup(PLAN *plan __unused, FTSENT *entry)
 {
-	return group_from_gid(entry->fts_statp->st_gid, 1) == NULL;
+	struct group *gr;
+	gr = getgrgid(entry->fts_statp->st_gid);
+	return gr == NULL;
 }
 
 PLAN *
@@ -1279,7 +1340,9 @@
 int
 f_nouser(PLAN *plan __unused, FTSENT *entry)
 {
-	return user_from_uid(entry->fts_statp->st_uid, 1) == NULL;
+	struct passwd *pw;
+	pw = getpwuid(entry->fts_statp->st_uid);
+	return pw == NULL;
 }
 
 PLAN *
--- src.orig/findutils/find/ls.c
+++ src.freebsd/findutils/find/ls.c
@@ -36,6 +36,7 @@
 #include <sys/cdefs.h>
 #include <sys/param.h>
 #include <sys/stat.h>
+#include <sys/types.h>
 
 #include <err.h>
 #include <errno.h>
@@ -46,7 +47,7 @@
 #include <pwd.h>
 #include <stdio.h>
 #include <string.h>
-#include <time.h>
+#include <time_bsd.h>
 #include <unistd.h>
 
 #include "find.h"
@@ -60,13 +61,29 @@
 printlong(char *name, char *accpath, struct stat *sb)
 {
 	char modep[15];
+	struct passwd *pw = NULL;
+	struct group *gr = NULL;
+	char *uname = NULL;
+	char *gname = NULL;
 
+	pw = getpwuid(sb->st_uid);
+	if (pw == NULL)
+		uname = "root";
+	else
+		uname = pw->pw_name;
+
+	gr = getgrgid(sb->st_gid);
+	if (gr == NULL)
+		gname = "root";
+	else
+		gname = gr->gr_name;
+
 	(void)printf("%6ju %8"PRId64" ", (uintmax_t)sb->st_ino, sb->st_blocks);
 	(void)strmode(sb->st_mode, modep);
 	(void)printf("%s %3ju %-*s %-*s ", modep, (uintmax_t)sb->st_nlink,
 	    MAXLOGNAME - 1,
-	    user_from_uid(sb->st_uid, 0), MAXLOGNAME - 1,
-	    group_from_gid(sb->st_gid, 0));
+	    uname, MAXLOGNAME - 1,
+	    gname);
 
 	if (S_ISCHR(sb->st_mode) || S_ISBLK(sb->st_mode))
 		(void)printf("%#8jx ", (uintmax_t)sb->st_rdev);
@@ -103,7 +120,7 @@
 		/* mmm dd  yyyy || dd mmm  yyyy */
 		format = d_first ? "%e %b  %Y " : "%b %e  %Y ";
 	if ((tm = localtime(&ftime)) != NULL)
-		strftime(longstring, sizeof(longstring), format, tm);
+		strftime_bsd(longstring, sizeof(longstring), format, tm);
 	else
 		strlcpy(longstring, "bad date val ", sizeof(longstring));
 	fputs(longstring, stdout);
--- src.orig/findutils/find/main.c
+++ src.freebsd/findutils/find/main.c
@@ -32,9 +32,11 @@
  * SUCH DAMAGE.
  */
 
+#if 0
 static const char copyright[] =
 "@(#) Copyright (c) 1990, 1993, 1994\n\
 	The Regents of the University of California.  All rights reserved.\n";
+#endif
 
 #if 0
 static char sccsid[] = "@(#)main.c	8.4 (Berkeley) 5/4/95";
--- src.orig/findutils/find/misc.c
+++ src.freebsd/findutils/find/misc.c
@@ -49,6 +49,10 @@
 
 #include "find.h"
 
+#if defined(__linux__) && !defined(__GLIBC__)
+#include <rpmatch.h>
+#endif
+
 /*
  * brace_subst --
  *	Replace occurrences of {} in s1 with s2 and return the result string.
--- src.orig/findutils/locate/bigram/locate.bigram.c
+++ src.freebsd/findutils/locate/bigram/locate.bigram.c
@@ -47,11 +47,12 @@
 #endif /* not lint */
 #endif
 
-
+#include <sys/types.h>
 #include <capsicum_helpers.h>
 #include <err.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <limits.h>
 #include "locate.h"
 
 u_char buf1[LOCATE_PATH_MAX] = " ";
@@ -68,7 +69,7 @@
 	if (caph_limit_stdio() < 0 || caph_enter() < 0)
 		err(1, "capsicum");
 
-     	while (fgets(path, sizeof(buf2), stdin) != NULL) {
+     	while (fgets((char *)path, sizeof(buf2), stdin) != NULL) {
 
 		/* 
 		 * We don't need remove newline character '\n'.
--- src.orig/findutils/locate/code/locate.code.c
+++ src.freebsd/findutils/locate/code/locate.code.c
@@ -90,6 +90,7 @@
  */
 
 #include <sys/param.h>
+#include <sys/types.h>
 #include <err.h>
 #include <errno.h>
 #include <stdlib.h>
@@ -133,7 +134,7 @@
 		err(1, "%s", argv[0]);
 
 	/* First copy bigram array to stdout. */
-	if (fgets(bigrams, BGBUFSIZE + 1, fp) == NULL) {
+	if (fgets((char *)bigrams, BGBUFSIZE + 1, fp) == NULL) {
 		if (!feof(fp) || ferror(fp))
 			err(1, "get bigram array");
 	}
@@ -154,7 +155,7 @@
 	path = buf2;
 	oldcount = 0;
 
-	while (fgets(path, sizeof(buf2), stdin) != NULL) {
+	while (fgets((char *)path, sizeof(buf2), stdin) != NULL) {
 
 		/* skip empty lines */
 		if (*path == '\n')
--- src.orig/findutils/locate/locate/fastfind.c
+++ src.freebsd/findutils/locate/locate/fastfind.c
@@ -152,7 +152,7 @@
 	/* use a lookup table for case insensitive search */
 	u_char table[UCHAR_MAX + 1];
 
-	tolower_word(pathpart);
+	tolower_word((u_char *)pathpart);
 #endif /* FF_ICASE*/
 
 	/* init bigram table */
@@ -169,8 +169,8 @@
 #endif /* FF_MMAP */
 
 	/* find optimal (last) char for searching */
-	for (p = pathpart; *p != '\0'; p++)
-		if (strchr(LOCATE_REG, *p) != NULL)
+	for (p = (u_char *)pathpart; *p != '\0'; p++)
+		if (strchr(LOCATE_REG, *(char *)p) != NULL)
 			break;
 
 	if (*p == '\0')
@@ -178,8 +178,8 @@
 	else
 		globflag = 1;
 
-	p = pathpart;
-	patend = patprep(p);
+	p = (u_char *)pathpart;
+	patend = (u_char *)patprep(pathpart);
 	cc = *patend;
 
 #ifdef FF_ICASE
@@ -209,7 +209,7 @@
 		/* go forward or backward */
 		if (c == SWITCH) { /* big step, an integer */
 #ifdef FF_MMAP
-			if (len < sizeof(int))
+			if (len < (off_t)sizeof(int))
 				errx(1, "corrupted database: %s", database);
 
 			count += getwm(paddr) - OFFSET;
@@ -318,9 +318,9 @@
 					found = 1;
 					if (!globflag || 
 #ifndef FF_ICASE
-					    !fnmatch(pathpart, path, 0)) 
+					    !fnmatch(pathpart, (char *)path, 0)) 
 #else 
-					    !fnmatch(pathpart, path, 
+					    !fnmatch(pathpart, (char *)path, 
 						     FNM_CASEFOLD))
 #endif /* !FF_ICASE */						
 					{
@@ -328,7 +328,7 @@
 							counter++;
 						else if (f_limit) {
 							counter++;
-							if (f_limit >= counter)
+							if (f_limit >= (int)counter)
 								(void)printf("%s%c",path,separator);
 							else 
 								errx(0, "[show only %ld lines]", counter - 1);
--- src.orig/findutils/locate/locate/locate.1
+++ src.freebsd/findutils/locate/locate/locate.1
@@ -187,13 +187,11 @@
 option was specified.
 .El
 .Sh FILES
-.Bl -tag -width /etc/periodic/weekly/310.locate -compact
+.Bl -tag -width /usr/libexec/locate.updatedb -compact
 .It Pa /var/db/locate.database
 locate database
 .It Pa /usr/libexec/locate.updatedb
 Script to update the locate database
-.It Pa /etc/periodic/weekly/310.locate
-Script that starts the database rebuild
 .El
 .Sh SEE ALSO
 .Xr find 1 ,
--- src.orig/findutils/locate/locate/locate.c
+++ src.freebsd/findutils/locate/locate/locate.c
@@ -77,6 +77,7 @@
  */
 
 #include <sys/param.h>
+#include <sys/types.h>
 #include <ctype.h>
 #include <err.h>
 #include <fnmatch.h>
--- src.orig/findutils/locate/locate/locate.rc
+++ src.freebsd/findutils/locate/locate/locate.rc
@@ -15,7 +15,7 @@
 #SEARCHPATHS="/"
 
 # paths unwanted in output
-#PRUNEPATHS="/tmp /usr/tmp /var/tmp /var/db/portsnap /var/db/freebsd-update"
+#PRUNEPATHS="/tmp /var/tmp"
 
 # directories unwanted in output
 #PRUNEDIRS=".zfs"
@@ -24,9 +24,10 @@
 # and if the SEARCHPATHS starts in such a filesystem locate will build
 # an empty database.
 #
-# the default list contains all local file systems that are not synthetic,
-# loopback mounts, or read-only, according to lsvfs.
+# the default list contains filesystems known to be read-write,
+# non-virtual on-disk file systems; it is not possible to compute
+# this list reliably, so change it to your liking
 #
-# be careful if you add 'nfs' or other network file system types or file
-# systems that generally reside on slow or removable devices like cd9660
-#FILESYSTEMS="ufs ext2fs zfs xfs"
+# be careful if you add NFS or other network file system types or file
+# systems that generally reside on slow or removable devices (e.g. iso9660)
+#FILESYSTEMS="ext2 ext3 ext4 xfs vfat exfat ntfs ntfs3 f2fs zfs btrfs reiserfs reiser4 jfs"
--- src.orig/findutils/locate/locate/locate.updatedb.8
+++ src.freebsd/findutils/locate/locate/locate.updatedb.8
@@ -41,9 +41,6 @@
 .Nm
 utility updates the database used by
 .Xr locate 1 .
-It is typically run once a week by the
-.Pa /etc/periodic/weekly/310.locate
-script.
 .Pp
 The contents of the newly built database can be controlled by the
 .Pa /etc/locate.rc
@@ -61,8 +58,7 @@
 the configuration file
 .El
 .Sh SEE ALSO
-.Xr locate 1 ,
-.Xr periodic 8
+.Xr locate 1
 .Rs
 .%A Woods, James A.
 .%D 1983
--- src.orig/findutils/locate/locate/updatedb.sh
+++ src.freebsd/findutils/locate/locate/updatedb.sh
@@ -52,11 +52,10 @@
 : ${mklocatedb:=locate.mklocatedb}	 # make locate database program
 : ${FCODES:=/var/db/locate.database}	 # the database
 : ${SEARCHPATHS="/"}		# directories to be put in the database
-: ${PRUNEPATHS="/tmp /usr/tmp /var/tmp /var/db/portsnap /var/db/freebsd-update"} # unwanted directories
+: ${PRUNEPATHS="/tmp /var/tmp"} # unwanted directories
 : ${PRUNEDIRS=".zfs"}	# unwanted directories, in any parent
-: ${FILESYSTEMS="$(lsvfs | tail -n +3 | \
-	egrep -vw "loopback|network|synthetic|read-only|0" | \
-	cut -d " " -f1)"}		# allowed filesystems
+# allowed filesystems
+: ${FILESYSTEMS="ext2 ext3 ext4 xfs vfat exfat ntfs ntfs3 f2fs zfs btrfs reiserfs reiser4 jfs"}
 : ${find:=find}
 
 if [ -z "$SEARCHPATHS" ]; then
--- src.orig/findutils/locate/locate/util.c
+++ src.freebsd/findutils/locate/locate/util.c
@@ -37,6 +37,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <err.h>
+#include <sys/types.h>
 #include <arpa/inet.h>
 #include <stdio.h>
 #include <sys/stat.h>
--- src.orig/findutils/xargs/strnsubst.c
+++ src.freebsd/findutils/xargs/strnsubst.c
@@ -14,6 +14,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <stdint.h>
 
 bool	strnsubst(char **, const char *, const char *, size_t);
 
--- src.orig/findutils/xargs/xargs.c
+++ src.freebsd/findutils/xargs/xargs.c
@@ -49,8 +49,8 @@
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <sys/time.h>
-#include <sys/limits.h>
 #include <sys/resource.h>
+#include <limits.h>
 #include <err.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -92,7 +92,7 @@
 static long eoflen;
 static int count, insingle, indouble, oflag, pflag, tflag, Rflag, rval, zflag;
 static int cnt, Iflag, jfound, Lflag, Sflag, wasquoted, xflag;
-static int curprocs, maxprocs;
+static long unsigned int curprocs, maxprocs;
 static pid_t *childpids;
 
 static volatile int childerr;
@@ -607,6 +607,7 @@
 	case -1:
 		warn("vfork");
 		xexit(*argv, 1);
+		break;
 	case 0:
 		if (oflag) {
 			if ((fd = open(_PATH_TTY, O_RDONLY)) == -1)
@@ -701,7 +702,7 @@
 static void
 pids_init(void)
 {
-	int i;
+	long unsigned int i;
 
 	if ((childpids = malloc(maxprocs * sizeof(*childpids))) == NULL)
 		errx(1, "malloc failed");
@@ -760,7 +761,7 @@
 static int
 findslot(pid_t pid)
 {
-	int slot;
+	long unsigned int slot;
 
 	for (slot = 0; slot < maxprocs; slot++)
 		if (childpids[slot] == pid)
@@ -782,22 +783,22 @@
 prompt(void)
 {
 	regex_t cre;
-	size_t rsize;
+	size_t rsize = 0;
 	int match;
-	char *response;
+	char *response = NULL;
 	FILE *ttyfp;
 
 	if ((ttyfp = fopen(_PATH_TTY, "r")) == NULL)
 		return (2);	/* Indicate that the TTY failed to open. */
 	(void)fprintf(stderr, "?...");
 	(void)fflush(stderr);
-	if ((response = fgetln(ttyfp, &rsize)) == NULL ||
+	if (getline(&response, &rsize, ttyfp) < 0 ||
 	    regcomp(&cre, nl_langinfo(YESEXPR), REG_EXTENDED) != 0) {
 		(void)fclose(ttyfp);
 		return (0);
 	}
-	response[rsize - 1] = '\0';
 	match = regexec(&cre, response, 0, NULL, 0);
+	free(response);
 	(void)fclose(ttyfp);
 	regfree(&cre);
 	return (match == 0);
--- src.orig/grep/file.c
+++ src.freebsd/grep/file.c
@@ -40,6 +40,7 @@
 #include <err.h>
 #include <errno.h>
 #include <fcntl.h>
+#include <limits.h>
 #include <stddef.h>
 #include <stdlib.h>
 #include <string.h>
@@ -49,6 +50,10 @@
 
 #include "grep.h"
 
+#ifndef OFF_MAX
+#define OFF_MAX ((off_t)(((1ULL << (sizeof(off_t) * CHAR_BIT - 2)) - 1) * 2 + 1))
+#endif
+
 #define	MAXBUFSIZ	(32 * 1024)
 #define	LNBUFBUMP	80
 
@@ -188,7 +193,7 @@
 		if (fstat(f->fd, &st) == -1 || !S_ISREG(st.st_mode))
 			filebehave = FILE_STDIO;
 		else {
-			int flags = MAP_PRIVATE | MAP_NOCORE | MAP_NOSYNC;
+			int flags = MAP_PRIVATE;
 #ifdef MAP_PREFAULT_READ
 			flags |= MAP_PREFAULT_READ;
 #endif
--- src.orig/grep/grep.c
+++ src.freebsd/grep/grep.c
@@ -64,7 +64,7 @@
 
 /* Flags passed to regcomp() and regexec() */
 int		 cflags = REG_NOSUB | REG_NEWLINE;
-int		 eflags = REG_STARTEND;
+int		 eflags = 0;
 
 bool		 matchall;
 
--- src.orig/grep/grep.h
+++ src.freebsd/grep/grep.h
@@ -30,12 +30,10 @@
  * SUCH DAMAGE.
  */
 
-#include <bzlib.h>
 #include <limits.h>
 #include <regex.h>
 #include <stdbool.h>
 #include <stdio.h>
-#include <zlib.h>
 
 extern const char		*errstr[];
 
--- src.orig/grep/util.c
+++ src.freebsd/grep/util.c
@@ -466,6 +466,30 @@
 
 #define iswword(x)	(iswalnum((x)) || (x) == L'_')
 
+#ifndef REG_STARTEND
+static int regexec_startend(
+    const regex_t *restrict preg, char *restrict str, size_t nmatch,
+    regmatch_t pmatch[restrict], int eflags
+) {
+	regoff_t so = pmatch[0].rm_so;
+	regoff_t eo = pmatch[0].rm_eo;
+	char old = str[eo];
+	str[eo] = '\0';
+	int ret = regexec(preg, str + so, nmatch, pmatch, eflags);
+	str[eo] = old;
+	pmatch[0].rm_so += so;
+	pmatch[0].rm_eo += so;
+	return ret;
+}
+#else
+static int regexec_startend(
+    const regex_t *restrict preg, const char *restrict str, size_t nmatch,
+    regmatch_t pmatch[restrict], int eflags
+) {
+	return regexec(preg, str, nmatch, pmatch, eflags | REG_STARTEND);
+}
+#endif
+
 /*
  * Processes a line comparing it with the specified patterns.  Each pattern
  * is looped to be compared along with the full string, saving each and every
@@ -533,7 +557,7 @@
 				r = litexec(&pattern[i], pc->ln.dat, 1, &pmatch);
 			else
 #endif
-			r = regexec(&r_pattern[i], pc->ln.dat, 1, &pmatch,
+			r = regexec_startend(&r_pattern[i], pc->ln.dat, 1, &pmatch,
 			    leflags);
 			if (r != 0)
 				continue;
--- src.orig/gzip/gzip.c
+++ src.freebsd/gzip/gzip.c
@@ -48,13 +48,21 @@
  *	- make bzip2/compress -v/-t/-l support work as well as possible
  */
 
-#include <sys/endian.h>
+static inline unsigned le32dec(const void *s) {
+	const unsigned char *p = (const unsigned char *)s;
+	return (((unsigned)p[3] << 24) | (p[2] << 16) | (p[1] << 8) | p[0]);
+}
+
+#define nitems(x) (sizeof((x)) / sizeof((x)[0]))
+
 #include <sys/param.h>
 #include <sys/stat.h>
 #include <sys/time.h>
+#include <sys/types.h>
 
 #include <inttypes.h>
 #include <unistd.h>
+#include <signal.h>
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
@@ -367,7 +375,7 @@
 			break;
 		case 'V':
 			display_version();
-			/* NOTREACHED */
+			break; /* NOTREACHED */
 		case 'a':
 			fprintf(stderr, "%s: option --ascii ignored on this system\n", progname);
 			break;
@@ -379,7 +387,7 @@
 			break;
 		case 'L':
 			display_license();
-			/* NOT REACHED */
+			break; /* NOT REACHED */
 		case 'N':
 			nflag = 0;
 			Nflag = 1;
@@ -1100,9 +1108,11 @@
 	if (futimens(fd, times) < 0)
 		maybe_warn("couldn't futimens: %s", file);
 
+#if 0
 	/* only try flags if they exist already */
         if (sb.st_flags != 0 && fchflags(fd, sb.st_flags) < 0)
 		maybe_warn("couldn't fchflags: %s", file);
+#endif
 }
 
 /* what sort of file is this? */
--- src.orig/gzip/unxz.c
+++ src.freebsd/gzip/unxz.c
@@ -36,6 +36,7 @@
 #include <stdio.h>
 #include <unistd.h>
 #include <lzma.h>
+#include <sys/stat.h>
 
 static off_t
 unxz(int i, int o, char *pre, size_t prelen, off_t *bytes_in)
@@ -80,7 +81,7 @@
 			switch (strm.avail_in) {
 			case (size_t)-1:
 				maybe_err("read failed");
-				/*NOTREACHED*/
+				break; /*NOTREACHED*/
 			case 0:
 				action = LZMA_FINISH;
 				break;
--- src.orig/gzip/zuncompress.c
+++ src.freebsd/gzip/zuncompress.c
@@ -39,8 +39,13 @@
 
 /* This file is #included by gzip.c */
 
-static int	zread(void *, char *, int);
+static ssize_t
+zread(void *cookie, char *rbp, size_t num);
 
+#ifndef EFTYPE
+#define EFTYPE EINVAL
+#endif
+
 #define	tab_prefixof(i)	(zs->zs_codetab[i])
 #define	tab_suffixof(i)	((char_type *)(zs->zs_htab))[i]
 #define	de_stack	((char_type *)&tab_suffixof(1 << BITS))
@@ -173,6 +178,7 @@
 zdopen(int fd)
 {
 	struct s_zstate *zs;
+	cookie_io_functions_t zfuncs;
 
 	if ((zs = calloc(1, sizeof(struct s_zstate))) == NULL)
 		return (NULL);
@@ -200,7 +206,12 @@
 		return NULL;
 	}
 
-	return funopen(zs, zread, NULL, NULL, zclose);
+	zfuncs.read = zread;
+	zfuncs.write = NULL;
+	zfuncs.seek = NULL;
+	zfuncs.close = zclose;
+
+	return fopencookie(zs, "r", zfuncs);
 }
 
 /*
@@ -209,8 +220,8 @@
  * compressed file.  The tables used herein are shared with those of the
  * compress() routine.  See the definitions above.
  */
-static int
-zread(void *cookie, char *rbp, int num)
+static ssize_t
+zread(void *cookie, char *rbp, size_t num)
 {
 	u_int count, i;
 	struct s_zstate *zs;
--- src.orig/libfetch/common.c
+++ src.freebsd/libfetch/common.c
@@ -135,10 +135,7 @@
 	{ SOCKS5_ERR_BAD_PORT,		FETCH_ABORT,	"SOCKS5: Bad port" }
 };
 
-/* End-of-Line */
-static const char ENDL[2] = "\r\n";
 
-
 /*** Error-reporting functions ***********************************************/
 
 /*
@@ -176,8 +173,12 @@
 	case EPERM:
 	case EACCES:
 	case EROFS:
+#ifdef EAUTH
 	case EAUTH:
+#endif
+#ifdef ENEEDAUTH
 	case ENEEDAUTH:
+#endif
 		fetchLastErrCode = FETCH_AUTH;
 		break;
 	case ENOENT:
@@ -278,13 +279,11 @@
 fetch_reopen(int sd)
 {
 	conn_t *conn;
-	int opt = 1;
 
 	/* allocate and fill connection structure */
 	if ((conn = calloc(1, sizeof(*conn))) == NULL)
 		return (NULL);
 	fcntl(sd, F_SETFD, FD_CLOEXEC);
-	setsockopt(sd, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof opt);
 	conn->sd = sd;
 	++conn->ref;
 	return (conn);
@@ -408,15 +407,16 @@
 	 * Largest FQDN (256) + one byte size (1) +
 	 * Port (2)
 	 */
-	unsigned char buf[BUFF_SIZE];
+	char buf[BUFF_SIZE];
 	unsigned char *ptr;
+	ptrdiff_t dif;
 	int ret = 1;
 
 	if (verbose)
 		fetch_info("Initializing SOCKS5 connection: %s:%d", host, port);
 
 	/* Connection initialization */
-	ptr = buf;
+	ptr = (unsigned char *)buf;
 	*ptr++ = SOCKS_VERSION_5;
 	*ptr++ = SOCKS_CONNECTION;
 	*ptr++ = SOCKS_RSV;
@@ -432,7 +432,7 @@
 		goto fail;
 	}
 
-	ptr = buf;
+	ptr = (unsigned char *)buf;
 	if (ptr[0] != SOCKS_VERSION_5) {
 		ret = SOCKS5_ERR_VER5_ONLY;
 		goto fail;
@@ -464,7 +464,8 @@
 	*ptr++ = port & 0x00ff;
 	*ptr++ = (port & 0xff00) >> 8;
 
-	if (fetch_write(conn, buf, ptr - buf) != ptr - buf) {
+	dif = ptr - (unsigned char *)buf;
+	if (fetch_write(conn, buf, dif) != dif) {
 		ret = SOCKS5_ERR_REQUEST;
 		goto fail;
 	}
@@ -475,7 +476,7 @@
 		goto fail;
 	}
 
-	ptr = buf;
+	ptr = (unsigned char *)buf;
 	if (*ptr++ != SOCKS_VERSION_5) {
 		ret = SOCKS5_ERR_NON_VER5_RESP;
 		goto fail;
@@ -702,6 +703,7 @@
 }
 
 #ifdef WITH_SSL
+#if 0
 /*
  * Convert characters A-Z to lowercase (intentionally avoid any locale
  * specific conversions).
@@ -1030,6 +1032,7 @@
 		GENERAL_NAMES_free(altnames);
 	return (ret);
 }
+#endif
 
 /*
  * Configure transport security layer based on environment.
@@ -1222,7 +1225,9 @@
 	if (getenv("SSL_NO_VERIFY_HOSTNAME") == NULL) {
 		if (verbose)
 			fetch_info("Verify hostname");
-		if (!fetch_ssl_verify_hname(conn->ssl_cert, URL->host)) {
+		if (X509_check_host(conn->ssl_cert, URL->host, strlen(URL->host),
+				X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS,
+				NULL) != 1) {
 			fprintf(stderr,
 			    "SSL certificate subject doesn't match host %s\n",
 			    URL->host);
@@ -1310,7 +1315,7 @@
 		timeout.tv_sec += fetchTimeout;
 	}
 
-	deltams = INFTIM;
+	deltams = -1;
 	memset(&pfd, 0, sizeof pfd);
 	pfd.fd = conn->sd;
 	pfd.events = POLLIN | POLLERR;
@@ -1420,27 +1425,12 @@
 	return (0);
 }
 
-
 /*
  * Write to a connection w/ timeout
  */
 ssize_t
 fetch_write(conn_t *conn, const char *buf, size_t len)
 {
-	struct iovec iov;
-
-	iov.iov_base = __DECONST(char *, buf);
-	iov.iov_len = len;
-	return fetch_writev(conn, &iov, 1);
-}
-
-/*
- * Write a vector to a connection w/ timeout
- * Note: can modify the iovec.
- */
-ssize_t
-fetch_writev(conn_t *conn, struct iovec *iov, int iovcnt)
-{
 	struct timeval now, timeout, delta;
 	struct pollfd pfd;
 	ssize_t wlen, total;
@@ -1455,7 +1445,7 @@
 	}
 
 	total = 0;
-	while (iovcnt > 0) {
+	while (len) {
 		while (fetchTimeout && pfd.revents == 0) {
 			gettimeofday(&now, NULL);
 			if (!timercmp(&timeout, &now, >)) {
@@ -1480,11 +1470,10 @@
 		errno = 0;
 #ifdef WITH_SSL
 		if (conn->ssl != NULL)
-			wlen = SSL_write(conn->ssl,
-			    iov->iov_base, iov->iov_len);
+			wlen = SSL_write(conn->ssl, buf, len);
 		else
 #endif
-			wlen = writev(conn->sd, iov, iovcnt);
+			wlen = send(conn->sd, buf, len, MSG_NOSIGNAL);
 		if (wlen == 0) {
 			/* we consider a short write a failure */
 			/* XXX perhaps we shouldn't in the SSL case */
@@ -1498,20 +1487,13 @@
 			return (-1);
 		}
 		total += wlen;
-		while (iovcnt > 0 && wlen >= (ssize_t)iov->iov_len) {
-			wlen -= iov->iov_len;
-			iov++;
-			iovcnt--;
-		}
-		if (iovcnt > 0) {
-			iov->iov_len -= wlen;
-			iov->iov_base = __DECONST(char *, iov->iov_base) + wlen;
-		}
+		buf += wlen;
+		len -= wlen;
 	}
 	return (total);
 }
 
-
+#if 0
 /*
  * Write a line of text to a connection w/ timeout
  */
@@ -1534,6 +1516,7 @@
 		return (-1);
 	return (0);
 }
+#endif
 
 
 /*
--- src.orig/libfetch/common.h
+++ src.freebsd/libfetch/common.h
@@ -44,6 +44,10 @@
 #include <openssl/err.h>
 #endif
 
+#ifndef IPPORT_MAX
+# define IPPORT_MAX 65535
+#endif
+
 /* Connection */
 typedef struct fetchconn conn_t;
 struct fetchconn {
@@ -100,9 +104,6 @@
 #define SOCKS_COMMAND_NOT_SUPPORTED	0x07
 #define SOCKS_ADDRESS_NOT_SUPPORTED	0x08
 
-/* for fetch_writev */
-struct iovec;
-
 void		 fetch_seterr(struct fetcherr *, int);
 void		 fetch_syserr(void);
 void		 fetch_info(const char *, ...) __printflike(1, 2);
@@ -123,8 +124,6 @@
 ssize_t		 fetch_read(conn_t *, char *, size_t);
 int		 fetch_getln(conn_t *);
 ssize_t		 fetch_write(conn_t *, const char *, size_t);
-ssize_t		 fetch_writev(conn_t *, struct iovec *, int);
-int		 fetch_putln(conn_t *, const char *, size_t);
 int		 fetch_close(conn_t *);
 int		 fetch_add_entry(struct url_ent **, int *, int *,
 		     const char *, struct url_stat *);
--- src.orig/libfetch/ftp.c
+++ src.freebsd/libfetch/ftp.c
@@ -77,6 +77,10 @@
 #include "common.h"
 #include "ftperr.h"
 
+#ifndef MAXLOGNAME
+#define MAXLOGNAME LOGIN_NAME_MAX
+#endif
+
 #define FTP_ANONYMOUS_USER	"anonymous"
 
 #define FTP_CONNECTION_ALREADY_OPEN	125
@@ -133,7 +137,9 @@
 	sin4->sin_addr.s_addr = addr;
 	sin4->sin_port = port;
 	sin4->sin_family = AF_INET;
+#ifdef HAVE_SA_LEN
 	sin4->sin_len = sizeof(struct sockaddr_in);
+#endif
 }
 
 /*
@@ -176,7 +182,7 @@
  * Send a command and check reply
  */
 static int
-ftp_cmd(conn_t *conn, const char *fmt, ...)
+ftp_cmdf(conn_t *conn, const char *fmt, ...)
 {
 	va_list ap;
 	size_t len;
@@ -193,7 +199,7 @@
 		return (-1);
 	}
 
-	r = fetch_putln(conn, msg, len);
+	r = fetch_write(conn, msg, len);
 	free(msg);
 
 	if (r == -1) {
@@ -204,6 +210,8 @@
 	return (ftp_chkerr(conn));
 }
 
+#define ftp_cmd(conn, fmt, ...) ftp_cmdf(conn, fmt "\r\n", ## __VA_ARGS__)
+
 /*
  * Return a pointer to the filename part of a path
  */
@@ -380,9 +388,10 @@
 	case 'A':
 		break;
 	case 'd':
-		type = 'D';
 	case 'D':
+		type = 'D';
 		/* can't handle yet */
+		return (FTP_PROTOCOL_ERROR);
 	default:
 		return (FTP_PROTOCOL_ERROR);
 	}
@@ -483,16 +492,16 @@
 	int	 err;		/* Error code */
 };
 
-static int	 ftp_readfn(void *, char *, int);
-static int	 ftp_writefn(void *, const char *, int);
-static fpos_t	 ftp_seekfn(void *, fpos_t, int);
+static ssize_t	 ftp_readfn(void *, char *, size_t);
+static ssize_t	 ftp_writefn(void *, const char *, size_t);
+static int	 ftp_seekfn(void *, off_t *, int);
 static int	 ftp_closefn(void *);
 
-static int
-ftp_readfn(void *v, char *buf, int len)
+static ssize_t
+ftp_readfn(void *v, char *buf, size_t len)
 {
 	struct ftpio *io;
-	int r;
+	ssize_t r;
 
 	io = (struct ftpio *)v;
 	if (io == NULL) {
@@ -521,11 +530,11 @@
 	return (-1);
 }
 
-static int
-ftp_writefn(void *v, const char *buf, int len)
+static ssize_t
+ftp_writefn(void *v, const char *buf, size_t len)
 {
 	struct ftpio *io;
-	int w;
+	ssize_t w;
 
 	io = (struct ftpio *)v;
 	if (io == NULL) {
@@ -548,8 +557,8 @@
 	return (-1);
 }
 
-static fpos_t
-ftp_seekfn(void *v, fpos_t pos __unused, int whence __unused)
+static int
+ftp_seekfn(void *v, off_t *pos __unused, int whence __unused)
 {
 	struct ftpio *io;
 
@@ -596,6 +605,7 @@
 {
 	struct ftpio *io;
 	FILE *f;
+	cookie_io_functions_t iof;
 
 	if (cconn == NULL || dconn == NULL)
 		return (NULL);
@@ -605,7 +615,11 @@
 	io->dconn = dconn;
 	io->dir = mode;
 	io->eof = io->err = 0;
-	f = funopen(io, ftp_readfn, ftp_writefn, ftp_seekfn, ftp_closefn);
+	iof.read = ftp_readfn;
+	iof.write = ftp_writefn;
+	iof.seek = ftp_seekfn;
+	iof.close = ftp_closefn;
+	f = fopencookie(io, "w+", iof);
 	if (f == NULL)
 		free(io);
 	return (f);
@@ -624,14 +638,19 @@
 	const char *bindaddr;
 	const char *filename;
 	int filenamelen, type;
-	int low, pasv, verbose;
+#if defined(IPV6_PORTRANGE) || defined(IP_PORTRANGE)
+	int low;
+#endif
+	int pasv, verbose;
 	int e, sd = -1;
 	socklen_t l;
 	char *s;
 	FILE *df;
 
 	/* check flags */
+#if defined(IPV6_PORTRANGE) || defined(IP_PORTRANGE)
 	low = CHECK_FLAG('l');
+#endif
 	pasv = CHECK_FLAG('p') || !CHECK_FLAG('P');
 	verbose = CHECK_FLAG('v');
 
@@ -772,7 +791,7 @@
 		if (bindaddr != NULL && *bindaddr != '\0' &&
 		    (e = fetch_bind(sd, sa.ss_family, bindaddr)) != 0)
 			goto ouch;
-		if (connect(sd, (struct sockaddr *)&sa, sa.ss_len) == -1)
+		if (connect(sd, (struct sockaddr *)&sa, l) == -1)
 			goto sysouch;
 
 		/* make the server initiate the transfer */
@@ -785,7 +804,10 @@
 	} else {
 		u_int32_t a;
 		u_short p;
-		int arg, d;
+#if defined(IPV6_PORTRANGE) || defined(IP_PORTRANGE)
+		int arg;
+#endif
+		int d;
 		char *ap;
 		char hname[INET6_ADDRSTRLEN];
 
@@ -801,15 +823,17 @@
 			break;
 		case AF_INET:
 			((struct sockaddr_in *)&sa)->sin_port = 0;
+#ifdef IP_PORTRANGE
 			arg = low ? IP_PORTRANGE_DEFAULT : IP_PORTRANGE_HIGH;
 			if (setsockopt(sd, IPPROTO_IP, IP_PORTRANGE,
 				(char *)&arg, sizeof(arg)) == -1)
 				goto sysouch;
+#endif
 			break;
 		}
 		if (verbose)
 			fetch_info("binding data socket");
-		if (bind(sd, (struct sockaddr *)&sa, sa.ss_len) == -1)
+		if (bind(sd, (struct sockaddr *)&sa, l) == -1)
 			goto sysouch;
 		if (listen(sd, 1) == -1)
 			goto sysouch;
@@ -832,7 +856,7 @@
 			e = -1;
 			sin6 = (struct sockaddr_in6 *)&sa;
 			sin6->sin6_scope_id = 0;
-			if (getnameinfo((struct sockaddr *)&sa, sa.ss_len,
+			if (getnameinfo((struct sockaddr *)&sa, l,
 				hname, sizeof(hname),
 				NULL, 0, NI_NUMERICHOST) == 0) {
 				e = ftp_cmd(conn, "EPRT |%d|%s|%d|", 2, hname,
--- src.orig/libfetch/gen_errors.sh
+++ src.freebsd/libfetch/gen_errors.sh
@@ -0,0 +1,12 @@
+#!/bin/sh
+
+ERRTYPE=$1
+ERRLIST=$2
+ERRTYPE_U=$(echo $ERRTYPE|tr '[:lower:]' '[:upper:]')
+
+echo "static struct fetcherr ${ERRTYPE}_errlist[] = {"
+cat "$ERRLIST" | grep -v "^#" | sort | while read NUM CAT STRING; do
+    echo "    {${NUM}, FETCH_${CAT}, \"${STRING}\"},"
+done
+echo "    {-1, FETCH_UNKNOWN, \"Unknown ${ERRTYPE_U} error\"}"
+echo "};"
--- src.orig/libfetch/http.c
+++ src.freebsd/libfetch/http.c
@@ -82,7 +82,7 @@
 #include <openssl/md5.h>
 #define MD5Init(c) MD5_Init(c)
 #define MD5Update(c, data, len) MD5_Update(c, data, len)
-#define MD5Final(md, c) MD5_Final(md, c)
+#define MD5Final(md, c) MD5_Final((unsigned char *)md, c)
 #else
 #include <md5.h>
 #endif
@@ -267,8 +267,8 @@
 /*
  * Read function
  */
-static int
-http_readfn(void *v, char *buf, int len)
+static ssize_t
+http_readfn(void *v, char *buf, size_t len)
 {
 	struct httpio *io = (struct httpio *)v;
 	int rlen;
@@ -290,7 +290,7 @@
 	}
 
 	rlen = io->buflen - io->bufpos;
-	if (len < rlen)
+	if (rlen > 0 && len < (size_t)rlen)
 		rlen = len;
 	memcpy(buf, io->buf + io->bufpos, rlen);
 	io->bufpos += rlen;
@@ -300,8 +300,8 @@
 /*
  * Write function
  */
-static int
-http_writefn(void *v, const char *buf, int len)
+static ssize_t
+http_writefn(void *v, const char *buf, size_t len)
 {
 	struct httpio *io = (struct httpio *)v;
 
@@ -332,6 +332,7 @@
 {
 	struct httpio *io;
 	FILE *f;
+	cookie_io_functions_t iof;
 
 	if ((io = calloc(1, sizeof(*io))) == NULL) {
 		fetch_syserr();
@@ -339,7 +340,11 @@
 	}
 	io->conn = conn;
 	io->chunked = chunked;
-	f = funopen(io, http_readfn, http_writefn, NULL, http_closefn);
+	iof.read = http_readfn;
+	iof.write = http_writefn;
+	iof.seek = NULL;
+	iof.close = http_closefn;
+	f = fopencookie(io, "w+", iof);
 	if (f == NULL) {
 		fetch_syserr();
 		free(io);
@@ -387,7 +392,7 @@
  * Send a formatted line; optionally echo to terminal
  */
 static int
-http_cmd(conn_t *conn, const char *fmt, ...)
+http_cmdf(conn_t *conn, const char *fmt, ...)
 {
 	va_list ap;
 	size_t len;
@@ -404,7 +409,7 @@
 		return (-1);
 	}
 
-	r = fetch_putln(conn, msg, len);
+	r = fetch_write(conn, msg, len);
 	free(msg);
 
 	if (r == -1) {
@@ -415,6 +420,8 @@
 	return (0);
 }
 
+#define http_cmd(conn, fmt, ...) http_cmdf(conn, fmt "\r\n", ## __VA_ARGS__)
+
 /*
  * Get and parse status line
  */
@@ -1478,13 +1485,17 @@
 	if (strcmp(URL->scheme, SCHEME_HTTPS) == 0 &&
 	    fetch_ssl(conn, URL, verbose) == -1) {
 		/* grrr */
+#ifdef EAUTH
 		errno = EAUTH;
+#else
+		errno = EPERM;
+#endif
 		fetch_syserr();
 		goto ouch;
 	}
 
 	val = 1;
-	setsockopt(conn->sd, IPPROTO_TCP, TCP_NOPUSH, &val, sizeof(val));
+	setsockopt(conn->sd, IPPROTO_TCP, TCP_CORK, &val, sizeof(val));
 
 	clean_http_headerbuf(&headerbuf);
 	return (conn);
@@ -1788,7 +1799,7 @@
 		 * options to force the pending data to be written.
 		 */
 		val = 0;
-		setsockopt(conn->sd, IPPROTO_TCP, TCP_NOPUSH, &val,
+		setsockopt(conn->sd, IPPROTO_TCP, TCP_CORK, &val,
 			   sizeof(val));
 		val = 1;
 		setsockopt(conn->sd, IPPROTO_TCP, TCP_NODELAY, &val,
--- src.orig/libmp/mpasbn.c
+++ src.freebsd/libmp/mpasbn.c
@@ -91,7 +91,7 @@
 } while (0)
 
 static void _bnerr(const char *);
-static MINT *_dtom(const char *, const char *);
+/*static MINT *_dtom(const char *, const char *);*/
 static MINT *_itom(const char *, short);
 static void _madd(const char *, const MINT *, const MINT *, MINT *);
 static int _mcmpa(const char *, const MINT *, const MINT *);
@@ -118,6 +118,7 @@
 	MPERRX(("%s: %s", msg, ERR_reason_error_string(ERR_get_error())));
 }
 
+#if 0
 /*
  * Convert a decimal string to an MINT.
  */
@@ -135,6 +136,7 @@
 	BN_ERRCHECK(msg, BN_dec2bn(&mp->bn, s));
 	return (mp);
 }
+#endif
 
 /*
  * Compute the greatest common divisor of mp1 and mp2; result goes in rmp.
@@ -277,6 +279,7 @@
 	_mfree("mfree", mp);
 }
 
+#if 0
 /*
  * Read an integer from standard input and stick the result in mp.
  * The input is treated to be in base 10.  This must be the silliest
@@ -304,6 +307,7 @@
 	_mfree("min", rmp);
 	free(nline);
 }
+#endif
 
 /*
  * Print the value of mp to standard output in base 10.  See blurb
--- src.orig/m4/parser.y
+++ src.freebsd/m4/parser.y
@@ -18,6 +18,7 @@
 
 #include <math.h>
 #include <stdint.h>
+#include <stdlib.h>
 #define YYSTYPE	int32_t
 extern int32_t end_result;
 extern int yylex(void);
--- src.orig/miscutils/calendar/calendar.1
+++ src.freebsd/miscutils/calendar/calendar.1
@@ -264,9 +264,9 @@
 .It Pa ~/.calendar/nomail
 do not send mail if this file exists.
 .It Pa /usr/share/calendar
-system wide location of calendar files provided as part of the base system.
+system wide location of calendar files.
 .It Pa /usr/local/share/calendar
-system wide location for calendar files provided by a port or package.
+alternate system wide location for calendar files.
 .El
 .Pp
 The order of precedence in searches for a calendar file is:
@@ -274,7 +274,7 @@
 Files of similar names are ignored in lower precedence locations.
 .Pp
 The following default calendar files are provided by the
-deskutils/calendar-data port.
+chimerautils-calendar-data package.
 .Pp
 .Bl -tag -width calendar.southafrica -compact
 .It Pa calendar.all
@@ -293,10 +293,6 @@
 Calendar of events in Croatia.
 .It Pa calendar.dutch
 Calendar of events in the Netherlands.
-.It Pa calendar.freebsd
-Birthdays of
-.Fx
-committers.
 .It Pa calendar.french
 Calendar of events in France.
 .It Pa calendar.german
--- src.orig/miscutils/calendar/calendar.c
+++ src.freebsd/miscutils/calendar/calendar.c
@@ -46,7 +46,6 @@
 #include <err.h>
 #include <errno.h>
 #include <locale.h>
-#include <login_cap.h>
 #include <langinfo.h>
 #include <pwd.h>
 #include <stdio.h>
@@ -220,12 +219,6 @@
 			if (pid < 0)
 				err(1, "fork");
 			if (pid == 0) {
-				login_cap_t *lc;
-
-				lc = login_getpwclass(pw);
-				if (setusercontext(lc, pw, pw->pw_uid,
-				    LOGIN_SETALL) != 0)
-					errx(1, "setusercontext");
 				setenv("HOME", pw->pw_dir, 1);
 				cal();
 				exit(0);
--- src.orig/miscutils/calendar/day.c
+++ src.freebsd/miscutils/calendar/day.c
@@ -35,7 +35,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <time.h>
+#include <time_bsd.h>
 
 #include "calendar.h"
 
@@ -63,7 +63,7 @@
 	localtime_r(&time2, tp2);
 	year2 = 1900 + tp2->tm_year;
 
-	strftime(dayname, sizeof(dayname) - 1, "%A, %d %B %Y", tp1);
+	strftime_bsd(dayname, sizeof(dayname) - 1, "%A, %d %B %Y", tp1);
 
 	setnnames();
 }
--- src.orig/miscutils/calendar/events.c
+++ src.freebsd/miscutils/calendar/events.c
@@ -34,6 +34,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <time_bsd.h>
 #ifdef WITH_ICONV
 #include <iconv.h>
 #include <errno.h>
@@ -202,8 +203,11 @@
 	char dbuf[80];
 	static int d_first;
 
-	d_first = (*nl_langinfo(D_MD_ORDER) == 'd');
+	d_first = 0;
+	if (strlen(nl_langinfo(D_FMT)) >= 2 && nl_langinfo(D_FMT)[1] == 'd')
+		d_first = 1;
 
+
 	while (walkthrough_dates(&e) != 0) {
 		if (e) {
 #ifdef DEBUG
@@ -214,7 +218,7 @@
 			tm.tm_mday = e->day;
 			tm.tm_mon = e->month - 1;
 			tm.tm_year = e->year - 1900;
-			(void)strftime(dbuf, sizeof(dbuf), d_first ? "%e %b" : "%b %e", &tm);
+			(void)strftime_bsd(dbuf, sizeof(dbuf), d_first ? "%e %b" : "%b %e", &tm);
 		}
 
 		/*
--- src.orig/miscutils/calendar/io.c
+++ src.freebsd/miscutils/calendar/io.c
@@ -118,9 +118,6 @@
 	FILE *fp;
 	char *home = getenv("HOME");
 	unsigned int i;
-	struct stat sb;
-	static bool warned = false;
-	static char calendarhome[MAXPATHLEN];
 
 	if (home == NULL || *home == '\0') {
 		warnx("Cannot get home directory");
@@ -133,29 +130,18 @@
 	}
 
 	for (i = 0; i < nitems(calendarHomes); i++) {
-		if (snprintf(calendarhome, sizeof (calendarhome), calendarHomes[i],
-			getlocalbase()) >= (int)sizeof (calendarhome))
+		if (chdir(calendarHomes[i]) != 0)
 			continue;
 
-		if (chdir(calendarhome) != 0)
-			continue;
-
 		if ((fp = fopen(file, "r")) != NULL) {
 			cal_home = home;
-			cal_dir = calendarhome;
+			cal_dir = calendarHomes[i];
 			cal_file = file;
 			return (fp);
 		}
 	}
 
 	warnx("can't open calendar file \"%s\"", file);
-	if (!warned) {
-		snprintf(path, sizeof(path), _PATH_INCLUDE_LOCAL, getlocalbase());
-		if (stat(path, &sb) != 0) {
-			warnx("calendar data files now provided by calendar-data pkg.");
-			warned = true;
-		}
-	}
 
 	return (NULL);
 }
--- src.orig/miscutils/calendar/locale.c
+++ src.freebsd/miscutils/calendar/locale.c
@@ -35,7 +35,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <time.h>
+#include <time_bsd.h>
 
 #include "calendar.h"
 
@@ -79,7 +79,7 @@
 	memset(&tm, 0, sizeof(struct tm));
 	for (i = 0; i < 7; i++) {
 		tm.tm_wday = i;
-		strftime(buf, sizeof(buf), "%a", &tm);
+		strftime_bsd(buf, sizeof(buf), "%a", &tm);
 		for (l = strlen(buf);
 		     l > 0 && isspace((unsigned char)buf[l - 1]);
 		     l--)
@@ -91,7 +91,7 @@
 			errx(1, "cannot allocate memory");
 		ndays[i].len = strlen(buf);
 
-		strftime(buf, sizeof(buf), "%A", &tm);
+		strftime_bsd(buf, sizeof(buf), "%A", &tm);
 		for (l = strlen(buf);
 		     l > 0 && isspace((unsigned char)buf[l - 1]);
 		     l--)
@@ -107,7 +107,7 @@
 	memset(&tm, 0, sizeof(struct tm));
 	for (i = 0; i < 12; i++) {
 		tm.tm_mon = i;
-		strftime(buf, sizeof(buf), "%b", &tm);
+		strftime_bsd(buf, sizeof(buf), "%b", &tm);
 		for (l = strlen(buf);
 		     l > 0 && isspace((unsigned char)buf[l - 1]);
 		     l--)
@@ -119,7 +119,7 @@
 			errx(1, "cannot allocate memory");
 		nmonths[i].len = strlen(buf);
 
-		strftime(buf, sizeof(buf), "%B", &tm);
+		strftime_bsd(buf, sizeof(buf), "%B", &tm);
 		for (l = strlen(buf);
 		     l > 0 && isspace((unsigned char)buf[l - 1]);
 		     l--)
--- src.orig/miscutils/calendar/pathnames.h
+++ src.freebsd/miscutils/calendar/pathnames.h
@@ -34,4 +34,4 @@
 #include <paths.h>
 
 #define	_PATH_INCLUDE	"/usr/share/calendar"
-#define	_PATH_INCLUDE_LOCAL	"%s/share/calendar"
+#define	_PATH_INCLUDE_LOCAL	"/usr/local/share/calendar"
--- src.orig/miscutils/col/col.c
+++ src.freebsd/miscutils/col/col.c
@@ -50,6 +50,7 @@
 #include <capsicum_helpers.h>
 #include <err.h>
 #include <errno.h>
+#include <limits.h>
 #include <locale.h>
 #include <stdio.h>
 #include <stdlib.h>
--- src.orig/miscutils/hexdump/conv.c
+++ src.freebsd/miscutils/hexdump/conv.c
@@ -102,7 +102,7 @@
 	if (odmode && MB_CUR_MAX > 1) {
 		oclen = 0;
 retry:
-		clen = mbrtowc(&wc, p, bufsize, &pr->mbstate);
+		clen = mbrtowc(&wc, (const char *)p, bufsize, &pr->mbstate);
 		if (clen == 0)
 			clen = 1;
 		else if (clen == (size_t)-1 || (clen == (size_t)-2 &&
--- src.orig/miscutils/hexdump/display.c
+++ src.freebsd/miscutils/hexdump/display.c
@@ -37,9 +37,9 @@
 #include <sys/cdefs.h>
 #include <sys/param.h>
 #include <sys/capsicum.h>
-#include <sys/conf.h>
 #include <sys/ioctl.h>
 #include <sys/stat.h>
+#include <sys/types.h>
 
 #include <capsicum_helpers.h>
 #include <ctype.h>
@@ -105,7 +105,7 @@
 		for (pr = endfu->nextpr; pr; pr = pr->nextpr)
 			switch(pr->flags) {
 			case F_ADDRESS:
-				(void)printf(pr->fmt, (quad_t)eaddress);
+				(void)printf(pr->fmt, (long long)eaddress);
 				break;
 			case F_TEXT:
 				(void)printf("%s", pr->fmt);
@@ -129,7 +129,7 @@
 
 	switch(pr->flags) {
 	case F_ADDRESS:
-		(void)printf(pr->fmt, (quad_t)address);
+		(void)printf(pr->fmt, (long long)address);
 		break;
 	case F_BPAD:
 		(void)printf(pr->fmt, "");
@@ -162,15 +162,15 @@
 	case F_INT:
 		switch(pr->bcnt) {
 		case 1:
-			(void)printf(pr->fmt, (quad_t)(signed char)*bp);
+			(void)printf(pr->fmt, (long long)(signed char)*bp);
 			break;
 		case 2:
 			bcopy(bp, &s2, sizeof(s2));
-			(void)printf(pr->fmt, (quad_t)s2);
+			(void)printf(pr->fmt, (long long)s2);
 			break;
 		case 4:
 			bcopy(bp, &s4, sizeof(s4));
-			(void)printf(pr->fmt, (quad_t)s4);
+			(void)printf(pr->fmt, (long long)s4);
 			break;
 		case 8:
 			bcopy(bp, &s8, sizeof(s8));
@@ -193,15 +193,15 @@
 	case F_UINT:
 		switch(pr->bcnt) {
 		case 1:
-			(void)printf(pr->fmt, (u_quad_t)*bp);
+			(void)printf(pr->fmt, (unsigned long long)*bp);
 			break;
 		case 2:
 			bcopy(bp, &u2, sizeof(u2));
-			(void)printf(pr->fmt, (u_quad_t)u2);
+			(void)printf(pr->fmt, (unsigned long long)u2);
 			break;
 		case 4:
 			bcopy(bp, &u4, sizeof(u4));
-			(void)printf(pr->fmt, (u_quad_t)u4);
+			(void)printf(pr->fmt, (unsigned long long)u4);
 			break;
 		case 8:
 			bcopy(bp, &u8, sizeof(u8));
@@ -391,7 +391,6 @@
 void
 doskip(const char *fname, int statok)
 {
-	int type;
 	struct stat sb;
 
 	if (statok) {
@@ -408,16 +407,8 @@
 		return;
 	}
 	if (S_ISCHR(sb.st_mode) || S_ISBLK(sb.st_mode)) {
-		if (ioctl(fileno(stdin), FIODTYPE, &type))
-			err(1, "%s", fname);
-		/*
-		 * Most tape drives don't support seeking,
-		 * yet fseek() would succeed.
-		 */
-		if (type & D_TAPE) {
-			noseek();
-			return;
-		}
+		noseek();
+		return;
 	}
 	if (fseeko(stdin, skip, SEEK_SET)) {
 		noseek();
--- src.orig/miscutils/hexdump/parse.c
+++ src.freebsd/miscutils/hexdump/parse.c
@@ -50,7 +50,7 @@
 void
 addfile(const char *name)
 {
-	unsigned char *p;
+	char *p;
 	FILE *fp;
 	int ch;
 	char buf[2048 + 1];
@@ -75,7 +75,7 @@
 void
 add(const char *fmt)
 {
-	unsigned const char *p, *savep;
+	const char *p, *savep;
 	static FS **nextfs;
 	FS *tfs;
 	FU *tfu, **nextfu;
@@ -151,7 +151,7 @@
 {
 	FU *fu;
 	int bcnt, cursize;
-	unsigned char *fmt;
+	char *fmt;
 	int prec;
 
 	/* figure out the data block size needed for each format unit */
@@ -208,8 +208,8 @@
 	enum { NOTOKAY, USEBCNT, USEPREC } sokay;
 	PR *pr, **nextpr;
 	FU *fu;
-	unsigned char *p1, *p2, *fmtp;
-	char savech, cs[3];
+	char *p1, *p2, *fmtp;
+	char savech, cs[4];
 	int nconv, prec;
 
 	prec = 0;
@@ -288,9 +288,10 @@
 				goto isint;
 			case 'o': case 'u': case 'x': case 'X':
 				pr->flags = F_UINT;
-isint:				cs[2] = '\0';
-				cs[1] = cs[0];
-				cs[0] = 'q';
+isint:				cs[3] = '\0';
+				cs[2] = cs[0];
+				cs[1] = 'l';
+				cs[0] = 'l';
 				switch(fu->bcnt) {
 				case 0: case 4:
 					pr->bcnt = 4;
@@ -335,6 +336,7 @@
 				switch(sokay) {
 				case NOTOKAY:
 					badsfmt();
+					return;
 				case USEBCNT:
 					pr->bcnt = fu->bcnt;
 					break;
@@ -355,9 +357,10 @@
 					++p2;
 					switch(p1[2]) {
 					case 'd': case 'o': case'x':
-						cs[0] = 'q';
-						cs[1] = p1[2];
-						cs[2] = '\0';
+						cs[0] = 'l';
+						cs[1] = 'l';
+						cs[2] = p1[2];
+						cs[3] = '\0';
 						break;
 					default:
 						p1[3] = '\0';
--- src.orig/miscutils/kill/kill.c
+++ src.freebsd/miscutils/kill/kill.c
@@ -60,7 +60,6 @@
 
 static void nosig(const char *);
 static void printsignals(FILE *);
-static int signame_to_signum(const char *);
 static void usage(void) __dead2;
 
 int
@@ -89,9 +88,9 @@
 				errx(2, "illegal signal number: %s", *argv);
 			if (numsig >= 128)
 				numsig -= 128;
-			if (numsig <= 0 || numsig >= sys_nsig)
+			if (numsig <= 0 || numsig >= NSIG)
 				nosig(*argv);
-			printf("%s\n", sys_signame[numsig]);
+			printf("%s\n", signum_to_signame(numsig));
 			return (0);
 		}
 		printsignals(stdout);
@@ -155,20 +154,6 @@
 	return (errors);
 }
 
-static int
-signame_to_signum(const char *sig)
-{
-	int n;
-
-	if (strncasecmp(sig, "SIG", 3) == 0)
-		sig += 3;
-	for (n = 1; n < sys_nsig; n++) {
-		if (!strcasecmp(sys_signame[n], sig))
-			return (n);
-	}
-	return (-1);
-}
-
 static void
 nosig(const char *name)
 {
@@ -187,9 +172,9 @@
 {
 	int n;
 
-	for (n = 1; n < sys_nsig; n++) {
-		(void)fprintf(fp, "%s", sys_signame[n]);
-		if (n == (sys_nsig / 2) || n == (sys_nsig - 1))
+	for (n = 1; n < NSIG; n++) {
+		(void)fprintf(fp, "%s", signum_to_signame(n));
+		if (n == (NSIG / 2) || n == (NSIG - 1))
 			(void)fprintf(fp, "\n");
 		else
 			(void)fprintf(fp, " ");
--- src.orig/miscutils/logger/logger.c
+++ src.freebsd/miscutils/logger/logger.c
@@ -347,8 +347,22 @@
 			errx(1, "address family mismatch");
 			
 		if (ss_src[res->ai_family]) {
+			socklen_t alen;
+			switch (res->ai_family) {
+			case AF_INET:
+				alen = sizeof(struct sockaddr_in);
+				break;
+#ifdef INET6
+			case AF_INET6:
+				alen = sizeof(struct sockaddr_in6);
+				break;
+#endif
+			default:
+				/* should be unreachable */
+				errx(1, "invalid address family");
+			}
 			error = bind(s, sstosa(ss_src[res->ai_family]),
-				    ss_src[res->ai_family]->ss_len);
+				    alen);
 			if (error < 0)
 				err(1, "bind");
 		}
--- src.orig/miscutils/look/look.c
+++ src.freebsd/miscutils/look/look.c
@@ -80,12 +80,12 @@
 
 static int dflag, fflag;
 
-static char	*binary_search(wchar_t *, unsigned char *, unsigned char *);
-static int	 compare(wchar_t *, unsigned char *, unsigned char *);
-static char	*linear_search(wchar_t *, unsigned char *, unsigned char *);
-static int	 look(wchar_t *, unsigned char *, unsigned char *);
+static char	*binary_search(wchar_t *, char *, char *);
+static int	 compare(wchar_t *, char *, char *);
+static char	*linear_search(wchar_t *, char *, char *);
+static int	 look(wchar_t *, char *, char *);
 static wchar_t	*prepkey(const char *, wchar_t);
-static void	 print_from(wchar_t *, unsigned char *, unsigned char *);
+static void	 print_from(wchar_t *, char *, char *);
 
 static void usage(void) __dead2;
 
@@ -103,8 +103,8 @@
 	struct stat sb;
 	int ch, fd, match;
 	wchar_t termchar;
-	unsigned char *back, *front;
-	unsigned const char *file;
+	char *back, *front;
+	const char *file;
 	wchar_t *key;
 
 	(void) setlocale(LC_CTYPE, "");
@@ -147,7 +147,7 @@
 	do {
 		if ((fd = open(file, O_RDONLY, 0)) < 0 || fstat(fd, &sb))
 			err(2, "%s", file);
-		if ((uintmax_t)sb.st_size > (uintmax_t)SIZE_T_MAX)
+		if ((uintmax_t)sb.st_size > (uintmax_t)SIZE_MAX)
 			errx(2, "%s: %s", file, strerror(EFBIG));
 		if (sb.st_size == 0) {
 			close(fd);
@@ -195,7 +195,7 @@
 }
 
 static int
-look(wchar_t *string, unsigned char *front, unsigned char *back)
+look(wchar_t *string, char *front, char *back)
 {
 
 	front = binary_search(string, front, back);
@@ -249,9 +249,9 @@
 	while (p < back && *p++ != '\n');
 
 static char *
-binary_search(wchar_t *string, unsigned char *front, unsigned char *back)
+binary_search(wchar_t *string, char *front, char *back)
 {
-	unsigned char *p;
+	char *p;
 
 	p = front + (back - front) / 2;
 	SKIP_PAST_NEWLINE(p, back);
@@ -283,7 +283,7 @@
  *	o front is before or at the first line to be printed.
  */
 static char *
-linear_search(wchar_t *string, unsigned char *front, unsigned char *back)
+linear_search(wchar_t *string, char *front, char *back)
 {
 	while (front < back) {
 		switch (compare(string, front, back)) {
@@ -303,7 +303,7 @@
  * Print as many lines as match string, starting at front.
  */
 static void
-print_from(wchar_t *string, unsigned char *front, unsigned char *back)
+print_from(wchar_t *string, char *front, char *back)
 {
 	for (; front < back && compare(string, front, back) == EQUAL; ++front) {
 		for (; front < back && *front != '\n'; ++front)
@@ -328,7 +328,7 @@
  * "back" terminated).
  */
 static int
-compare(wchar_t *s1, unsigned char *s2, unsigned char *back)
+compare(wchar_t *s1, char *s2, char *back)
 {
 	wchar_t ch1, ch2;
 	size_t len2;
--- src.orig/miscutils/ncal/ncal.c
+++ src.freebsd/miscutils/ncal/ncal.c
@@ -37,7 +37,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <sysexits.h>
-#include <time.h>
+#include <time_bsd.h>
 #include <unistd.h>
 #include <wchar.h>
 #include <wctype.h>
@@ -545,8 +545,11 @@
 	char    buf[MAX_WIDTH];
 	static int d_first = -1;
 
-	if (d_first < 0)
-		d_first = (*nl_langinfo(D_MD_ORDER) == 'd');
+	if (d_first < 0) {
+		d_first = 0;
+		if (strlen(nl_langinfo(D_FMT)) >= 2 && nl_langinfo(D_FMT)[1] == 'd')
+			d_first = 1;
+	}
 	/* force orthodox easter for years before 1583 */
 	if (y < 1583)
 		orthodox = 1;
@@ -563,7 +566,7 @@
 	tm.tm_year = dt.y - 1900;
 	tm.tm_mon  = dt.m - 1;
 	tm.tm_mday = dt.d;
-	strftime(buf, sizeof(buf), d_first ? "%e %B %Y" : "%B %e %Y",  &tm);
+	strftime_bsd(buf, sizeof(buf), d_first ? "%e %B %Y" : "%B %e %Y",  &tm);
 	printf("%s\n", buf);
 }
 
@@ -628,12 +631,12 @@
 
 		/* Empty line between two rows of months */
 		if (m != m1)
-			printf("\n");
+			wprintf(L"\n");
 
 		/* Year at the top. */
 		if (printyearheader && M2Y(m) != prevyear) {
 			sprintf(s, "%d", M2Y(m));
-			printf("%s\n", center(t, s, mpl * mw));
+			wprintf(L"%s\n", center(t, s, mpl * mw));
 			prevyear = M2Y(m);
 		}
 
@@ -647,7 +650,7 @@
 				    L"%-ls %d", year[i].name, M2Y(m + i));
 				wprintf(L"%-*ls  ", mw, wcenter(ws1, ws, mw));
 			}
-		printf("\n");
+		wprintf(L"\n");
 
 		/* Day of the week names. */
 		for (i = 0; i < count; i++) {
@@ -657,15 +660,15 @@
 				wdss, wds.names[3], wdss, wds.names[4],
 				wdss, wds.names[5]);
 		}
-		printf("\n");
+		wprintf(L"\n");
 
 		/* And the days of the month. */
 		for (i = 0; i != 6; i++) {
 			for (j = 0; j < count; j++)
-				printf("%-*s  ",
+				wprintf(L"%-*s  ",
 				    MW(mw, year[j].extralen[i]),
 					year[j].lines[i]+1);
-			printf("\n");
+			wprintf(L"\n");
 		}
 
 		m += mpl;
@@ -715,12 +718,12 @@
 
 		/* Empty line between two rows of months. */
 		if (m != m1)
-			printf("\n");
+			wprintf(L"\n");
 
 		/* Year at the top. */
 		if (printyearheader && M2Y(m) != prevyear) {
 			sprintf(s, "%d", M2Y(m));
-			printf("%s\n", center(t, s, mpl * mw));
+			wprintf(L"%s\n", center(t, s, mpl * mw));
 			prevyear = M2Y(m);
 		}
 
@@ -732,7 +735,7 @@
 			else
 				wprintf(L"%-ls %-*d", year[i].name,
 				    mw - wcslen(year[i].name) - 1, M2Y(m + i));
-		printf("\n");
+		wprintf(L"\n");
 
 		/* And the days of the month. */
 		for (i = 0; i != 7; i++) {
@@ -741,18 +744,18 @@
 
 			/* Full months */
 			for (j = 0; j < count; j++)
-				printf("%-*s",
+				wprintf(L"%-*s",
 				    MW(mw, year[j].extralen[i]),
 					year[j].lines[i]);
-			printf("\n");
+			wprintf(L"\n");
 		}
 
 		/* Week numbers. */
 		if (flag_weeks) {
-			printf("  ");
+			wprintf(L"  ");
 			for (i = 0; i < count; i++)
-				printf("%-*s", mw, year[i].weeks);
-			printf("\n");
+				wprintf(L"%-*s", mw, year[i].weeks);
+			wprintf(L"\n");
 		}
 
 		m += mpl;
@@ -1055,9 +1058,12 @@
 center(char *s, char *t, int w)
 {
 	char blanks[MAX_WIDTH];
+	int nblank;
 
 	memset(blanks, ' ', sizeof(blanks));
-	sprintf(s, "%.*s%s", (int)(w - strlen(t)) / 2, blanks, t);
+	nblank = (int)(w - strlen(t)) / 2;
+	memcpy(s, blanks, nblank);
+	sprintf(s + nblank, "%s", t);
 	return (s);
 }
 
@@ -1098,7 +1104,7 @@
 		*y = ny;
 		return (0);
 	}
-	if (strptime(s, "%B", &tm) != NULL || strptime(s, "%b", &tm) != NULL) {
+	if (strptime_bsd(s, "%B", &tm) != NULL || strptime_bsd(s, "%b", &tm) != NULL) {
 		*m = tm.tm_mon + 1;
 		return (0);
 	}
--- src.orig/miscutils/rev/rev.c
+++ src.freebsd/miscutils/rev/rev.c
@@ -55,6 +55,46 @@
 
 static void usage(void) __dead2;
 
+#define BUF_PIECE 1024
+
+static wchar_t *get_wln(FILE *f, size_t *len, wchar_t **sbuf, size_t *blen) {
+	wchar_t *wptr;
+	size_t wlen;
+
+	wptr = fgetws(*sbuf, *blen, f);
+	if (wptr) {
+		wlen = wcslen(wptr);
+		if (wptr[wlen - 1] == '\n' || feof(f)) {
+			*len = wlen;
+			return wptr;
+		}
+	} else {
+		return NULL;
+	}
+
+	for (;;) {
+		wchar_t *nptr;
+		*blen = wlen + BUF_PIECE;
+		*sbuf = realloc(*sbuf, *blen * sizeof(wchar_t));
+		if (*sbuf) err(1, "realloc");
+
+		nptr = fgetws(*sbuf + wlen, BUF_PIECE, f);
+		if (!nptr) {
+			if (feof(f))
+				break;
+			return NULL;
+		}
+
+		wlen += wcslen(nptr);
+		if ((*sbuf)[wlen - 1] == '\n' || feof(f)) {
+			break;
+		}
+	}
+
+	*len = wlen;
+	return *sbuf;
+}
+
 int
 main(int argc, char *argv[])
 {
@@ -63,7 +103,11 @@
 	FILE *fp;
 	size_t len;
 	int ch, rval;
+	size_t bufl = BUF_PIECE;
+	wchar_t *buf = malloc(bufl * sizeof(wchar_t));
 
+	if (!buf) err(1, "malloc");
+
 	setlocale(LC_ALL, "");
 
 	while ((ch = getopt(argc, argv, "")) != -1)
@@ -89,7 +133,7 @@
 			}
 			filename = *argv++;
 		}
-		while ((p = fgetwln(fp, &len)) != NULL) {
+		while ((p = get_wln(fp, &len, &buf, &bufl)) != NULL) {
 			if (p[len - 1] == '\n')
 				--len;
 			for (t = p + len - 1; t >= p; --t)
@@ -103,6 +147,7 @@
 		}
 		(void)fclose(fp);
 	} while(*argv);
+	free(buf);
 	exit(rval);
 }
 
--- src.orig/miscutils/script/script.1
+++ src.freebsd/miscutils/script/script.1
@@ -92,13 +92,6 @@
 .Xr mkfifo 1
 and another user may watch the live session using a utility like
 .Xr cat 1 .
-.It Fl f
-Create
-.Ar file.filemon
-or
-.Pa typescript.filemon
-using
-.Xr filemon 4 .
 .It Fl k
 Log keys sent to the program as well as output.
 .It Fl p
@@ -255,8 +248,7 @@
 for the
 .Em history
 mechanism
-.Pc ,
-.Xr filemon 4
+.Pc
 .Sh HISTORY
 The
 .Nm
--- src.orig/miscutils/script/script.c
+++ src.freebsd/miscutils/script/script.c
@@ -30,7 +30,7 @@
  * SUCH DAMAGE.
  */
 
-#include <sys/param.h>
+#include <sys/cdefs.h>
 #ifndef lint
 static const char copyright[] =
 "@(#) Copyright (c) 1980, 1992, 1993\n\
@@ -40,14 +40,13 @@
 static const char sccsid[] = "@(#)script.c	8.1 (Berkeley) 6/6/93";
 #endif
 
+#include <sys/param.h>
 #include <sys/wait.h>
 #include <sys/stat.h>
 #include <sys/ioctl.h>
 #include <sys/time.h>
 #include <sys/queue.h>
 #include <sys/uio.h>
-#include <sys/endian.h>
-#include <dev/filemon/filemon.h>
 
 #include <err.h>
 #include <errno.h>
@@ -60,6 +59,10 @@
 #include <string.h>
 #include <termios.h>
 #include <unistd.h>
+#include <time_bsd.h>
+#include <pty.h>
+#include <utmp.h>
+#include <byteswap.h>
 
 #define DEF_BUF 65536
 
@@ -82,7 +85,7 @@
 static int child;
 static const char *fname;
 static char *fmfname;
-static int fflg, qflg, ttyflg;
+static int qflg, ttyflg;
 static int usesleep, rawout, showexit;
 static TAILQ_HEAD(, buf_elm) obuf_list = TAILQ_HEAD_INITIALIZER(obuf_list);
 
@@ -117,17 +120,14 @@
 	ssize_t cc;
 	int aflg, Fflg, kflg, pflg, ch, k, n, fcm;
 	int flushtime, readstdin;
-	int fm_fd, fm_log;
 
 	aflg = Fflg = kflg = pflg = 0;
 	usesleep = 1;
 	rawout = 0;
 	flushtime = 30;
-	fm_fd = -1;	/* Shut up stupid "may be used uninitialized" GCC
-			   warning. (not needed w/clang) */
 	showexit = 0;
 
-	while ((ch = getopt(argc, argv, "adeFfkpqrT:t:")) != -1)
+	while ((ch = getopt(argc, argv, "adeFkpqrT:t:")) != -1)
 		switch(ch) {
 		case 'a':
 			aflg = 1;
@@ -140,9 +140,6 @@
 		case 'F':
 			Fflg = 1;
 			break;
-		case 'f':
-			fflg = 1;
-			break;
 		case 'k':
 			kflg = 1;
 			break;
@@ -182,20 +179,6 @@
 	if ((fscript = fopen(fname, pflg ? "r" : aflg ? "a" : "w")) == NULL)
 		err(1, "%s", fname);
 
-	if (fflg) {
-		asprintf(&fmfname, "%s.filemon", fname);
-		if (!fmfname)
-			err(1, "%s.filemon", fname);
-		if ((fm_fd = open("/dev/filemon", O_RDWR | O_CLOEXEC)) == -1)
-			err(1, "open(\"/dev/filemon\", O_RDWR)");
-		if ((fm_log = open(fmfname,
-		    O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC,
-		    S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
-			err(1, "open(%s)", fmfname);
-		if (ioctl(fm_fd, FILEMON_SET_FD, &fm_log) < 0)
-			err(1, "Cannot set filemon log file descriptor");
-	}
-
 	if (pflg)
 		playback(fscript);
 
@@ -236,10 +219,6 @@
 			}
 		}
 		fflush(fscript);
-		if (fflg) {
-			(void)printf("Filemon started, output file is %s\n",
-			    fmfname);
-		}
 	}
 	if (ttyflg) {
 		rtt = tt;
@@ -254,14 +233,6 @@
 		done(1);
 	}
 	if (child == 0) {
-		if (fflg) {
-			int pid;
-
-			pid = getpid();
-			if (ioctl(fm_fd, FILEMON_SET_PID, &pid) < 0)
-				err(1, "Cannot set filemon PID");
-		}
-
 		doshell(argv);
 	}
 	close(slave);
@@ -365,7 +336,7 @@
 usage(void)
 {
 	(void)fprintf(stderr,
-	    "usage: script [-aeFfkpqr] [-t time] [file [command ...]]\n");
+	    "usage: script [-aeFkpqr] [-t time] [file [command ...]]\n");
 	(void)fprintf(stderr,
 	    "       script -p [-deq] [-T fmt] [file]\n");
 	exit(1);
@@ -430,10 +401,6 @@
 			    ctime(&tvec));
 		}
 		(void)printf("\nScript done, output file is %s\n", fname);
-		if (fflg) {
-			(void)printf("Filemon done, output file is %s\n",
-			    fmfname);
-		}
 	}
 	(void)fclose(fscript);
 	(void)close(master);
@@ -481,10 +448,10 @@
 
 #define swapstamp(stamp) do { \
 	if (stamp.scr_direction > 0xff) { \
-		stamp.scr_len = bswap64(stamp.scr_len); \
-		stamp.scr_sec = bswap64(stamp.scr_sec); \
-		stamp.scr_usec = bswap32(stamp.scr_usec); \
-		stamp.scr_direction = bswap32(stamp.scr_direction); \
+		stamp.scr_len = bswap_64(stamp.scr_len); \
+		stamp.scr_sec = bswap_64(stamp.scr_sec); \
+		stamp.scr_usec = bswap_32(stamp.scr_usec); \
+		stamp.scr_direction = bswap_32(stamp.scr_direction); \
 	} \
 } while (0/*CONSTCOND*/)
 
@@ -580,7 +547,7 @@
 				if (stamp.scr_len == 0)
 					continue;
 				if (tclock - lclock > 0) {
-				    l = strftime(buf, sizeof buf, tstamp_fmt,
+				    l = strftime_bsd(buf, sizeof buf, tstamp_fmt,
 					localtime(&tclock));
 				    (void)write(STDOUT_FILENO, buf, l);
 				}
--- src.orig/miscutils/time/time.1
+++ src.freebsd/miscutils/time/time.1
@@ -35,7 +35,7 @@
 .Nd time command execution
 .Sh SYNOPSIS
 .Nm
-.Op Fl al
+.Op Fl a
 .Op Fl h | Fl p
 .Op Fl o Ar file
 .Ar utility Op Ar argument ...
@@ -69,10 +69,6 @@
 Print times in a human friendly format.
 Times are printed in minutes, hours,
 etc.\& as appropriate.
-.It Fl l
-The contents of the
-.Em rusage
-structure are printed as well.
 .It Fl o Ar file
 Write the output to
 .Ar file
@@ -98,7 +94,7 @@
 If
 .Nm
 receives a
-.Dv SIGINFO
+.Dv SIGUSR1
 (see the status argument for
 .Xr stty 1 )
 signal, the current time the given command is running will be written to the
@@ -161,33 +157,15 @@
 Time the
 .Xr sleep 1
 command and show the results in a human friendly format.
-Show the contents of the
-.Em rusage
-structure too:
 .Bd -literal -offset indent
-$ /usr/bin/time -l -h -p sleep 5
+$ /usr/bin/time -h -p sleep 5
 real 5.01
 user 0.00
 sys 0.00
-         0  maximum resident set size
-         0  average shared memory size
-         0  average unshared data size
-         0  average unshared stack size
-        80  page reclaims
-         0  page faults
-         0  swaps
-         1  block input operations
-         0  block output operations
-         0  messages sent
-         0  messages received
-         0  signals received
-         3  voluntary context switches
-         0  involuntary context switches
 .Ed
 .Sh SEE ALSO
 .Xr builtin 1 ,
 .Xr csh 1 ,
-.Xr getrusage 2 ,
 .Xr wait 2
 .Sh STANDARDS
 The
--- src.orig/miscutils/time/time.c
+++ src.freebsd/miscutils/time/time.c
@@ -43,10 +43,9 @@
   "$FreeBSD$";
 #endif /* not lint */
 
+#include <sys/cdefs.h>
 #include <sys/types.h>
 #include <sys/resource.h>
-#include <sys/signal.h>
-#include <sys/sysctl.h>
 #include <sys/time.h>
 #include <sys/wait.h>
 
@@ -61,7 +60,6 @@
 #include <time.h>
 #include <unistd.h>
 
-static int getstathz(void);
 static void humantime(FILE *, long, long);
 static void showtime(FILE *, struct timespec *, struct timespec *,
     struct rusage *);
@@ -76,20 +74,21 @@
 int
 main(int argc, char **argv)
 {
-	int aflag, ch, lflag, status;
+	int aflag, ch, status;
 	int exitonsig;
 	pid_t pid;
 	struct rlimit rl;
 	struct rusage ru;
 	struct timespec after;
+	struct sigaction sa = { .sa_handler = siginfo, .sa_flags = 0 };
 	char *ofn = NULL;
 	FILE *out = stderr;
 
 	(void) setlocale(LC_NUMERIC, "");
 	decimal_point = localeconv()->decimal_point[0];
 
-	aflag = hflag = lflag = pflag = 0;
-	while ((ch = getopt(argc, argv, "ahlo:p")) != -1)
+	aflag = hflag = pflag = 0;
+	while ((ch = getopt(argc, argv, "aho:p")) != -1)
 		switch((char)ch) {
 		case 'a':
 			aflag = 1;
@@ -97,9 +96,6 @@
 		case 'h':
 			hflag = 1;
 			break;
-		case 'l':
-			lflag = 1;
-			break;
 		case 'o':
 			ofn = optarg;
 			break;
@@ -136,8 +132,8 @@
 	(void)signal(SIGINT, SIG_IGN);
 	(void)signal(SIGQUIT, SIG_IGN);
 	siginfo_recvd = 0;
-	(void)signal(SIGINFO, siginfo);
-	(void)siginterrupt(SIGINFO, 1);
+	sa.sa_handler = siginfo;
+	(void)sigaction(SIGINFO, &sa, NULL);
 	while (wait4(pid, &status, 0, &ru) != pid) {
 		if (siginfo_recvd) {
 			siginfo_recvd = 0;
@@ -153,6 +149,7 @@
 		warnx("command terminated abnormally");
 	exitonsig = WIFSIGNALED(status) ? WTERMSIG(status) : 0;
 	showtime(out, &before_ts, &after, &ru);
+#if 0
 	if (lflag) {
 		int hz = getstathz();
 		u_long ticks;
@@ -196,6 +193,7 @@
 		fprintf(out, "%10ld  %s\n",
 			ru.ru_nivcsw, "involuntary context switches");
 	}
+#endif
 	/*
 	 * If the child has exited on a signal, exit on the same
 	 * signal, too, in order to reproduce the child's exit status.
@@ -222,6 +220,7 @@
 	exit(1);
 }
 
+#if 0
 /*
  * Return the frequency of the kernel's statistics clock.
  */
@@ -239,6 +238,7 @@
 		err(1, "sysctl kern.clockrate");
 	return clockrate.stathz;
 }
+#endif
 
 static void
 humantime(FILE *out, long sec, long centisec)
--- src.orig/miscutils/ul/ul.c
+++ src.freebsd/miscutils/ul/ul.c
@@ -43,6 +43,7 @@
   "$FreeBSD$";
 #endif /* not lint */
 
+#include <sys/cdefs.h>
 #include <err.h>
 #include <locale.h>
 #include <stdio.h>
--- src.orig/miscutils/wall/ttymsg.c
+++ src.freebsd/miscutils/wall/ttymsg.c
@@ -34,6 +34,7 @@
 static const char sccsid[] = "@(#)ttymsg.c	8.2 (Berkeley) 11/16/93";
 #endif
 
+#include <sys/param.h>
 #include <sys/types.h>
 #include <sys/uio.h>
 #include <dirent.h>
@@ -65,6 +66,7 @@
 	static char errbuf[1024];
 	char *p;
 	int forked;
+	sigset_t set;
 
 	forked = 0;
 	if (iovcnt > (int)(sizeof(localiov) / sizeof(localiov[0])))
@@ -140,7 +142,8 @@
 			/* wait at most tmout seconds */
 			(void) signal(SIGALRM, SIG_DFL);
 			(void) signal(SIGTERM, SIG_DFL); /* XXX */
-			(void) sigsetmask(0);
+			sigemptyset(&set);
+			sigprocmask(SIG_SETMASK, &set, 0);
 			(void) alarm((u_int)tmout);
 			(void) fcntl(fd, F_SETFL, 0);	/* clear O_NONBLOCK */
 			continue;
--- src.orig/miscutils/wall/wall.c
+++ src.freebsd/miscutils/wall/wall.c
@@ -45,7 +45,9 @@
  * is entitled "Mechanisms for Broadcast and Selective Broadcast".
  */
 
+#include <sys/cdefs.h>
 #include <sys/param.h>
+#include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/uio.h>
 
@@ -159,7 +161,7 @@
 					ingroup = 1;
 				else if ((grp = getgrgid(g->gid)) != NULL) {
 					for (np = grp->gr_mem; *np; np++) {
-						if (strcmp(*np, utmp->ut_user) == 0) {
+						if (strncmp(*np, utmp->ut_user, sizeof(utmp->ut_user)) == 0) {
 							ingroup = 1;
 							break;
 						}
--- src.orig/miscutils/whereis/pathnames.h
+++ src.freebsd/miscutils/whereis/pathnames.h
@@ -29,6 +29,7 @@
 #define PATH_LIBEXEC "/usr/libexec"
 
 /* Where to look for sources. */
+#if 0
 #define PATH_SOURCES					\
 "/usr/src/bin:/usr/src/usr.bin:/usr/src/sbin:"		\
 "/usr/src/usr.sbin:/usr/src/libexec:"			\
@@ -39,12 +40,15 @@
 "/usr/src/secure/sbin:/usr/src/secure/usr.sbin:"	\
 "/usr/src/secure/libexec:/usr/src/crypto:"		\
 "/usr/src/games"
+#else
+#define PATH_SOURCES "/usr/src"
+#endif
 
 /* Each subdirectory of PATH_PORTS will be appended to PATH_SOURCES. */
 #define PATH_PORTS "/usr/ports"
 
 /* How to query the current manpath. */
-#define MANPATHCMD "manpath -q"
+#define MANPATHCMD "command -v man > /dev/null && man -w || :"
 
 /* How to obtain the location of manpages, and how to match this result. */
 #define MANWHEREISCMD "man -S1:8:6 -w %s 2>/dev/null"
--- src.orig/miscutils/whereis/whereis.1
+++ src.freebsd/miscutils/whereis/whereis.1
@@ -58,11 +58,7 @@
 .Ql ,v
 from a source code control system.
 .Pp
-The default path searched is the string returned by the
-.Xr sysctl 8
-utility for the
-.Dq user.cs_path
-string, with
+The default path searched is the standard utilities path, with
 .Pa /usr/libexec
 and the current user's
 .Ev $PATH
@@ -71,9 +67,7 @@
 .Ev $MANPATH .
 Program sources are located in a list of known standard places,
 including all the subdirectories of
-.Pa /usr/src
-and
-.Pa /usr/ports .
+.Pa /usr/src .
 .Pp
 The following options are available:
 .Bl -tag -width indent
@@ -151,8 +145,7 @@
 .Xr find 1 ,
 .Xr locate 1 ,
 .Xr man 1 ,
-.Xr which 1 ,
-.Xr sysctl 8
+.Xr which 1
 .Sh HISTORY
 The
 .Nm
--- src.orig/miscutils/whereis/whereis.c
+++ src.freebsd/miscutils/whereis/whereis.c
@@ -32,9 +32,9 @@
  * was pretty inferior in functionality.
  */
 
+#include <sys/cdefs.h>
 #include <sys/types.h>
 #include <sys/stat.h>
-#include <sys/sysctl.h>
 
 #include <dirent.h>
 #include <err.h>
@@ -46,6 +46,7 @@
 #include <string.h>
 #include <sysexits.h>
 #include <unistd.h>
+#include <paths.h>
 
 #include "pathnames.h"
 
@@ -251,14 +252,14 @@
 static void
 defaults(void)
 {
-	size_t s;
 	char *b, buf[BUFSIZ], *cp;
 	int nele;
 	FILE *p;
+#if 0
 	DIR *dir;
 	struct stat sb;
 	struct dirent *dirp;
-	const int oid[2] = {CTL_USER, USER_CS_PATH};
+#endif
 
 	/* default to -bms if none has been specified */
 	if (!opt_b && !opt_m && !opt_s)
@@ -267,12 +268,8 @@
 	/* -b defaults to default path + /usr/libexec +
 	 * user's path */
 	if (!bindirs) {
-		if (sysctl(oid, 2, NULL, &s, NULL, 0) == -1)
-			err(EX_OSERR, "sysctl(\"user.cs_path\")");
-		if ((b = malloc(s + 1)) == NULL)
+		if ((b = strdup(_PATH_STDPATH)) == NULL)
 			abort();
-		if (sysctl(oid, 2, b, &s, NULL, 0) == -1)
-			err(EX_OSERR, "sysctl(\"user.cs_path\")");
 		nele = 0;
 		decolonify(b, &bindirs, &nele);
 		bindirs = realloc(bindirs, (nele + 2) * sizeof(char *));
@@ -293,7 +290,7 @@
 	if (!mandirs) {
 		if ((p = popen(MANPATHCMD, "r")) == NULL)
 			err(EX_OSERR, "cannot execute manpath command");
-		if (fgets(buf, BUFSIZ - 1, p) == NULL ||
+		if ((fgets(buf, BUFSIZ - 1, p) == NULL && !feof(p)) ||
 		    pclose(p))
 			err(EX_OSERR, "error processing manpath results");
 		if ((b = strchr(buf, '\n')) != NULL)
@@ -312,7 +309,7 @@
 			abort();
 		nele = 0;
 		decolonify(b, &sourcedirs, &nele);
-
+#if 0
 		if (stat(PATH_PORTS, &sb) == -1) {
 			if (errno == ENOENT)
 				/* no /usr/ports, we are done */
@@ -350,7 +347,7 @@
 			    (dirp->d_name[0] >= 'A' && dirp->d_name[0] <= 'Z') ||
 			    strcmp(dirp->d_name, "distfiles") == 0)
 				continue;
-			if ((b = malloc(sizeof PATH_PORTS + 1 + dirp->d_namlen))
+			if ((b = malloc(sizeof PATH_PORTS + 1 + strlen(dirp->d_name)))
 			    == NULL)
 				abort();
 			strcpy(b, PATH_PORTS);
@@ -370,6 +367,7 @@
 			sourcedirs[nele] = NULL;
 		}
 		closedir(dir);
+#endif
 	}
 }
 
--- src.orig/miscutils/write/write.c
+++ src.freebsd/miscutils/write/write.c
@@ -47,8 +47,6 @@
 #include <sys/cdefs.h>
 #include <sys/param.h>
 #include <sys/capsicum.h>
-#include <sys/filio.h>
-#include <sys/signal.h>
 #include <sys/stat.h>
 #include <sys/time.h>
 
@@ -56,13 +54,16 @@
 #include <ctype.h>
 #include <err.h>
 #include <errno.h>
+#include <fcntl.h>
 #include <locale.h>
 #include <paths.h>
 #include <pwd.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <signal.h>
 #include <unistd.h>
+#include <time.h>
 #include <utmpx.h>
 #include <wchar.h>
 #include <wctype.h>
@@ -78,7 +79,7 @@
 int
 main(int argc, char **argv)
 {
-	unsigned long cmds[] = { TIOCGETA, TIOCGWINSZ, FIODGNAME };
+	unsigned long cmds[] = { 0 };
 	cap_rights_t rights;
 	struct passwd *pwd;
 	time_t atime;
@@ -201,10 +202,11 @@
 {
 	struct utmpx lu, *u;
 
-	strncpy(lu.ut_line, tty, sizeof lu.ut_line);
+	strncpy(lu.ut_line, tty, sizeof lu.ut_line - 1);
+	lu.ut_line[sizeof lu.ut_line - 1] = '\0';
 	while ((u = getutxline(&lu)) != NULL)
 		if (u->ut_type == USER_PROCESS &&
-		    strcmp(user, u->ut_user) == 0) {
+		    strncmp(user, u->ut_user, sizeof(u->ut_user)) == 0) {
 			endutxent();
 			return(0);
 		}
@@ -236,13 +238,13 @@
 
 	while ((u = getutxent()) != NULL)
 		if (u->ut_type == USER_PROCESS &&
-		    strcmp(user, u->ut_user) == 0) {
+		    strncmp(user, u->ut_user, sizeof(u->ut_user)) == 0) {
 			++nloggedttys;
 			if (term_chk(devfd, u->ut_line, &msgsok, &atime, 0))
 				continue;	/* bad term? skip */
 			if (myuid && !msgsok)
 				continue;	/* skip ttys with msgs off */
-			if (strcmp(u->ut_line, mytty) == 0) {
+			if (strncmp(u->ut_line, mytty, sizeof(u->ut_line)) == 0) {
 				user_is_me = 1;
 				continue;	/* don't write to yourself */
 			}
@@ -301,10 +303,9 @@
 	fd = openat(devfd, tty, O_WRONLY);
 	if (fd < 0)
 		err(1, "openat(%s%s)", _PATH_DEV, tty);
-	fclose(stdout);
-	stdout = fdopen(fd, "w");
-	if (stdout == NULL)
+	if (dup2(fd, STDOUT_FILENO) < 0)
 		err(1, "%s%s", _PATH_DEV, tty);
+	close(fd);
 
 	(void)signal(SIGINT, done);
 	(void)signal(SIGHUP, done);
--- src.orig/nvi/cl/cl_funcs.c
+++ src.freebsd/nvi/cl/cl_funcs.c
@@ -146,7 +146,7 @@
 			if (clp->smcup != NULL)
 				(void)tputs(clp->smcup, 1, cl_putchar);
 		}
-	} else
+	} else {
 		if (clp->ti_te != TE_SENT) {
 			clp->ti_te = TE_SENT;
 			if (clp->rmcup == NULL)
@@ -154,6 +154,7 @@
 			if (clp->rmcup != NULL)
 				(void)tputs(clp->rmcup, 1, cl_putchar);
 			(void)fflush(stdout);
+		}
 		}
 		(void)fflush(stdout);
 		break;
--- src.orig/nvi/common/log.c
+++ src.freebsd/nvi/common/log.c
@@ -22,6 +22,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <stddef.h>
 
 #include "common.h"
 
@@ -81,7 +82,7 @@
 	char    data[sizeof(u_char) /* type */ + sizeof(recno_t)];
 	CHAR_T  str[1];
 } log_t;
-#define CHAR_T_OFFSET ((char *)(((log_t*)0)->str) - (char *)0)
+#define CHAR_T_OFFSET offsetof(log_t, str)
 
 /*
  * log_init --
@@ -520,6 +521,7 @@
 				sp->rptlchange = lno;
 				++sp->rptlines[L_CHANGED];
 			}
+			/* FALLTHROUGH */
 		case LOG_MARK:
 			memmove(&lm, p + sizeof(u_char), sizeof(LMARK));
 			m.lno = lm.lno;
--- src.orig/nvi/common/main.c
+++ src.freebsd/nvi/common/main.c
@@ -27,7 +27,6 @@
 #include "../vi/vi.h"
 #include "pathnames.h"
 
-static void	 attach(GS *);
 static int	 v_obsolete(char *[]);
 
 /*
@@ -419,8 +418,7 @@
  * PUBLIC: void v_end(GS *);
  */
 void
-v_end(gp)
-	GS *gp;
+v_end(GS *gp)
 {
 	MSGS *mp;
 	SCR *sp;
--- src.orig/nvi/common/options.c
+++ src.freebsd/nvi/common/options.c
@@ -313,15 +313,24 @@
 	argv[1] = &b;
 
 	/* Set numeric and string default values. */
-#define	OI(indx, str) do {						\
-	a.len = STRLEN(str);						\
-	if ((CHAR_T*)str != b2)	  /* GCC puts strings in text-space. */	\
-		(void)MEMCPY(b2, str, a.len+1);				\
+#define	OI_BASE(indx) do {						\
 	if (opts_set(sp, argv, NULL)) {					\
 		 optindx = indx;					\
 		goto err;						\
 	}								\
 } while (0)
+
+#define OI(indx, str) do { \
+	a.len = STRLEN(str); \
+	MEMCPY(b2, str, a.len + 1); \
+	OI_BASE(indx); \
+} while(0)
+
+#define OIB(indx) do { \
+	a.len = STRLEN(b2); \
+	OI_BASE(indx); \
+} while(0)
+
 	/*
 	 * Indirect global options to global space.  Specifically, set up
 	 * terminal, lines, columns first, they're used by other options.
@@ -343,7 +352,7 @@
 	/* Initialize string values. */
 	(void)SPRINTF(b2, SIZE(b2),
 	    L("cdpath=%s"), (s = getenv("CDPATH")) == NULL ? ":" : s);
-	OI(O_CDPATH, b2);
+	OIB(O_CDPATH);
 	OI(O_CEDIT, L("cedit=\033"));
 
 	/*
@@ -355,30 +364,30 @@
 	 */
 	(void)SPRINTF(b2, SIZE(b2),
 	    L("directory=%s"), (s = getenv("TMPDIR")) == NULL ? _PATH_TMP : s);
-	OI(O_TMPDIR, b2);
+	OIB(O_TMPDIR);
 	OI(O_ESCAPETIME, L("escapetime=6"));
 	OI(O_FILEC, L("filec=\t"));
 	OI(O_KEYTIME, L("keytime=6"));
 	OI(O_MATCHCHARS, L("matchchars=()[]{}"));
 	OI(O_MATCHTIME, L("matchtime=7"));
 	(void)SPRINTF(b2, SIZE(b2), L("msgcat=%s"), _PATH_MSGCAT);
-	OI(O_MSGCAT, b2);
+	OIB(O_MSGCAT);
 	OI(O_REPORT, L("report=5"));
 	OI(O_PARAGRAPHS, L("paragraphs=IPLPPPQPP LIpplpipbp"));
 	(void)SPRINTF(b2, SIZE(b2), L("path=%s"), "");
-	OI(O_PATH, b2);
+	OIB(O_PATH);
 	(void)SPRINTF(b2, SIZE(b2), L("recdir=%s"), NVI_PATH_PRESERVE);
-	OI(O_RECDIR, b2);
+	OIB(O_RECDIR);
 	OI(O_SECTIONS, L("sections=NHSHH HUnhsh"));
 	(void)SPRINTF(b2, SIZE(b2),
 	    L("shell=%s"), (s = getenv("SHELL")) == NULL ? _PATH_BSHELL : s);
-	OI(O_SHELL, b2);
+	OIB(O_SHELL);
 	OI(O_SHELLMETA, L("shellmeta=~{[*?$`'\"\\"));
 	OI(O_SHIFTWIDTH, L("shiftwidth=8"));
 	OI(O_SIDESCROLL, L("sidescroll=16"));
 	OI(O_TABSTOP, L("tabstop=8"));
 	(void)SPRINTF(b2, SIZE(b2), L("tags=%s"), _PATH_TAGS);
-	OI(O_TAGS, b2);
+	OIB(O_TAGS);
 
 	/*
 	 * XXX
@@ -388,7 +397,7 @@
 	if ((v = (O_VAL(sp, O_LINES) - 1) / 2) == 0)
 		v = 1;
 	(void)SPRINTF(b2, SIZE(b2), L("scroll=%ld"), v);
-	OI(O_SCROLL, b2);
+	OIB(O_SCROLL);
 
 	/*
 	 * The default window option values are:
@@ -409,7 +418,7 @@
 		v = 1;
 
 	(void)SPRINTF(b2, SIZE(b2), L("window=%lu"), v);
-	OI(O_WINDOW, b2);
+	OIB(O_WINDOW);
 
 	/*
 	 * Set boolean default values, and copy all settings into the default
--- src.orig/nvi/common/recover.c
+++ src.freebsd/nvi/common/recover.c
@@ -33,6 +33,7 @@
 #include <string.h>
 #include <time.h>
 #include <unistd.h>
+#include <libutil.h>
 
 #include "../ex/version.h"
 #include "common.h"
@@ -851,7 +852,7 @@
 	GET_SPACE_GOTOC(sp, bp, blen, (len + 2) / 3 * 4 + dlen + 2);
 	(void)memcpy(bp, dtype, dlen);
 	bp[dlen] = ';';
-	if ((xlen = b64_ntop((u_char *)src,
+	if ((xlen = compat_b64_ntop((u_char *)src,
 	    len, bp + dlen + 1, blen)) == -1)
 		goto err;
 	xlen += dlen + 1;
@@ -930,7 +931,7 @@
 	MALLOC(sp, data, dlen + len / 4 * 3 + 2);
 	if (data == NULL)
 		goto err;
-	if ((xlen = (b64_pton(p + dlen + 1,
+	if ((xlen = (compat_b64_pton(p + dlen + 1,
 	    (u_char *)data, len / 4 * 3 + 1))) == -1) {
 		free(data);
 		goto err;
--- src.orig/nvi/ex/ex_cscope.c
+++ src.freebsd/nvi/ex/ex_cscope.c
@@ -326,7 +326,7 @@
 		len = sb.st_size;
 		MALLOC_RET(sp, csc->pbuf, len + 1);
 		if ((fd = open(buf, O_RDONLY, 0)) < 0 ||
-		    read(fd, csc->pbuf, len) != len) {
+		    read(fd, csc->pbuf, len) != (ssize_t)len) {
 			 msgq_str(sp, M_SYSERR, buf, "%s");
 			 if (fd >= 0)
 				(void)close(fd);
--- src.orig/nvi/ex/ex_map.c
+++ src.freebsd/nvi/ex/ex_map.c
@@ -90,6 +90,8 @@
 			    "134|The %s character may not be remapped",
 			    KEY_NAME(sp, input[0]));
 			return (1);
+		default:
+			break;
 		}
 	return (seq_set(sp, NULL, 0, input, cmdp->argv[0]->len,
 	    cmdp->argv[1]->bp, cmdp->argv[1]->len, stype, SEQ_USERDEF));
--- src.orig/nvi/files/config.h.in
+++ src.freebsd/nvi/files/config.h.in
@@ -1,26 +1,26 @@
 /* Define when using wide characters */
-#cmakedefine USE_WIDECHAR
+#mesondefine USE_WIDECHAR
 
 /* Define when iconv can be used */
-#cmakedefine USE_ICONV
+#mesondefine USE_ICONV
 
 /* Define when the 2nd argument of iconv(3) is not const */
-#cmakedefine ICONV_TRADITIONAL
+#mesondefine ICONV_TRADITIONAL
 
 /* Define if you have <libutil.h> */
-#cmakedefine HAVE_LIBUTIL_H
+#mesondefine HAVE_LIBUTIL_H
 
 /* Define if you have <ncurses.h> */
-#cmakedefine HAVE_NCURSES_H
+#mesondefine HAVE_NCURSES_H
 
 /* Define if you have <ncursesw/ncurses.h> */
-#cmakedefine HAVE_NCURSESW_NCURSES_H
+#mesondefine HAVE_NCURSESW_NCURSES_H
 
 /* Define if you have <pty.h> */
-#cmakedefine HAVE_PTY_H
+#mesondefine HAVE_PTY_H
 
 /* Define if you have <term.h> */
-#cmakedefine HAVE_TERM_H
+#mesondefine HAVE_TERM_H
 
 /* Define if struct dirent has field d_namlen */
-#cmakedefine HAVE_DIRENT_D_NAMLEN
+#mesondefine HAVE_DIRENT_D_NAMLEN
--- src.orig/nvi/gen_ex_version_h.sh
+++ src.freebsd/nvi/gen_ex_version_h.sh
@@ -0,0 +1,2 @@
+#!/bin/sh
+exec sed -n 's/^.*version \([^)]*)\).*/\#define VI_VERSION "\1"/p' "$@"
--- src.orig/nvi/gen_extern_h.sh
+++ src.freebsd/nvi/gen_extern_h.sh
@@ -0,0 +1,39 @@
+#!/bin/sh
+
+do_sed() {
+    sed -n 's/^ \* PUBLIC: \(.*\)/\1/p' "$@"
+}
+
+try_sed() {
+    case "$1" in
+        */$2/*)
+            do_sed "$1"
+            return 0
+            ;;
+    esac
+    return 1
+}
+
+echo "#ifdef CL_IN_EX"
+
+while try_sed "$1" cl; do
+    shift
+done
+
+echo "#endif"
+echo "#ifdef EXP"
+
+while try_sed "$1" ex; do
+    shift
+done
+
+echo "#endif"
+echo "#ifdef V_ABS"
+
+while try_sed "$1" vi; do
+    shift
+done
+
+echo "#endif"
+
+do_sed "$@"
--- src.orig/nvi/vi/v_paragraph.c
+++ src.freebsd/nvi/vi/v_paragraph.c
@@ -45,7 +45,7 @@
 		continue;						\
 	for (lp = VIP(sp)->ps; *lp != '\0'; lp += 2)			\
 		if (lp[0] == p[1] &&					\
-		    (lp[1] == ' ' && len == 2 || lp[1] == p[2]) &&	\
+		    ((lp[1] == ' ' && len == 2) || lp[1] == p[2]) &&	\
 		    !--cnt)						\
 			goto found;					\
 } while (0)
--- src.orig/nvi/vi/vs_refresh.c
+++ src.freebsd/nvi/vi/vs_refresh.c
@@ -575,7 +575,7 @@
 	 *
 	 * Walk through the map and find the current line.
 	 */
-slow:	for (smp = HMAP; smp->lno != LNO; ++smp);
+slow:	for (smp = HMAP; smp->lno != LNO; ++smp) {}
 
 	/*
 	 * 7e: Leftright scrolling adjustment.
--- src.orig/patch/backupfile.c
+++ src.freebsd/patch/backupfile.c
@@ -104,7 +104,7 @@
 	file_name_length = strlen(file);
 
 	while ((dp = readdir(dirp)) != NULL) {
-		if (dp->d_namlen <= file_name_length)
+		if (strlen(dp->d_name) <= file_name_length)
 			continue;
 
 		this_version = version_number(file, dp->d_name, file_name_length);
--- src.orig/patch/inp.c
+++ src.freebsd/patch/inp.c
@@ -34,6 +34,7 @@
 
 #include <ctype.h>
 #include <errno.h>
+#include <fcntl.h>
 #include <libgen.h>
 #include <paths.h>
 #include <spawn.h>
@@ -283,8 +284,9 @@
 plan_b(const char *filename)
 {
 	FILE	*ifp;
-	size_t	i, j, len, maxlen;
-	char	*lbuf = NULL, *p;
+	size_t	i, j, blen = 0, maxlen;
+	ssize_t len;
+	char	*p = NULL;
 	bool	found_revision = (revision == NULL);
 
 	using_plan_a = false;
@@ -295,26 +297,20 @@
 		pfatal("can't open file %s", TMPINNAME);
 	len = 0;
 	maxlen = 1;
-	while ((p = fgetln(ifp, &len)) != NULL) {
+	while ((len = getline(&p, &blen, ifp)) >= 0) {
 		if (p[len - 1] == '\n')
 			p[len - 1] = '\0';
 		else {
-			/* EOF without EOL, copy and add the NUL */
-			if ((lbuf = malloc(len + 1)) == NULL)
-				fatal("out of memory\n");
-			memcpy(lbuf, p, len);
-			lbuf[len] = '\0';
-			p = lbuf;
-
+			/* EOF without EOL */
 			last_line_missing_eol = true;
 			len++;
 		}
 		if (revision != NULL && !found_revision && rev_in_string(p))
 			found_revision = true;
-		if (len > maxlen)
+		if ((size_t)len > maxlen)
 			maxlen = len;   /* find longest line */
 	}
-	free(lbuf);
+	free(p);
 	if (ferror(ifp))
 		pfatal("can't read file %s", filename);
 
--- src.orig/patch/patch.c
+++ src.freebsd/patch/patch.c
@@ -561,7 +561,11 @@
 	Argv_last = Argv;
 	if (!Argc)
 		return;
+#ifdef __GLIBC__
+	optind = 0;
+#else
 	optreset = optind = 1;
+#endif
 	while ((ch = getopt_long(Argc, Argv, options, longopts, NULL)) != -1) {
 		switch (ch) {
 		case 'b':
--- src.orig/patch/pch.c
+++ src.freebsd/patch/pch.c
@@ -1213,14 +1213,15 @@
 size_t
 pgets(bool do_indent)
 {
-	char *line;
-	size_t len = 0;
+	char *line = NULL;
+	ssize_t len = 0;
+	size_t buflen = 0;
 	int indent = 0, skipped = 0;
 
-	line = fgetln(pfp, &len);
-	if (line != NULL) {
-		if (len + 1 > buf_size) {
-			while (len + 1 > buf_size)
+	if ((len = getline(&line, &buflen, pfp)) >= 0) {
+		char *linep = line;
+		if ((size_t)(len + 1) > buf_size) {
+			while ((size_t)(len + 1) > buf_size)
 				buf_size *= 2;
 			free(buf);
 			buf = malloc(buf_size);
@@ -1239,8 +1240,10 @@
 		}
 		memcpy(buf, line, len - skipped);
 		buf[len - skipped] = '\0';
+		line = linep;
 	}
-	return len;
+	free(line);
+	return (len > 0) ? len : 0;
 }
 
 
--- src.orig/sed/main.c
+++ src.freebsd/sed/main.c
@@ -260,7 +260,7 @@
 			state = ST_STRING;
 			goto again;
 		default:
-			__unreachable();
+			abort(); /* unreachable */
 		}
 	case ST_FILE:
 		if ((p = fgets(buf, n, f)) != NULL) {
--- src.orig/sed/process.c
+++ src.freebsd/sed/process.c
@@ -71,7 +71,7 @@
 static void		 do_tr(struct s_tr *);
 static void		 flush_appends(void);
 static void		 lputs(char *, size_t);
-static int		 regexec_e(regex_t *, const char *, int, int, size_t,
+static int		 regexec_e(regex_t *, char *, int, int, size_t,
 			     size_t);
 static void		 regsub(SPACE *, char *, char *);
 static int		 substitute(struct s_command *);
@@ -663,7 +663,7 @@
 }
 
 static int
-regexec_e(regex_t *preg, const char *string, int eflags, int nomatch,
+regexec_e(regex_t *preg, char *string, int eflags, int nomatch,
 	size_t start, size_t stop)
 {
 	int eval;
@@ -675,11 +675,23 @@
 		defpreg = preg;
 
 	/* Set anchors */
+#ifndef REG_STARTEND
+	char old = string[stop];
+	string[stop] = '\0';
+	eval = regexec(defpreg, string + start,
+	    nomatch ? 0 : maxnsub + 1, match, eflags);
+	string[stop] = old;
+	for (size_t i = 0; i <= (nomatch ? 0 : maxnsub); ++i) {
+		match[i].rm_so += start;
+		match[i].rm_eo += start;
+	}
+#else
 	match[0].rm_so = start;
 	match[0].rm_eo = stop;
 
 	eval = regexec(defpreg, string,
 	    nomatch ? 0 : maxnsub + 1, match, eflags | REG_STARTEND);
+#endif
 	switch(eval) {
 	case 0:
 		return (1);
--- src.orig/sh/arith_yacc.c
+++ src.freebsd/sh/arith_yacc.c
@@ -197,6 +197,7 @@
 		return ~primary(op, val, yylex(), noeval);
 	default:
 		yyerror("expecting primary");
+		return 0; /* unreachable */
 	}
 }
 
--- src.orig/sh/error.h
+++ src.freebsd/sh/error.h
@@ -82,12 +82,3 @@
 void warning(const char *, ...) __printflike(1, 2);
 void error(const char *, ...) __printf0like(1, 2) __dead2;
 void errorwithstatus(int, const char *, ...) __printf0like(2, 3) __dead2;
-
-
-/*
- * BSD setjmp saves the signal mask, which violates ANSI C and takes time,
- * so we use _setjmp instead.
- */
-
-#define setjmp(jmploc)	_setjmp(jmploc)
-#define longjmp(jmploc, val)	_longjmp(jmploc, val)
--- src.orig/sh/expand.c
+++ src.freebsd/sh/expand.c
@@ -643,7 +643,8 @@
 		}
 		error("%.*s: parameter %snot set", (int)(p - var - 1),
 		      var, (varflags & VSNUL) ? "null or " : "");
-
+		abort();
+		break;
 	default:
 		abort();
 	}
@@ -800,6 +801,7 @@
 		c = p - var - 1;
 		error("${%.*s%s}: Bad substitution", c, var,
 		    (c > 0 && *p != CTLENDVAR) ? "..." : "");
+		break; /* unreachable */
 
 	default:
 		abort();
@@ -1169,7 +1171,7 @@
 		if (dp->d_name[0] == '.' && ! matchdot)
 			continue;
 		if (patmatch(start, dp->d_name)) {
-			namlen = dp->d_namlen;
+			namlen = strlen(dp->d_name);
 			if (enddir + namlen + 1 > expdir_end)
 				continue;
 			memcpy(enddir, dp->d_name, namlen + 1);
--- src.orig/sh/histedit.c
+++ src.freebsd/sh/histedit.c
@@ -77,10 +77,14 @@
 static char *fc_replace(const char *, char *, char *);
 static int not_fcnumber(const char *);
 static int str_to_event(const char *, int);
-static int comparator(const void *, const void *, void *);
+#ifdef HAVE_FN_COMPLETE2
+static int comparator(const void *, const void *);
 static char **sh_matches(const char *, int, int);
 static const char *append_char_function(const char *);
 static unsigned char sh_complete(EditLine *, int);
+#else
+#define sh_complete _el_fn_complete
+#endif
 
 static const char *
 get_histfile(void)
@@ -579,17 +583,17 @@
 	return ret;
 }
 
+#ifdef HAVE_FN_COMPLETE2
+static size_t comp_curpos;
 /*
  * Comparator function for qsort(). The use of curpos here is to skip
  * characters that we already know to compare equal (common prefix).
  */
 static int
-comparator(const void *a, const void *b, void *thunk)
+comparator(const void *a, const void *b)
 {
-	size_t curpos = (intptr_t)thunk;
-
-	return (strcmp(*(char *const *)a + curpos,
-		*(char *const *)b + curpos));
+	return (strcmp(*(char *const *)a + comp_curpos,
+		*(char *const *)b + comp_curpos));
 }
 
 static char
@@ -666,7 +670,7 @@
 	for (const unsigned char *bp = builtincmd; *bp != 0; bp += 2 + bp[0]) {
 		if (curpos > bp[0] || memcmp(bp + 2, text, curpos) != 0)
 			continue;
-		rmatches = add_match(matches, ++i, &size, strndup(bp + 2, bp[0]));
+		rmatches = add_match(matches, ++i, &size, strndup((char *)bp + 2, bp[0]));
 		if (rmatches == NULL)
 			goto out;
 		matches = rmatches;
@@ -679,8 +683,8 @@
 	}
 	uniq = 1;
 	if (i > 1) {
-		qsort_s(matches + 1, i, sizeof(matches[0]), comparator,
-			(void *)(intptr_t)curpos);
+		comp_curpos = curpos;
+		qsort(matches + 1, i, sizeof(matches[0]), comparator);
 		for (size_t k = 2; k <= i; k++) {
 			const char *l = matches[uniq] + curpos;
 			const char *r = matches[k] + curpos;
@@ -758,6 +762,7 @@
 		L" \t\n\"\\'`@$><=;|&{(", NULL, append_char_function,
 		(size_t)100, NULL, &((int) {0}), NULL, NULL, FN_QUOTE_MATCH);
 }
+#endif
 
 #else
 #include "error.h"
--- src.orig/sh/input.c
+++ src.freebsd/sh/input.c
@@ -366,8 +366,7 @@
 	int fd2;
 	int oflags = O_RDONLY | O_CLOEXEC;
 
-	if (verify == 1 || (verify == -1 && verifyflag))
-		oflags |= O_VERIFY;
+	(void)verify;
 
 	INTOFF;
 	if ((fd = open(fname, oflags)) < 0) {
--- src.orig/sh/main.c
+++ src.freebsd/sh/main.c
@@ -146,19 +146,16 @@
 	INTON;
 	if (iflag)
 		chkmail(1);
-	if (argv[0] && argv[0][0] == '-') {
+	if (lflag) {
 		state = 1;
 		read_profile("/etc/profile");
 state1:
 		state = 2;
-		if (privileged == 0)
-			read_profile("${HOME-}/.profile");
-		else
-			read_profile("/etc/suid_profile");
+		read_profile("${HOME-}/.profile");
 	}
 state2:
 	state = 3;
-	if (!privileged && iflag) {
+	if (iflag) {
 		if ((shinit = lookupvar("ENV")) != NULL && *shinit != '\0') {
 			state = 3;
 			read_profile(shinit);
@@ -259,9 +256,6 @@
 	const char *expandedname;
 	int oflags = O_RDONLY | O_CLOEXEC;
 
-	if (verifyflag)
-		oflags |= O_VERIFY;
-
 	expandedname = expandstr(name);
 	if (expandedname == NULL)
 		return;
@@ -356,4 +350,5 @@
 		exitshell(number(argv[1]));
 	else
 		exitshell_savedstatus();
+	return 1; /* unreachable */
 }
--- src.orig/sh/memalloc.h
+++ src.freebsd/sh/memalloc.h
@@ -36,6 +36,9 @@
 
 #include <string.h>
 
+#define ALIGNBYTES (sizeof(void *) - 1)
+#define ALIGN(v) (((uintptr_t)(v) + ALIGNBYTES) & ~ALIGNBYTES)
+
 struct stackmark {
 	struct stack_block *stackp;
 	char *stacknxt;
--- src.orig/sh/miscbltin.c
+++ src.freebsd/sh/miscbltin.c
@@ -444,6 +444,13 @@
 	char	option;
 };
 
+/* linux */
+#ifndef RLIMIT_VMEM
+#ifdef RLIMIT_AS
+#define RLIMIT_VMEM RLIMIT_AS
+#endif
+#endif
+
 static const struct limits limits[] = {
 #ifdef RLIMIT_CPU
 	{ "cpu time",		"seconds",	RLIMIT_CPU,	   1, 't' },
@@ -475,7 +482,8 @@
 #ifdef RLIMIT_VMEM
 	{ "virtual mem size",	"kbytes",	RLIMIT_VMEM,	1024, 'v' },
 #endif
-#ifdef RLIMIT_SWAP
+#if 0
+#ifdef
 	{ "swap limit",		"kbytes",	RLIMIT_SWAP,	1024, 'w' },
 #endif
 #ifdef RLIMIT_SBSIZE
@@ -490,6 +498,23 @@
 #ifdef RLIMIT_UMTXP
 	{ "umtx shared locks",	(char *)0,	RLIMIT_UMTXP,	   1, 'o' },
 #endif
+#else
+#ifdef RLIMIT_LOCKS
+	{ "locks",		(char *)0,	RLIMIT_LOCKS,	   1, 'w' },
+#endif
+#ifdef RLIMIT_SIGPENDING
+	{ "pending signals",		(char *)0,	RLIMIT_SIGPENDING,	   1, 'i' },
+#endif
+#ifdef RLIMIT_MSGQUEUE
+	{ "POSIX msg queue",	"bytes",	RLIMIT_MSGQUEUE,	   1, 'q' },
+#endif
+#ifdef RLIMIT_NICE
+	{ "max nice",		(char *)0,	RLIMIT_NICE,	   1, 'e' },
+#endif
+#ifdef RLIMIT_RTPRIO
+	{ "rt priority",		(char *)0,	RLIMIT_RTPRIO,	   1, 'r' },
+#endif
+#endif
 	{ (char *) 0,		(char *)0,	0,		   0, '\0' }
 };
 
@@ -525,7 +550,7 @@
 	struct rlimit	limit;
 
 	what = 'f';
-	while ((optc = nextopt("HSatfdsmcnuvlbpwko")) != '\0')
+	while ((optc = nextopt("HSatfdsmcnuvlbpwkoreiq")) != '\0')
 		switch (optc) {
 		case 'H':
 			how = HARD;
@@ -567,7 +592,8 @@
 				error("bad number");
 			uval *= l->factor;
 			val = (rlim_t)uval;
-			if (val < 0 || (uintmax_t)val != uval ||
+			/* posix says rlim_t is unsigned */
+			if (uval > ((rlim_t)~(rlim_t)0) ||
 			    val == RLIM_INFINITY)
 				error("bad number");
 		}
--- src.orig/sh/mkbuiltins
+++ src.freebsd/sh/mkbuiltins
@@ -33,13 +33,14 @@
 #
 #	@(#)mkbuiltins	8.2 (Berkeley) 5/4/95
 
-temp=`mktemp -t ka`
+temp=`mktemp`
 srcdir=$1
+dstdir=$2
 havejobs=0
 if grep '^#define[	 ]*JOBS[	 ]*1' $srcdir/shell.h > /dev/null
 then	havejobs=1
 fi
-exec > builtins.c
+exec > "${dstdir}/builtins.c"
 cat <<\!
 /*
  * This file was generated by the mkbuiltins program.
@@ -70,7 +71,7 @@
 	}}' $temp
 echo '};'
 
-exec > builtins.h
+exec > "${dstdir}/builtins.h"
 cat <<\!
 /*
  * This file was generated by the mkbuiltins program.
--- src.orig/sh/mknodes.c
+++ src.freebsd/sh/mknodes.c
@@ -95,7 +95,7 @@
 
 static void parsenode(void);
 static void parsefield(void);
-static void output(char *);
+static void output(char *, char *, char *);
 static void outsizes(FILE *);
 static void outfunc(FILE *, int);
 static void indent(int, FILE *);
@@ -111,7 +111,7 @@
 {
 	FILE *infp;
 
-	if (argc != 3)
+	if (argc != 5)
 		error("usage: mknodes file");
 	if ((infp = fopen(argv[1], "r")) == NULL)
 		error("Can't open %s: %s", argv[1], strerror(errno));
@@ -122,7 +122,7 @@
 			parsenode();
 	}
 	fclose(infp);
-	output(argv[2]);
+	output(argv[2], argv[3], argv[4]);
 	exit(0);
 }
 
@@ -212,7 +212,7 @@
 \n";
 
 static void
-output(char *file)
+output(char *file, char *nodesh, char *nodesc)
 {
 	FILE *hfile;
 	FILE *cfile;
@@ -224,9 +224,9 @@
 
 	if ((patfile = fopen(file, "r")) == NULL)
 		error("Can't open %s: %s", file, strerror(errno));
-	if ((hfile = fopen("nodes.h", "w")) == NULL)
+	if ((hfile = fopen(nodesh, "w")) == NULL)
 		error("Can't create nodes.h: %s", strerror(errno));
-	if ((cfile = fopen("nodes.c", "w")) == NULL)
+	if ((cfile = fopen(nodesc, "w")) == NULL)
 		error("Can't create nodes.c");
 	fputs(writer, hfile);
 	for (i = 0 ; i < ntypes ; i++)
--- src.orig/sh/mksyntax.c
+++ src.freebsd/sh/mksyntax.c
@@ -112,18 +112,23 @@
 static void output_type_macros(void);
 
 int
-main(int argc __unused, char **argv __unused)
+main(int argc, char **argv)
 {
 	int i;
 	char buf[80];
 	int pos;
 
+	if (argc <= 2) {
+		fprintf(stderr, "not enough arguments\n");
+		return 1;
+	}
+
 	/* Create output files */
-	if ((cfile = fopen("syntax.c", "w")) == NULL) {
+	if ((cfile = fopen(argv[2], "w")) == NULL) {
 		perror("syntax.c");
 		exit(2);
 	}
-	if ((hfile = fopen("syntax.h", "w")) == NULL) {
+	if ((hfile = fopen(argv[1], "w")) == NULL) {
 		perror("syntax.h");
 		exit(2);
 	}
--- src.orig/sh/mktokens
+++ src.freebsd/sh/mktokens
@@ -37,7 +37,8 @@
 # token marks the end of a list.  The third column is the name to print in
 # error messages.
 
-temp=`mktemp -t ka`
+temp=`mktemp`
+dstdir=$1
 cat > $temp <<\!
 TEOF	1	end of file
 TNL	0	newline
@@ -69,7 +70,7 @@
 TNOT	0	"!"
 !
 nl=`wc -l $temp`
-exec > token.h
+exec > "${dstdir}/token.h"
 awk '{print "#define " $1 " " NR-1}' $temp
 echo '
 /* Array indicating which tokens mark the end of a list */
--- src.orig/sh/myhistedit.h
+++ src.freebsd/sh/myhistedit.h
@@ -37,7 +37,22 @@
 extern EditLine *el;
 extern int displayhist;
 
-#include <filecomplete.h>
+#ifdef HAVE_FN_COMPLETE2
+#define FN_QUOTE_MATCH 1U
+/* while this is not a part of the public API in libedit, it is a part of
+ * its public ABI (in recent versions, older ones did not have it, which
+ * is why this is guarded here)
+ *
+ * i hope libedit will at very least play nice and not break it, as that
+ * could get ugly
+ */
+int fn_complete2(EditLine *,
+    char *(*)(const char *, int),
+    char **(*)(const char *, int, int),
+    const wchar_t *, const wchar_t *, const char *(*)(const char *), size_t,
+    int *, int *, int *, int *, unsigned int);
+char *fn_tilde_expand(const char *);
+#endif
 
 void histedit(void);
 void sethistsize(const char *);
--- src.orig/sh/options.c
+++ src.freebsd/sh/options.c
@@ -89,11 +89,11 @@
 	char *scriptname;
 
 	argptr = argv;
+	lflag = argptr[0] && argptr[0][0] == '-';
 	if (argc > 0)
 		argptr++;
 	for (i = 0; i < NOPTS; i++)
 		optval[i] = 2;
-	privileged = (getuid() != geteuid() || getgid() != getegid());
 	options(1);
 	if (*argptr == NULL && minusc == NULL)
 		sflag = 1;
@@ -196,6 +196,8 @@
 				if (q == NULL || minusc != NULL)
 					error("Bad -c option");
 				minusc = q;
+			} else if (c == 'l' && cmdline) {
+				lflag |= 1;
 			} else if (c == 'o') {
 				minus_o(*argptr, val);
 				if (*argptr)
@@ -282,12 +284,6 @@
 static void
 setoptionbyindex(int idx, int val)
 {
-	if (&optval[idx] == &privileged && !val && privileged) {
-		if (setgid(getgid()) == -1)
-			error("setgid");
-		if (setuid(getuid()) == -1)
-			error("setuid");
-	}
 	optval[idx] = val;
 	if (val) {
 		/* #%$ hack for ksh semantics */
--- src.orig/sh/options.h
+++ src.freebsd/sh/options.h
@@ -61,22 +61,22 @@
 #define	aflag optval[12]
 #define	bflag optval[13]
 #define	uflag optval[14]
-#define	privileged optval[15]
-#define	Tflag optval[16]
-#define	Pflag optval[17]
-#define	hflag optval[18]
-#define	nologflag optval[19]
-#define	pipefailflag optval[20]
-#define	verifyflag optval[21]
+#define	Tflag optval[15]
+#define	Pflag optval[16]
+#define	hflag optval[17]
+#define	nologflag optval[18]
+#define	pipefailflag optval[19]
 
-#define NSHORTOPTS	19
-#define NOPTS		22
+#define NSHORTOPTS	18
+#define NOPTS		20
 
+extern char lflag;
 extern char optval[NOPTS];
 extern const char optletter[NSHORTOPTS];
 #ifdef DEFINE_OPTIONS
+char lflag;
 char optval[NOPTS];
-const char optletter[NSHORTOPTS] = "efIimnsxvVECabupTPh";
+const char optletter[NSHORTOPTS] = "efIimnsxvVECabuTPh";
 static const unsigned char optname[] =
 	"\007errexit"
 	"\006noglob"
@@ -93,13 +93,11 @@
 	"\011allexport"
 	"\006notify"
 	"\007nounset"
-	"\012privileged"
 	"\012trapsasync"
 	"\010physical"
 	"\010trackall"
 	"\005nolog"
 	"\010pipefail"
-	"\006verify"
 ;
 #endif
 
--- src.orig/sh/output.c
+++ src.freebsd/sh/output.c
@@ -69,7 +69,7 @@
 #define MEM_OUT -2		/* output to dynamically allocated memory */
 #define OUTPUT_ERR 01		/* error occurred on output */
 
-static int doformat_wr(void *, const char *, int);
+static ssize_t doformat_wr(void *, const char *, size_t);
 
 struct output output = {NULL, NULL, NULL, OUTBUFSIZ, 1, 0};
 struct output errout = {NULL, NULL, NULL, 256, 2, 0};
@@ -316,8 +316,8 @@
 	INTON;
 }
 
-static int
-doformat_wr(void *cookie, const char *buf, int len)
+static ssize_t
+doformat_wr(void *cookie, const char *buf, size_t len)
 {
 	struct output *o;
 
@@ -327,12 +327,19 @@
 	return (len);
 }
 
+static cookie_io_functions_t func = {
+    .write = doformat_wr,
+    .read = NULL,
+    .seek = NULL,
+    .close = NULL
+};
+
 void
 doformat(struct output *dest, const char *f, va_list ap)
 {
 	FILE *fp;
 
-	if ((fp = fwopen(dest, doformat_wr)) != NULL) {
+	if ((fp = fopencookie(dest, "a", func)) != NULL) {
 		vfprintf(fp, f, ap);
 		fclose(fp);
 	}
@@ -341,7 +348,7 @@
 FILE *
 out1fp(void)
 {
-	return fwopen(out1, doformat_wr);
+	return fopencookie(out1, "a", func);
 }
 
 /*
--- src.orig/sh/parser.c
+++ src.freebsd/sh/parser.c
@@ -592,6 +592,9 @@
 	case TRP:
 		if (!redir)
 			synexpect(-1);
+		tokpushback++;
+		n1 = simplecmd(rpp, redir);
+		return n1;
 	case TWORD:
 		tokpushback++;
 		n1 = simplecmd(rpp, redir);
@@ -1092,7 +1095,6 @@
 	struct jmploc jmploc;
 	struct jmploc *const savehandler = handler;
 	size_t savelen;
-	int saveprompt;
 	const int bq_startlinno = plinno;
 	char *volatile ostr = NULL;
 	struct parsefile *const savetopfile = getcurrentfile();
@@ -1180,18 +1182,16 @@
 	(*nlpp)->next = NULL;
 
 	if (oldstyle) {
-		saveprompt = doprompt;
+		int saveprompt = doprompt;
 		doprompt = 0;
-	}
-
-	n = list(0);
-
-	if (oldstyle) {
+		n = list(0);
 		if (peektoken() != TEOF)
 			synexpect(-1);
 		doprompt = saveprompt;
-	} else
+	} else {
+		n = list(0);
 		consumetoken(TRP);
+	}
 
 	(*nlpp)->n = n;
         if (oldstyle) {
@@ -1240,12 +1240,13 @@
 readcstyleesc(char *out)
 {
 	int c, vc, i, n;
-	unsigned int v;
+	unsigned int v = 0;
 
 	c = pgetc();
 	switch (c) {
 	case '\0':
 		synerror("Unterminated quoted string");
+		return NULL; /* unreachable */
 	case '\n':
 		plinno++;
 		if (doprompt)
@@ -1989,7 +1990,7 @@
 static void
 getusername(char *name, size_t namelen)
 {
-	static char cached_name[MAXLOGNAME];
+	static char cached_name[LOGIN_NAME_MAX];
 	struct passwd *pw;
 	uid_t euid;
 
--- src.orig/sh/redir.c
+++ src.freebsd/sh/redir.c
@@ -173,7 +173,7 @@
 	struct stat sb;
 	int fd = redir->nfile.fd;
 	const char *fname;
-	int f;
+	int f = 0;
 	int e;
 
 	memory[fd] = 0;
--- src.orig/sh/sh.1
+++ src.freebsd/sh/sh.1
@@ -277,22 +277,6 @@
 to
 .Fl P
 (physical directory layout).
-.It Fl p Li privileged
-Turn on privileged mode.
-This mode is enabled on startup
-if either the effective user or group ID is not equal to the
-real user or group ID.
-Turning this mode off sets the
-effective user and group IDs to the real user and group IDs.
-When this mode is enabled for interactive shells, the file
-.Pa /etc/suid_profile
-is sourced instead of
-.Pa ~/.profile
-after
-.Pa /etc/profile
-is sourced, and the contents of the
-.Ev ENV
-variable are ignored.
 .It Fl s Li stdin
 Read commands from standard input (set automatically
 if no file arguments are present).
@@ -2662,7 +2646,7 @@
 For aliases the alias expansion is printed;
 for commands and tracked aliases
 the complete pathname of the command is printed.
-.It Ic ulimit Oo Fl HSabcdfklmnopstuvw Oc Op Ar limit
+.It Ic ulimit Oo Fl HSacedfilmnqrstuvw Oc Op Ar limit
 Set or display resource limits (see
 .Xr getrlimit 2 ) .
 If
@@ -2701,8 +2685,6 @@
 displayed or modified.
 They are mutually exclusive.
 .Bl -tag -width indent
-.It Fl b Ar sbsize
-The maximum size of socket buffer usage, in bytes.
 .It Fl c Ar coredumpsize
 The maximal size of core dump files, in 512-byte blocks.
 Setting
@@ -2710,13 +2692,12 @@
 to 0 prevents core dump files from being created.
 .It Fl d Ar datasize
 The maximal size of the data segment of a process, in kilobytes.
+.It Fl e Ar nice
+The nice value ceiling for the process.
 .It Fl f Ar filesize
 The maximal size of a file, in 512-byte blocks.
-.It Fl k Ar kqueues
-The maximal number of kqueues
-(see
-.Xr kqueue 2 )
-for this user ID.
+.It Fl i Ar sigpending
+The limit on the number of signals that may be queued.
 .It Fl l Ar lockedmem
 The maximal size of memory that can be locked by a process, in
 kilobytes.
@@ -2724,13 +2705,10 @@
 The maximal resident set size of a process, in kilobytes.
 .It Fl n Ar nofiles
 The maximal number of descriptors that could be opened by a process.
-.It Fl o Ar umtxp
-The maximal number of process-shared locks
-(see
-.Xr pthread 3 )
-for this user ID.
-.It Fl p Ar pseudoterminals
-The maximal number of pseudo-terminals for this user ID.
+.It Fl r Ar rtprio
+The ceiling on the real-time priority that may be set for the process.
+.It Fl q Ar msgqueue
+The limit on the number of bytes that may be allocated for POSIX message queus.
 .It Fl s Ar stacksize
 The maximal size of the stack segment, in kilobytes.
 .It Fl t Ar time
@@ -2739,9 +2717,12 @@
 The maximal number of simultaneous processes for this user ID.
 .It Fl v Ar virtualmem
 The maximal virtual size of a process, in kilobytes.
-.It Fl w Ar swapuse
-The maximum amount of swap space reserved or used for this user ID,
-in kilobytes.
+.It Fl w Ar locks
+The limit on the combined number of
+.Xr flock 2
+and
+.Xr fcntl 2
+locks.
 .El
 .It Ic umask Oo Fl S Oc Op Ar mask
 Set the file creation mask (see
--- src.orig/sh/trap.c
+++ src.freebsd/sh/trap.c
@@ -111,10 +111,11 @@
 
 		if (strncasecmp(sig, "SIG", 3) == 0)
 			sig += 3;
-		for (n = 1; n < sys_nsig; n++)
-			if (sys_signame[n] &&
-			    strcasecmp(sys_signame[n], sig) == 0)
+		for (n = 1; n < NSIG; n++) {
+			const char *sign = signum_to_signame(n);
+			if (sign && strcasecmp(sign, sig) == 0)
 				return (n);
+		}
 	}
 	return (-1);
 }
@@ -129,16 +130,17 @@
 	int n, outlen;
 
 	outlen = 0;
-	for (n = 1; n < sys_nsig; n++) {
-		if (sys_signame[n]) {
-			out1fmt("%s", sys_signame[n]);
-			outlen += strlen(sys_signame[n]);
+	for (n = 1; n < NSIG; n++) {
+		const char *sign = signum_to_signame(n);
+		if (sign) {
+			out1fmt("%s", sign);
+			outlen += strlen(sign);
 		} else {
 			out1fmt("%d", n);
 			outlen += 3;	/* good enough */
 		}
 		++outlen;
-		if (outlen > 71 || n == sys_nsig - 1) {
+		if (outlen > 71 || n == NSIG - 1) {
 			out1str("\n");
 			outlen = 0;
 		} else {
@@ -169,14 +171,15 @@
 	argv = argptr;
 
 	if (*argv == NULL) {
-		for (signo = 0 ; signo < sys_nsig ; signo++) {
+		for (signo = 0 ; signo < NSIG ; signo++) {
 			if (signo < NSIG && trap[signo] != NULL) {
+				const char *sign = signum_to_signame(signo);
 				out1str("trap -- ");
 				out1qstr(trap[signo]);
 				if (signo == 0) {
 					out1str(" EXIT\n");
-				} else if (sys_signame[signo]) {
-					out1fmt(" %s\n", sys_signame[signo]);
+				} else if (sign) {
+					out1fmt(" %s\n", sign);
 				} else {
 					out1fmt(" %d\n", signo);
 				}
--- src.orig/telnet/libtelnet/auth.c
+++ src.freebsd/telnet/libtelnet/auth.c
@@ -397,7 +397,7 @@
 	if (data < _auth_send_data ||
 	    data > _auth_send_data + sizeof(_auth_send_data)) {
 		auth_send_cnt = (size_t)cnt > sizeof(_auth_send_data)
-					? sizeof(_auth_send_data)
+					? (int)sizeof(_auth_send_data)
 					: cnt;
 		memmove((void *)_auth_send_data, (void *)data, auth_send_cnt);
 		auth_send_data = _auth_send_data;
@@ -497,7 +497,7 @@
 void
 auth_name(unsigned char *data, int cnt)
 {
-	unsigned char savename[256];
+	char savename[256];
 
 	if (cnt < 1) {
 		if (auth_debug_mode)
--- src.orig/telnet/libtelnet/encrypt.c
+++ src.freebsd/telnet/libtelnet/encrypt.c
@@ -751,7 +751,7 @@
 		return;
 	}
 
-	encrypt_send_keyid(dir, kp->keyid, kp->keylen, 0);
+	encrypt_send_keyid(dir, (const char *)kp->keyid, kp->keylen, 0);
 }
 
 void
--- src.orig/telnet/libtelnet/pk.c
+++ src.freebsd/telnet/libtelnet/pk.c
@@ -44,6 +44,7 @@
  */
 
 #include <sys/time.h>
+#include <sys/random.h>
 #include <openssl/des.h>
 #include <fcntl.h>
 #include <stdio.h>
@@ -142,7 +143,15 @@
 static void
 getseed(char *seed, int seedsize)
 {
-	arc4random_buf(seed, seedsize);
+	for (;;) {
+		ssize_t rn = getrandom(seed, seedsize, GRND_RANDOM);
+		if (rn >= seedsize)
+			break;
+		else if (rn < 0)
+			continue;
+		seed += rn;
+		seedsize -= rn;
+	}
 }
 
 /*
@@ -223,7 +232,7 @@
 	memset(buf,0,sizeof(buf));
 	deslen = ((strlen(in) + 7)/8)*8;
 	DES_key_sched(key, &k);
-	DES_cbc_encrypt(in, buf, deslen, &k, &i, DES_ENCRYPT);
+	DES_cbc_encrypt((unsigned char *)in, (unsigned char *)buf, deslen, &k, &i, DES_ENCRYPT);
 	for (l=0,op=0;l<deslen;l++) {
 		out[op++] = hextab[(buf[l] & 0xf0) >> 4];
 		out[op++] = hextab[(buf[l] & 0x0f)];
@@ -255,6 +264,6 @@
 		buf[l] = n1*16 +n2;
 	}
 	DES_key_sched(key, &k);
-	DES_cbc_encrypt(buf, out, strlen(in) / 2, &k, &i, DES_DECRYPT);
+	DES_cbc_encrypt((unsigned char *)buf, (unsigned char *)out, strlen(in) / 2, &k, &i, DES_DECRYPT);
 	out[strlen(in)/2] = '\0';
 }
--- src.orig/telnet/libtelnet/sra.c
+++ src.freebsd/telnet/libtelnet/sra.c
@@ -41,7 +41,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <syslog.h>
-#include <ttyent.h>
 
 #ifndef NOPAM
 #include <security/pam_appl.h>
@@ -413,6 +412,7 @@
 	}
 }
 
+#if 0
 static int
 isroot(const char *usr)
 {
@@ -430,11 +430,14 @@
 
 	return ((t = getttynam(ttyn)) && t->ty_status & TTY_SECURE);
 }
+#endif
 
 #ifdef NOPAM
 static int
 check_user(char *name, char *cred)
 {
+	(void)name; (void)cred;
+#if 0
 	char *cp;
 	char *xpasswd, *salt;
 
@@ -460,6 +463,7 @@
 		}
 		return(1);
 	}
+#endif
 	return(0);
 }
 #else
--- src.orig/telnet/telnet/commands.c
+++ src.freebsd/telnet/telnet/commands.c
@@ -36,9 +36,11 @@
 __FBSDID("$FreeBSD$");
 
 #include <sys/param.h>
+#include <sys/types.h>
 #include <sys/un.h>
 #include <sys/file.h>
 #include <sys/socket.h>
+#include <sys/wait.h>
 #include <netinet/in.h>
 
 #include <assert.h>
@@ -80,6 +82,13 @@
 #define       MAXHOSTNAMELEN 256
 #endif
 
+#ifndef ALIGNBYTES
+#define ALIGNBYTES (sizeof(void *) - 1)
+#endif
+#ifndef ALIGN
+#define ALIGN(v) (((uintptr_t)(v) + ALIGNBYTES) & ~ALIGNBYTES)
+#endif
+
 typedef int (*intrtn_t)(int, char **);
 
 #ifdef	AUTHENTICATION
@@ -104,11 +113,11 @@
 #ifdef INET6
 static int switch_af(struct addrinfo **);
 #endif
-static int togglehelp(void);
+static int togglehelp(int);
 static int send_tncmd(void (*)(int, int), const char *, char *);
 static int setmod(int);
 static int clearmode(int);
-static int modehelp(void);
+static int modehelp(int);
 static int sourceroute(struct addrinfo *, char *, unsigned char **, int *, int *, int *);
 
 typedef struct {
@@ -124,6 +133,10 @@
 static char *margv[20];
 int quiet_mode;
 
+#if defined(__linux__) && !defined(__GLIBC__) && defined(INET6)
+#define INET6_NO_RTHDR
+#endif
+
 #ifdef OPIE
 #include <sys/wait.h>
 #define PATH_OPIEKEY	"/usr/bin/opiekey"
@@ -282,15 +295,15 @@
     const char	*help;		/* Help information (0 ==> no help) */
     int		needconnect;	/* Need to be connected */
     int		narg;		/* Number of arguments */
-    int		(*handler)(char *, ...); /* Routine to perform (for special ops) */
+    int		(*handler)(char *); /* Routine to perform (for special ops) */
     int		nbyte;		/* Number of bytes to send this command */
     int		what;		/* Character to be sent (<0 ==> special) */
 };
 
 
 static int
-	send_esc(void),
-	send_help(void),
+	send_esc(char *),
+	send_help(char *),
 	send_docmd(char *),
 	send_dontcmd(char *),
 	send_willcmd(char *),
@@ -303,7 +316,7 @@
     { "break",	NULL,				1, 0, NULL, 2, BREAK },
     { "ec",	"Send Telnet Erase Character",	1, 0, NULL, 2, EC },
     { "el",	"Send Telnet Erase Line",	1, 0, NULL, 2, EL },
-    { "escape",	"Send current escape character",1, 0, (int (*)(char *, ...))send_esc, 1, 0 },
+    { "escape",	"Send current escape character",1, 0, send_esc, 1, 0 },
     { "ga",	"Send Telnet 'Go Ahead' sequence", 1, 0, NULL, 2, GA },
     { "ip",	"Send Telnet Interrupt Process",1, 0, NULL, 2, IP },
     { "intp",	NULL,				1, 0, NULL, 2, IP },
@@ -314,14 +327,14 @@
     { "abort",	"Send Telnet 'Abort Process'",	1, 0, NULL, 2, ABORT },
     { "susp",	"Send Telnet 'Suspend Process'",1, 0, NULL, 2, SUSP },
     { "eof",	"Send Telnet End of File Character", 1, 0, NULL, 2, xEOF },
-    { "synch",	"Perform Telnet 'Synch operation'", 1, 0, (int (*)(char *, ...))dosynch, 2, 0 },
-    { "getstatus", "Send request for STATUS",	1, 0, (int (*)(char *, ...))get_status, 6, 0 },
-    { "?",	"Display send options",		0, 0, (int (*)(char *, ...))send_help, 0, 0 },
-    { "help",	NULL,				0, 0, (int (*)(char *, ...))send_help, 0, 0 },
-    { "do",	NULL,				0, 1, (int (*)(char *, ...))send_docmd, 3, 0 },
-    { "dont",	NULL,				0, 1, (int (*)(char *, ...))send_dontcmd, 3, 0 },
-    { "will",	NULL,				0, 1, (int (*)(char *, ...))send_willcmd, 3, 0 },
-    { "wont",	NULL,				0, 1, (int (*)(char *, ...))send_wontcmd, 3, 0 },
+    { "synch",	"Perform Telnet 'Synch operation'", 1, 0, dosynch, 2, 0 },
+    { "getstatus", "Send request for STATUS",	1, 0, get_status, 6, 0 },
+    { "?",	"Display send options",		0, 0, send_help, 0, 0 },
+    { "help",	NULL,				0, 0, send_help, 0, 0 },
+    { "do",	NULL,				0, 1, send_docmd, 3, 0 },
+    { "dont",	NULL,				0, 1, send_dontcmd, 3, 0 },
+    { "will",	NULL,				0, 1, send_willcmd, 3, 0 },
+    { "wont",	NULL,				0, 1, send_wontcmd, 3, 0 },
     { NULL,	NULL,				0, 0, NULL, 0, 0 }
 };
 
@@ -368,7 +381,7 @@
 	}
 	count += s->nbyte;
 	if ((void *)s->handler == (void *)send_help) {
-	    send_help();
+	    send_help(NULL);
 	    return 0;
 	}
 
@@ -398,8 +411,7 @@
 	}
 	if (s->handler) {
 	    count++;
-	    success += (*s->handler)((s->narg > 0) ? argv[i+1] : 0,
-				  (s->narg > 1) ? argv[i+2] : 0);
+	    success += (*s->handler)((s->narg > 0) ? argv[i+1] : 0);
 	    i += s->narg;
 	} else {
 	    NET2ADD(IAC, s->what);
@@ -410,8 +422,9 @@
 }
 
 static int
-send_esc(void)
+send_esc(char *name)
 {
+    (void)name;
     NETADD(escape);
     return 1;
 }
@@ -502,9 +515,10 @@
 }
 
 static int
-send_help(void)
+send_help(char *name)
 {
     struct sendlist *s;	/* pointer to current command */
+    (void)name;
     for (s = Sendlist; s->name; s++) {
 	if (s->help)
 	    printf("%-15s %s\n", s->name, s->help);
@@ -518,15 +532,17 @@
  */
 
 static int
-lclchars(void)
+lclchars(int val)
 {
+    (void)val;
     donelclchars = 1;
     return 1;
 }
 
 static int
-togdebug(void)
+togdebug(int val)
 {
+    (void)val;
 #ifndef	NOT43
     if (net > 0 &&
 	(SetSockOpt(net, SOL_SOCKET, SO_DEBUG, telnet_debug)) < 0) {
@@ -544,8 +560,9 @@
 
 
 static int
-togcrlf(void)
+togcrlf(int val)
 {
+    (void)val;
     if (crlf) {
 	printf("Will send carriage returns as telnet <CR><LF>.\n");
     } else {
@@ -721,7 +738,7 @@
 		    0 },
     { "crlf",
 	"sending carriage returns as telnet <CR><LF>",
-	    (int (*)(int))togcrlf,
+	    togcrlf,
 		&crlf,
 		    0 },
     { "crmod",
@@ -731,13 +748,13 @@
 		    "map carriage return on output" },
     { "localchars",
 	"local recognition of certain control characters",
-	    (int (*)(int))lclchars,
+	    lclchars,
 		&localchars,
 		    "recognize certain control characters" },
     { " ", "", NULL, NULL, NULL },		/* empty line */
     { "debug",
 	"debugging",
-	    (int (*)(int))togdebug,
+	    togdebug,
 		&telnet_debug,
 		    "turn on socket level debugging" },
     { "netdata",
@@ -762,23 +779,24 @@
 		    "print hexadecimal representation of terminal traffic" },
     { "?",
 	NULL,
-	    (int (*)(int))togglehelp,
+	    togglehelp,
 		NULL,
 		    NULL },
     { NULL, NULL, NULL, NULL, NULL },
     { "help",
 	NULL,
-	    (int (*)(int))togglehelp,
+	    togglehelp,
 		NULL,
 		    NULL },
     { NULL, NULL, NULL, NULL, NULL }
 };
 
 static int
-togglehelp(void)
+togglehelp(int val)
 {
     struct togglelist *c;
 
+    (void)val;
     for (c = Togglelist; c->name; c++) {
 	if (c->help) {
 	    if (*c->help)
@@ -857,7 +875,7 @@
  */
 
 #ifdef	USE_TERMIO
-struct termio new_tc = { 0, 0, 0, 0, {}, 0, 0 };
+struct termio new_tc = {0};
 #endif
 
 struct setlist {
@@ -1057,8 +1075,9 @@
 extern int kludgelinemode;
 
 static int
-dokludgemode(void)
+dokludgemode(int val)
 {
+    (void)val;
     kludgelinemode = 1;
     send_wont(TELOPT_LINEMODE, 1);
     send_dont(TELOPT_SGA, 1);
@@ -1068,8 +1087,9 @@
 #endif
 
 static int
-dolinemode(void)
+dolinemode(int val)
 {
+    (void)val;
 #ifdef	KLUDGELINEMODE
     if (kludgelinemode)
 	send_dont(TELOPT_SGA, 1);
@@ -1080,8 +1100,9 @@
 }
 
 static int
-docharmode(void)
+docharmode(int val)
 {
+    (void)val;
 #ifdef	KLUDGELINEMODE
     if (kludgelinemode)
 	send_do(TELOPT_SGA, 1);
@@ -1133,11 +1154,11 @@
 };
 
 static struct modelist ModeList[] = {
-    { "character", "Disable LINEMODE option",	(int (*)(int))docharmode, 1, 0 },
+    { "character", "Disable LINEMODE option",	docharmode, 1, 0 },
 #ifdef	KLUDGELINEMODE
     { "",	"(or disable obsolete line-by-line mode)", NULL, 0, 0 },
 #endif
-    { "line",	"Enable LINEMODE option",	(int (*)(int))dolinemode, 1, 0 },
+    { "line",	"Enable LINEMODE option",	dolinemode, 1, 0 },
 #ifdef	KLUDGELINEMODE
     { "",	"(or enable obsolete line-by-line mode)", NULL, 0, 0 },
 #endif
@@ -1155,21 +1176,22 @@
     { "litecho", "Enable literal character echo", setmod, 1, MODE_LIT_ECHO },
     { "+litecho", 0,				setmod, 1, MODE_LIT_ECHO },
     { "-litecho", "Disable literal character echo", clearmode, 1, MODE_LIT_ECHO },
-    { "help",	0,				(int (*)(int))modehelp, 0, 0 },
+    { "help",	0,				modehelp, 0, 0 },
 #ifdef	KLUDGELINEMODE
-    { "kludgeline", 0,				(int (*)(int))dokludgemode, 1, 0 },
+    { "kludgeline", 0,				dokludgemode, 1, 0 },
 #endif
     { "", "", NULL, 0, 0 },
-    { "?",	"Print help information",	(int (*)(int))modehelp, 0, 0 },
+    { "?",	"Print help information",	modehelp, 0, 0 },
     { NULL, NULL, NULL, 0, 0 },
 };
 
 
 static int
-modehelp(void)
+modehelp(int val)
 {
     struct modelist *mt;
 
+    (void)val;
     printf("format is:  'mode Mode', where 'Mode' is one of:\n\n");
     for (mt = ModeList; mt->name; mt++) {
 	if (mt->help) {
@@ -1303,8 +1325,9 @@
 }
 
 static int
-togcrmod(void)
+togcrmod(int v, char **p)
 {
+    (void)v; (void)p;
     crmod = !crmod;
     printf("Deprecated usage - please use 'toggle crmod' in the future.\n");
     printf("%s map carriage return on output.\n", crmod ? "Will" : "Won't");
@@ -1313,8 +1336,9 @@
 }
 
 static int
-suspend(void)
+suspend(int v, char **p)
 {
+	(void)v; (void)p;
 #ifdef	SIGTSTP
     setcommandmode();
     {
@@ -1421,8 +1445,17 @@
 }
 
 static int
-logout(void)
+quitf(int v, char **p)
 {
+	(void)v; (void)p;
+	quit();
+	return -1;
+}
+
+static int
+logout(int v, char **p)
+{
+	(void)v; (void)p;
 	send_do(TELOPT_LOGOUT, 1);
 	(void) netflush();
 	return 1;
@@ -1440,24 +1473,30 @@
 	int	arg;
 };
 
-static void slc_help(void);
+static void slc_help(int);
 
+static void slc_mode_exportf(int v) {
+    (void)v;
+    slc_mode_export();
+}
+
 struct slclist SlcList[] = {
     { "export",	"Use local special character definitions",
-						(void (*)(int))slc_mode_export,	0 },
+						slc_mode_exportf,	0 },
     { "import",	"Use remote special character definitions",
 						slc_mode_import,	1 },
     { "check",	"Verify remote special character definitions",
 						slc_mode_import,	0 },
-    { "help",	NULL,				(void (*)(int))slc_help,		0 },
-    { "?",	"Print help information",	(void (*)(int))slc_help,		0 },
+    { "help",	NULL,				slc_help,		0 },
+    { "?",	"Print help information",	slc_help,		0 },
     { NULL, NULL, NULL, 0 },
 };
 
 static void
-slc_help(void)
+slc_help(int v)
 {
     struct slclist *c;
+    (void)v;
 
     for (c = SlcList; c->name; c++) {
 	if (c->help) {
@@ -1509,49 +1548,54 @@
 struct envlist {
 	const char	*name;
 	const char	*help;
-	void	(*handler)(unsigned char *, unsigned char *);
+	void	(*handler)(char *, char *);
 	int	narg;
 };
 
-extern struct env_lst *
-	env_define(const unsigned char *, unsigned char *);
-extern void
-	env_undefine(unsigned char *),
-	env_export(const unsigned char *),
-	env_unexport(const unsigned char *),
-	env_send(unsigned char *),
+static struct env_lst *
+	env_define(const char *, char *);
+static void
+	env_undefine(char *, char *),
+	env_export(char *, char *),
+	env_unexport(char *, char *),
+	env_send(char *, char *),
 #if defined(OLD_ENVIRON) && defined(ENV_HACK)
-	env_varval(unsigned char *),
+	env_varval(char *, char *),
 #endif
-	env_list(void);
+	env_list(char *, char *);
 static void
-	env_help(void);
+	env_help(char *, char *);
 
+static void envf_define(char *a, char *b) {
+    env_define(a, b);
+}
+
 struct envlist EnvList[] = {
     { "define",	"Define an environment variable",
-						(void (*)(unsigned char *, unsigned char *))env_define,	2 },
+						envf_define,	2 },
     { "undefine", "Undefine an environment variable",
-						(void (*)(unsigned char *, unsigned char *))env_undefine,	1 },
+						env_undefine,	1 },
     { "export",	"Mark an environment variable for automatic export",
-						(void (*)(unsigned char *, unsigned char *))env_export,	1 },
+						env_export,	1 },
     { "unexport", "Don't mark an environment variable for automatic export",
-						(void (*)(unsigned char *, unsigned char *))env_unexport,	1 },
-    { "send",	"Send an environment variable", (void (*)(unsigned char *, unsigned char *))env_send,	1 },
+						env_unexport,	1 },
+    { "send",	"Send an environment variable", env_send,	1 },
     { "list",	"List the current environment variables",
-						(void (*)(unsigned char *, unsigned char *))env_list,	0 },
+						env_list,	0 },
 #if defined(OLD_ENVIRON) && defined(ENV_HACK)
     { "varval", "Reverse VAR and VALUE (auto, right, wrong, status)",
-						(void (*)(unsigned char *, unsigned char *))env_varval,    1 },
+						env_varval,    1 },
 #endif
-    { "help",	NULL,				(void (*)(unsigned char *, unsigned char *))env_help,		0 },
-    { "?",	"Print help information",	(void (*)(unsigned char *, unsigned char *))env_help,		0 },
+    { "help",	NULL,				env_help,		0 },
+    { "?",	"Print help information",	env_help,		0 },
     { NULL, NULL, NULL, 0 },
 };
 
 static void
-env_help(void)
+env_help(char *var, char *val)
 {
     struct envlist *c;
+    (void)var; (void)val;
 
     for (c = EnvList; c->name; c++) {
 	if (c->help) {
@@ -1605,8 +1649,8 @@
 struct env_lst {
 	struct env_lst *next;	/* pointer to next structure */
 	struct env_lst *prev;	/* pointer to previous structure */
-	unsigned char *var;	/* pointer to variable name */
-	unsigned char *value;	/* pointer to variable value */
+	char *var;	/* pointer to variable name */
+	char *value;	/* pointer to variable value */
 	int export;		/* 1 -> export with default list of variables */
 	int welldefined;	/* A well defined variable */
 };
@@ -1614,7 +1658,7 @@
 struct env_lst envlisthead;
 
 static struct env_lst *
-env_find(const unsigned char *var)
+env_find(const char *var)
 {
 	struct env_lst *ep;
 
@@ -1635,8 +1679,7 @@
 	for (epp = environ; *epp; epp++) {
 		if ((cp = strchr(*epp, '='))) {
 			*cp = '\0';
-			ep = env_define((unsigned char *)*epp,
-					(unsigned char *)cp+1);
+			ep = env_define(*epp, cp+1);
 			ep->export = 0;
 			*cp = '=';
 		}
@@ -1657,7 +1700,7 @@
 		asprintf(&cp, "%s%s", hbuf, cp2);
 		assert(cp != NULL);
 		free(ep->value);
-		ep->value = (unsigned char *)cp;
+		ep->value = cp;
 	}
 	/*
 	 * If USER is not defined, but LOGNAME is, then add
@@ -1666,14 +1709,14 @@
 	 */
 	if ((env_find("USER") == NULL) && (ep = env_find("LOGNAME"))) {
 		env_define("USER", ep->value);
-		env_unexport("USER");
+		env_unexport("USER", NULL);
 	}
-	env_export("DISPLAY");
-	env_export("PRINTER");
+	env_export("DISPLAY", NULL);
+	env_export("PRINTER", NULL);
 }
 
-struct env_lst *
-env_define(const unsigned char *var, unsigned char *value)
+static struct env_lst *
+env_define(const char *var, char *value)
 {
 	struct env_lst *ep;
 
@@ -1697,10 +1740,11 @@
 	return(ep);
 }
 
-void
-env_undefine(unsigned char *var)
+static void
+env_undefine(char *var, char *val)
 {
 	struct env_lst *ep;
+	(void)val;
 
 	if ((ep = env_find(var))) {
 		ep->prev->next = ep->next;
@@ -1714,28 +1758,31 @@
 	}
 }
 
-void
-env_export(const unsigned char *var)
+static void
+env_export(char *var, char *val)
 {
 	struct env_lst *ep;
+	(void)val;
 
 	if ((ep = env_find(var)))
 		ep->export = 1;
 }
 
-void
-env_unexport(const unsigned char *var)
+static void
+env_unexport(char *var, char *val)
 {
 	struct env_lst *ep;
+	(void)val;
 
 	if ((ep = env_find(var)))
 		ep->export = 0;
 }
 
-void
-env_send(unsigned char *var)
+static void
+env_send(char *var, char *val)
 {
 	struct env_lst *ep;
+	(void)val;
 
 	if (my_state_is_wont(TELOPT_NEW_ENVIRON)
 #ifdef	OLD_ENVIRON
@@ -1754,14 +1801,15 @@
 		return;
 	}
 	env_opt_start_info();
-	env_opt_add(ep->var);
+	env_opt_add((unsigned char *)ep->var);
 	env_opt_end(0);
 }
 
-void
-env_list(void)
+static void
+env_list(char *var, char *val)
 {
 	struct env_lst *ep;
+	(void)var; (void)val;
 
 	for (ep = envlisthead.next; ep; ep = ep->next) {
 		printf("%c %-20s %s\n", ep->export ? '*' : ' ',
@@ -1781,7 +1829,7 @@
 	if (nep) {
 		while ((nep = nep->next)) {
 			if (nep->export && (nep->welldefined == welldefined))
-				return(nep->var);
+				return (unsigned char *)(nep->var);
 		}
 	}
 	return(NULL);
@@ -1792,22 +1840,23 @@
 {
 	struct env_lst *ep;
 
-	if ((ep = env_find(var)))
-		return(ep->value);
+	if ((ep = env_find((char *)var)))
+		return (unsigned char *)(ep->value);
 	return(NULL);
 }
 
 #if defined(OLD_ENVIRON) && defined(ENV_HACK)
-void
-env_varval(unsigned char *what)
+static void
+env_varval(char *what, char *val)
 {
 	extern int old_env_var, old_env_value, env_auto;
-	int len = strlen((char *)what);
+	int len = strlen(what);
+	(void)val;
 
 	if (len == 0)
 		goto unknown;
 
-	if (strncasecmp((char *)what, "status", len) == 0) {
+	if (strncasecmp(what, "status", len) == 0) {
 		if (env_auto)
 			printf("%s%s", "VAR and VALUE are/will be ",
 					"determined automatically\n");
@@ -1815,15 +1864,15 @@
 			printf("VAR and VALUE set to correct definitions\n");
 		else
 			printf("VAR and VALUE definitions are reversed\n");
-	} else if (strncasecmp((char *)what, "auto", len) == 0) {
+	} else if (strncasecmp(what, "auto", len) == 0) {
 		env_auto = 1;
 		old_env_var = OLD_ENV_VALUE;
 		old_env_value = OLD_ENV_VAR;
-	} else if (strncasecmp((char *)what, "right", len) == 0) {
+	} else if (strncasecmp(what, "right", len) == 0) {
 		env_auto = 0;
 		old_env_var = OLD_ENV_VAR;
 		old_env_value = OLD_ENV_VALUE;
-	} else if (strncasecmp((char *)what, "wrong", len) == 0) {
+	} else if (strncasecmp(what, "wrong", len) == 0) {
 		env_auto = 0;
 		old_env_var = OLD_ENV_VALUE;
 		old_env_value = OLD_ENV_VAR;
@@ -1853,15 +1902,24 @@
 static int
 	auth_help(void);
 
+static int auth_statusf(char *p) {
+    (void)p;
+    return auth_status();
+}
+static int auth_helpf(char *p) {
+    (void)p;
+    return auth_help();
+}
+
 struct authlist AuthList[] = {
     { "status",	"Display current status of authentication information",
-						(int (*)(char *))auth_status,	0 },
+						auth_statusf,	0 },
     { "disable", "Disable an authentication type ('auth disable ?' for more)",
 						auth_disable,	1 },
     { "enable", "Enable an authentication type ('auth enable ?' for more)",
 						auth_enable,	1 },
-    { "help",	NULL,				(int (*)(char *))auth_help,		0 },
-    { "?",	"Print help information",	(int (*)(char *))auth_help,		0 },
+    { "help",	NULL,				auth_helpf,		0 },
+    { "?",	"Print help information",	auth_helpf,		0 },
     { NULL, NULL, NULL, 0 },
 };
 
@@ -1943,6 +2001,39 @@
 static int
 	EncryptHelp(void);
 
+static int EncryptStartf(char *a, char *b) {
+    (void)b;
+    return EncryptStart(a);
+}
+static int EncryptStartInputf(char *a, char *b) {
+    (void)a; (void)b;
+    return EncryptStartInput();
+}
+static int EncryptStartOutputf(char *a, char *b) {
+    (void)a; (void)b;
+    return EncryptStartOutput();
+}
+static int EncryptStopf(char *a, char *b) {
+    (void)b;
+    return EncryptStop(a);
+}
+static int EncryptStopInputf(char *a, char *b) {
+    (void)a; (void)b;
+    return EncryptStopInput();
+}
+static int EncryptStopOutputf(char *a, char *b) {
+    (void)a; (void)b;
+    return EncryptStopOutput();
+}
+static int EncryptStatusf(char *a, char *b) {
+    (void)a; (void)b;
+    return EncryptStatus();
+}
+static int EncryptHelpf(char *a, char *b) {
+    (void)a; (void)b;
+    return EncryptHelp();
+}
+
 struct encryptlist EncryptList[] = {
     { "enable", "Enable encryption. ('encrypt enable ?' for more)",
 						EncryptEnable, 1, 1, 2 },
@@ -1951,22 +2042,22 @@
     { "type", "Set encryption type. ('encrypt type ?' for more)",
 						EncryptType, 0, 1, 1 },
     { "start", "Start encryption. ('encrypt start ?' for more)",
-						(int (*)(char *, char *))EncryptStart, 1, 0, 1 },
+						EncryptStartf, 1, 0, 1 },
     { "stop", "Stop encryption. ('encrypt stop ?' for more)",
-						(int (*)(char *, char *))EncryptStop, 1, 0, 1 },
+						EncryptStopf, 1, 0, 1 },
     { "input", "Start encrypting the input stream",
-						(int (*)(char *, char *))EncryptStartInput, 1, 0, 0 },
+						EncryptStartInputf, 1, 0, 0 },
     { "-input", "Stop encrypting the input stream",
-						(int (*)(char *, char *))EncryptStopInput, 1, 0, 0 },
+						EncryptStopInputf, 1, 0, 0 },
     { "output", "Start encrypting the output stream",
-						(int (*)(char *, char *))EncryptStartOutput, 1, 0, 0 },
+						EncryptStartOutputf, 1, 0, 0 },
     { "-output", "Stop encrypting the output stream",
-						(int (*)(char *, char *))EncryptStopOutput, 1, 0, 0 },
+						EncryptStopOutputf, 1, 0, 0 },
 
     { "status",	"Display current status of authentication information",
-						(int (*)(char *, char *))EncryptStatus,	0, 0, 0 },
-    { "help",	NULL,				(int (*)(char *, char *))EncryptHelp,	0, 0, 0 },
-    { "?",	"Print help information",	(int (*)(char *, char *))EncryptHelp,	0, 0, 0 },
+						EncryptStatusf,	0, 0, 0 },
+    { "help",	NULL,				EncryptHelpf,	0, 0, 0 },
+    { "?",	"Print help information",	EncryptHelpf,	0, 0, 0 },
     { NULL, NULL, NULL, 0, 0, 0 },
 };
 
@@ -2172,7 +2263,7 @@
 {
     unsigned char *srp = 0;
     int proto, opt;
-    int srlen;
+    int srlen = 0;
     int srcroute = 0, result;
     char *cmd, *hostp = 0, *portp = 0, *user = 0;
     char *src_addr = NULL;
@@ -2265,7 +2356,8 @@
 	hostname = hostp;
 	memset(&su, 0, sizeof su);
 	su.sun_family = AF_UNIX;
-	strncpy(su.sun_path, hostp, sizeof su.sun_path);
+	strncpy(su.sun_path, hostp, sizeof su.sun_path - 1);
+	su.sun_path[sizeof su.sun_path - 1] = '\0';
 	if (!quiet_mode)
 	    printf("Trying %s...\n", hostp);
 	net = socket(PF_UNIX, SOCK_STREAM, 0);
@@ -2327,7 +2419,7 @@
         int gni_err = 1;
 
 	if (doaddrlookup)
-	    gni_err = getnameinfo(res->ai_addr, res->ai_addr->sa_len,
+	    gni_err = getnameinfo(res->ai_addr, res->ai_addrlen,
 				  _hostname, sizeof(_hostname) - 1, NULL, 0,
 				  NI_NAMEREQD);
 	if (gni_err != 0)
@@ -2447,13 +2539,16 @@
 
 	if (connect(net, res->ai_addr, res->ai_addrlen) < 0) {
 	    struct addrinfo *next;
+	    const char *addr;
 
 	    next = res->ai_next;
 	    /* If already an af failed, only try same af. */
-	    if (af_error != 0)
-		while (next != NULL && next->ai_family != res->ai_family)
-		    next = next->ai_next;
-	    warn("connect to address %s", sockaddr_ntop(res->ai_addr));
+	    if (af_error != 0) {
+			while (next != NULL && next->ai_family != res->ai_family)
+			    next = next->ai_next;
+		}
+		addr = sockaddr_ntop(res->ai_addr);
+	    warn("connect to address %s", addr ? addr : "(null)");
 	    if (next != NULL) {
 		res = next;
 		(void) NetClose(net);
@@ -2490,7 +2585,7 @@
     }
     if (user) {
 	env_define("USER", user);
-	env_export("USER");
+	env_export("USER", NULL);
     }
     (void) call(status, "status", "notmuch", 0);
     telnet(user); 
@@ -2539,12 +2634,12 @@
 
 static Command cmdtab[] = {
 	{ "close",	closehelp,	bye,		1 },
-	{ "logout",	logouthelp,	(int (*)(int, char **))logout,		1 },
+	{ "logout",	logouthelp,	logout,		1 },
 	{ "display",	displayhelp,	display,	0 },
 	{ "mode",	modestring,	modecmd,	0 },
 	{ "telnet",	openhelp,	tn,		0 },
 	{ "open",	openhelp,	tn,		0 },
-	{ "quit",	quithelp,	(int (*)(int, char **))quit,		0 },
+	{ "quit",	quithelp,	quitf,		0 },
 	{ "send",	sendhelp,	sendcmd,	0 },
 	{ "set",	sethelp,	setcmd,		0 },
 	{ "unset",	unsethelp,	unsetcmd,	0 },
@@ -2557,7 +2652,7 @@
 #ifdef	ENCRYPTION
 	{ "encrypt",	encrypthelp,	encrypt_cmd,	0 },
 #endif	/* ENCRYPTION */
-	{ "z",		zhelp,		(int (*)(int, char **))suspend,	0 },
+	{ "z",		zhelp,		suspend,	0 },
 	{ "!",		shellhelp,	shell,		1 },
 	{ "environ",	envhelp,	env_cmd,	0 },
 	{ "?",		helphelp,	help,		0 },
@@ -2573,7 +2668,7 @@
 static Command cmdtab2[] = {
 	{ "help",	0,		help,		0 },
 	{ "escape",	escapehelp,	setescape,	0 },
-	{ "crmod",	crmodhelp,	(int (*)(int, char **))togcrmod,	0 },
+	{ "crmod",	crmodhelp,	togcrmod,	0 },
 	{ NULL, NULL, NULL, 0 }
 };
 
@@ -2710,6 +2805,11 @@
 static char *rcname = 0;
 static char rcbuf[128];
 
+static void safe_strncpy(char *dest, const char *source, size_t num) {
+    memmove(dest, source, num);
+    dest[num] = '\0';
+}
+
 void
 cmdrc(char *m1, char *m2)
 {
@@ -2755,11 +2855,11 @@
 	    if (isspace(line[0]))
 		continue;
 	    if (strncasecmp(line, m1, l1) == 0)
-		strncpy(line, &line[l1], sizeof(line) - l1);
+		safe_strncpy(line, &line[l1], sizeof(line) - l1);
 	    else if (strncasecmp(line, m2, l2) == 0)
-		strncpy(line, &line[l2], sizeof(line) - l2);
+		safe_strncpy(line, &line[l2], sizeof(line) - l2);
 	    else if (strncasecmp(line, "DEFAULT", 7) == 0)
-		strncpy(line, &line[7], sizeof(line) - 7);
+		safe_strncpy(line, &line[7], sizeof(line) - 7);
 	    else
 		continue;
 	    if (line[0] != ' ' && line[0] != '\t' && line[0] != '\n')
@@ -2854,9 +2954,11 @@
 	unsigned char *cp, *cp2, *lsrp, *ep;
 	struct sockaddr_in *_sin;
 #ifdef INET6
+#ifndef INET6_NO_RTHDR
 	struct sockaddr_in6 *sin6;
-	struct ip6_rthdr *rth;
 #endif
+	struct ip6_rthdr *rth = NULL;
+#endif
 	struct addrinfo hints, *res;
 	int error;
 	char c;
@@ -2868,7 +2970,7 @@
 	if (cpp == NULL || lenp == NULL)
 		return -1;
 	if (*cpp != NULL) {
-		switch (res->ai_family) {
+		switch (ai->ai_family) {
 		case AF_INET:
 			if (*lenp < 7)
 				return -1;
@@ -2890,14 +2992,17 @@
 		lsrp = *cpp;
 		ep = lsrp + *lenp;
 	} else {
-		*cpp = lsrp = (char *)ALIGN(buf);
+		*cpp = lsrp = (unsigned char *)ALIGN(buf);
 		ep = lsrp + 1024;
 	}
 
-	cp = arg;
+	cp = (unsigned char *)arg;
 
 #ifdef INET6
 	if (ai->ai_family == AF_INET6) {
+#ifdef INET6_NO_RTHDR
+		return -1;
+#else
 		if ((rth = inet6_rth_init((void *)*cpp, sizeof(buf),
 					  IPV6_RTHDR_TYPE_0, 0)) == NULL)
 			return -1;
@@ -2905,6 +3010,7 @@
 			return -1;
 		*protop = IPPROTO_IPV6;
 		*optp = IPV6_RTHDR;
+#endif
 	} else
 #endif
       {
@@ -2960,10 +3066,10 @@
 			cp2 = 0;
 
 		hints.ai_flags = AI_NUMERICHOST;
-		error = getaddrinfo(cp, NULL, &hints, &res);
+		error = getaddrinfo((char *)cp, NULL, &hints, &res);
 		if (error == EAI_NONAME) {
 			hints.ai_flags = 0;
-			error = getaddrinfo(cp, NULL, &hints, &res);
+			error = getaddrinfo((char *)cp, NULL, &hints, &res);
 		}
 		if (error != 0) {
 			fprintf(stderr, "%s: %s\n", cp, gai_strerror(error));
@@ -2975,9 +3081,13 @@
 		}
 #ifdef INET6
 		if (res->ai_family == AF_INET6) {
+#ifdef INET6_NO_RTHDR
+			return -1;
+#else
 			sin6 = (struct sockaddr_in6 *)res->ai_addr;
 			if (inet6_rth_add((void *)rth, &sin6->sin6_addr) == -1)
 				return(0);
+#endif
 		} else
 #endif
 	      {
--- src.orig/telnet/telnet/externs.h
+++ src.freebsd/telnet/telnet/externs.h
@@ -68,7 +68,7 @@
 #include <string.h>
 
 #if defined(IPSEC)
-#include <netipsec/ipsec.h>
+#include <linux/ipsec.h>
 #if defined(IPSEC_POLICY_IPSEC)
 extern char *ipsec_policy_in;
 extern char *ipsec_policy_out;
--- src.orig/telnet/telnet/main.c
+++ src.freebsd/telnet/telnet/main.c
@@ -36,6 +36,7 @@
 __FBSDID("$FreeBSD$");
 
 #include <sys/param.h>
+#include <sys/types.h>
 #include <sys/socket.h>
 #include <stdlib.h>
 #include <string.h>
--- src.orig/telnet/telnet/ring.c
+++ src.freebsd/telnet/telnet/ring.c
@@ -49,6 +49,7 @@
 #include	<errno.h>
 #include	<stdio.h>
 #include	<string.h>
+#include <stdint.h>
 
 #ifdef	size_t
 #undef	size_t
@@ -179,7 +180,7 @@
 	ring->clearto = 0;
     else if (ring->consume + count > ring->top &&
 		ring->bottom <= ring->clearto &&
-		ring->bottom + ((ring->consume + count) - ring->top))
+		(uintptr_t)ring->bottom + (uintptr_t)((ring->consume + count) - ring->top))
 	ring->clearto = 0;
 #endif	/* ENCRYPTION */
     ring->consume = ring_increment(ring, ring->consume, count);
--- src.orig/telnet/telnet/sys_bsd.c
+++ src.freebsd/telnet/telnet/sys_bsd.c
@@ -41,6 +41,7 @@
  */
 
 #include <sys/param.h>
+#include <sys/types.h>
 #include <sys/socket.h>
 #include <sys/time.h>
 #include <err.h>
@@ -73,7 +74,7 @@
 # define old_tc ottyb
 
 #else	/* USE_TERMIO */
-struct	termio old_tc = { 0, 0, 0, 0, {}, 0, 0 };
+struct	termio old_tc = {0};
 
 # ifndef	TCSANOW
 #  ifdef TCSETS
@@ -650,7 +651,12 @@
 #ifdef	SIGTSTP
 	(void) signal(SIGTSTP, SIG_DFL);
 # ifndef SOLARIS
-	(void) sigsetmask(sigblock(0) & ~(1<<(SIGTSTP-1)));
+	{
+		sigset_t sigs;
+		sigemptyset (&sigs);
+		sigaddset (&sigs, SIGTSTP);
+		sigprocmask (SIG_UNBLOCK, &sigs, 0);
+	}
 # else	/* SOLARIS */
 	(void) sigrelse(SIGTSTP);
 # endif	/* SOLARIS */
@@ -1033,7 +1039,7 @@
      */
     if (FD_ISSET(tin, ibitsp)) {
 	FD_CLR(tin, ibitsp);
-	c = TerminalRead(ttyiring.supply, ring_empty_consecutive(&ttyiring));
+	c = TerminalRead((char *)ttyiring.supply, ring_empty_consecutive(&ttyiring));
 	if (c < 0 && errno == EIO)
 	    c = 0;
 	if (c < 0 && errno == EWOULDBLOCK) {
--- src.orig/telnet/telnet/telnet.c
+++ src.freebsd/telnet/telnet/telnet.c
@@ -42,8 +42,15 @@
  * declared in curses.h.
  */
 
-#include <ctype.h>
+#ifdef HAVE_NCURSESW_NCURSES_H
+#include <ncursesw/ncurses.h>
+#elif defined HAVE_NCURSES_H
+#include <ncurses.h>
+#else
 #include <curses.h>
+#endif
+
+#include <ctype.h>
 #include <signal.h>
 #include <stdlib.h>
 #include <term.h>
@@ -208,7 +215,7 @@
 void
 DoBaudRate(char *arg)
 {
-    char *temp, temp2[10];
+    char *temp, temp2[16];
     int i;
     uint32_t baudrate;
 
@@ -218,14 +225,14 @@
 	ExitString("Invalid baud rate provided.\n", 1);
 
     for (i = 1; termspeeds[i].speed != -1; i++)
-	if (baudrate == termspeeds[i].speed)
+	if ((int)baudrate == termspeeds[i].speed)
 	    break;
     if (termspeeds[i].speed == -1)
 	ExitString("Invalid baud rate provided.\n", 1);
 
-    strlcpy(ComPortBaudRate, arg, sizeof(ComPortBaudRate));
+    strlcpy((char *)ComPortBaudRate, arg, sizeof(ComPortBaudRate));
 
-    if (NETROOM() < sizeof(temp2)) {
+    if (NETROOM() < (int)sizeof(temp2)) {
 	ExitString("No room in buffer for baud rate.\n", 1);
 	/* NOTREACHED */
     }
@@ -235,8 +242,8 @@
 
     baudrate = htonl(baudrate);
     memcpy(&temp2[4], &baudrate, sizeof(baudrate));
-    ring_supply_data(&netoring, temp2, sizeof(temp2));
-    printsub('>', &temp[2], sizeof(temp2) - 2);
+    ring_supply_data(&netoring, (unsigned char *)temp2, sizeof(temp2));
+    printsub('>', (unsigned char *)&temp[2], sizeof(temp2) - 2);
 }
 
 void
@@ -386,8 +393,9 @@
 	    case TELOPT_SGA:
 		if (!kludgelinemode)
 		    break;
-		/* FALLTHROUGH */
+		goto telopt_echo;
 #endif
+	    telopt_echo:
 	    case TELOPT_ECHO:
 		settimer(modenegotiated);
 		break;
@@ -477,7 +485,7 @@
 #endif
 
 	    case TELOPT_XDISPLOC:	/* X Display location */
-		if (env_getvalue("DISPLAY"))
+		if (env_getvalue((unsigned char *)"DISPLAY"))
 		    new_state_ok = 1;
 		break;
 
@@ -730,7 +738,7 @@
 		resettermname = 0;
 		if (tnamep && tnamep != unknown)
 			free(tnamep);
-		if ((tname = env_getvalue("TERM")) &&
+		if ((tname = (char *)env_getvalue((unsigned char *)"TERM")) &&
 				(setupterm(tname, 1, &err) == 0)) {
 			tnamep = mklist(termbuf, tname);
 		} else {
@@ -775,7 +783,7 @@
 	    return;
 	} else {
 	    const char *name;
-	    unsigned char temp[50];
+	    char temp[50];
 	    int len;
 
 	    name = gettermname();
@@ -783,8 +791,8 @@
 	    if (len < NETROOM()) {
 		snprintf(temp, sizeof(temp), "%c%c%c%c%s%c%c", IAC, SB, TELOPT_TTYPE,
 				TELQUAL_IS, name, IAC, SE);
-		ring_supply_data(&netoring, temp, len);
-		printsub('>', &temp[2], len-2);
+		ring_supply_data(&netoring, (unsigned char *)temp, len);
+		printsub('>', (unsigned char *)&temp[2], len-2);
 	    } else {
 		ExitString("No room in buffer for terminal type.\n", 1);
 		/*NOTREACHED*/
@@ -798,18 +806,18 @@
 	    return;
 	if (SB_GET() == TELQUAL_SEND) {
 	    long ospeed, ispeed;
-	    unsigned char temp[50];
+	    char temp[50];
 	    int len;
 
 	    TerminalSpeeds(&ispeed, &ospeed);
 
-	    snprintf((char *)temp, sizeof(temp), "%c%c%c%c%ld,%ld%c%c", IAC, SB, TELOPT_TSPEED,
+	    snprintf(temp, sizeof(temp), "%c%c%c%c%ld,%ld%c%c", IAC, SB, TELOPT_TSPEED,
 		    TELQUAL_IS, ospeed, ispeed, IAC, SE);
-	    len = strlen((char *)temp+4) + 4;	/* temp[3] is 0 ... */
+	    len = strlen(temp+4) + 4;	/* temp[3] is 0 ... */
 
 	    if (len < NETROOM()) {
-		ring_supply_data(&netoring, temp, len);
-		printsub('>', temp+2, len - 2);
+		ring_supply_data(&netoring, (unsigned char *)temp, len);
+		printsub('>', (unsigned char *)&temp[2], len - 2);
 	    }
 /*@*/	    else printf("lm_will: not enough room in buffer\n");
 	}
@@ -897,10 +905,10 @@
 	if (SB_EOF())
 	    return;
 	if (SB_GET() == TELQUAL_SEND) {
-	    unsigned char temp[50], *dp;
+	    char temp[50], *dp;
 	    int len;
 
-	    if ((dp = env_getvalue("DISPLAY")) == NULL ||
+	    if ((dp = (char *)env_getvalue((unsigned char *)"DISPLAY")) == NULL ||
 		strlen(dp) > sizeof(temp) - 7) {
 		/*
 		 * Something happened, we no longer have a DISPLAY
@@ -911,11 +919,11 @@
 	    }
 	    snprintf(temp, sizeof(temp), "%c%c%c%c%s%c%c", IAC, SB,
 		    TELOPT_XDISPLOC, TELQUAL_IS, dp, IAC, SE);
-	    len = strlen((char *)temp+4) + 4;	/* temp[3] is 0 ... */
+	    len = strlen(temp+4) + 4;	/* temp[3] is 0 ... */
 
 	    if (len < NETROOM()) {
-		ring_supply_data(&netoring, temp, len);
-		printsub('>', temp+2, len - 2);
+		ring_supply_data(&netoring, (unsigned char *)temp, len);
+		printsub('>', (unsigned char *)&temp[2], len - 2);
 	    }
 /*@*/	    else printf("lm_will: not enough room in buffer\n");
 	}
@@ -1584,7 +1592,7 @@
 		opt_replyp = opt_reply + len - (opt_replyend - opt_replyp);
 		opt_replyend = opt_reply + len;
 	}
-	if (opt_welldefined(ep))
+	if (opt_welldefined((const char *)ep))
 #ifdef	OLD_ENVIRON
 		if (telopt_environ == TELOPT_OLD_ENVIRON)
 			*opt_replyp++ = old_env_var;
@@ -1953,7 +1961,7 @@
 				continue;
 			}
 			if (sc == escape) {
-				command(0, tbp, tcc);
+				command(0, (const char *)tbp, tcc);
 				bol = 1;
 				count += tcc;
 				tcc = 0;
@@ -2144,7 +2152,7 @@
 	send_will(TELOPT_LINEMODE, 1);
 	send_will(TELOPT_NEW_ENVIRON, 1);
 	send_do(TELOPT_STATUS, 1);
-	if (env_getvalue("DISPLAY"))
+	if (env_getvalue((unsigned char *)"DISPLAY"))
 	    send_will(TELOPT_XDISPLOC, 1);
 	if (eight)
 	    tel_enter_binary(eight);
--- src.orig/telnet/telnet/terminal.c
+++ src.freebsd/telnet/telnet/terminal.c
@@ -128,7 +128,7 @@
 	    TerminalFlushOutput();
 	    /* we leave 'n' alone! */
 	} else {
-	    n = TerminalWrite(ttyoring.consume, n);
+	    n = TerminalWrite((char *)ttyoring.consume, n);
 	}
     }
     if (n > 0) {
@@ -143,7 +143,7 @@
 	if (n1 == n && n0 > n) {
 		n1 = n0 - n;
 		if (!drop)
-			n1 = TerminalWrite(ttyoring.bottom, n1);
+			n1 = TerminalWrite((char *)ttyoring.bottom, n1);
 		if (n1 > 0)
 			n += n1;
 	}
--- src.orig/telnet/telnet/utilities.c
+++ src.freebsd/telnet/telnet/utilities.c
@@ -435,7 +435,7 @@
 			((pointer[3] & AUTH_HOW_MASK) == AUTH_HOW_MUTUAL) ?
 			"MUTUAL" : "ONE-WAY");
 
-		auth_printsub(&pointer[1], length - 1, buf, sizeof(buf));
+		auth_printsub(&pointer[1], length - 1, (unsigned char *)buf, sizeof(buf));
 		fprintf(NetTrace, "%s", buf);
 		break;
 
@@ -513,7 +513,7 @@
 		else
 		    fprintf(NetTrace, " %d (unknown)", pointer[2]);
 
-		encrypt_printsub(&pointer[1], length - 1, buf, sizeof(buf));
+		encrypt_printsub(&pointer[1], length - 1, (unsigned char *)buf, sizeof(buf));
 		fprintf(NetTrace, "%s", buf);
 		break;
 
--- src.orig/tip/getcap.c
+++ src.freebsd/tip/getcap.c
@@ -34,7 +34,6 @@
 
 #include <sys/cdefs.h>
 __SCCSID("@(#)getcap.c	8.3 (Berkeley) 3/25/94");
-#include "namespace.h"
 #include <sys/types.h>
 
 #include <ctype.h>
@@ -45,9 +44,8 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
-#include "un-namespace.h"
 
-#include <db.h>
+#include "getcap.h"
 
 #define	BFRAG		1024
 #define	BSIZE		1024
@@ -63,7 +61,6 @@
 static char	*toprec;	/* Additional record specified by cgetset() */
 static int	 gottoprec;	/* Flag indicating retrieval of toprecord */
 
-static int	cdbget(DB *, char **, const char *);
 static int 	getent(char **, u_int *, char **, int, const char *, int, char *);
 static int	nfcmp(char *, char *);
 
@@ -185,12 +182,10 @@
 getent(char **cap, u_int *len, char **db_array, int fd, const char *name,
     int depth, char *nfield)
 {
-	DB *capdbp;
 	char *r_end, *rp, **db_p;
-	int myfd, eof, foundit, retval;
-	char *record, *cbuf;
+	int myfd, eof, foundit;
+	char *record;
 	int tc_not_resolved;
-	char pbuf[_POSIX_PATH_MAX];
 
 	/*
 	 * Return with ``loop detected'' error if we've recursed more than
@@ -238,6 +233,7 @@
 			(void)lseek(fd, (off_t)0, SEEK_SET);
 			myfd = 0;
 		} else {
+#if 0
 			(void)snprintf(pbuf, sizeof(pbuf), "%s.db", *db_p);
 			if ((capdbp = dbopen(pbuf, O_RDONLY, 0, DB_HASH, 0))
 			     != NULL) {
@@ -261,8 +257,10 @@
 				*len = strlen(cbuf);
 				*cap = cbuf;
 				return (retval);
-			} else {
-				fd = _open(*db_p, O_RDONLY | O_CLOEXEC, 0);
+			} else
+#endif
+			{
+				fd = open(*db_p, O_RDONLY | O_CLOEXEC, 0);
 				if (fd < 0)
 					continue;
 				myfd = 1;
@@ -297,10 +295,10 @@
 				if (bp >= b_end) {
 					int n;
 
-					n = _read(fd, buf, sizeof(buf));
+					n = read(fd, buf, sizeof(buf));
 					if (n <= 0) {
 						if (myfd)
-							(void)_close(fd);
+							(void)close(fd);
 						if (n < 0) {
 							free(record);
 							return (-2);
@@ -339,7 +337,7 @@
 					if (record == NULL) {
 						errno = ENOMEM;
 						if (myfd)
-							(void)_close(fd);
+							(void)close(fd);
 						return (-2);
 					}
 					r_end = record + newsize;
@@ -431,7 +429,7 @@
 				/* an error */
 				if (iret < -1) {
 					if (myfd)
-						(void)_close(fd);
+						(void)close(fd);
 					free(record);
 					return (iret);
 				}
@@ -481,7 +479,7 @@
 				if (record == NULL) {
 					errno = ENOMEM;
 					if (myfd)
-						(void)_close(fd);
+						(void)close(fd);
 					free(icap);
 					return (-2);
 				}
@@ -513,7 +511,7 @@
 	 * return capability, length and success.
 	 */
 	if (myfd)
-		(void)_close(fd);
+		(void)close(fd);
 	*len = rp - record - 1;	/* don't count NUL */
 	if (r_end > rp)
 		if ((record =
@@ -528,6 +526,7 @@
 	return (0);
 }
 
+#if 0
 static int
 cdbget(DB *capdbp, char **bp, const char *name)
 {
@@ -563,6 +562,7 @@
 	free(namebuf);
 	return (((char *)(data.data))[0] == TCERR ? 1 : 0);
 }
+#endif
 
 /*
  * Cgetmatch will return 0 if name is one of the names of the capability
@@ -611,7 +611,7 @@
 
 
 
-
+#if 0
 int
 cgetfirst(char **buf, char **db_array)
 {
@@ -768,6 +768,7 @@
 	}
 	/* NOTREACHED */
 }
+#endif
 
 /*
  * Cgetstr retrieves the value of the string capability cap from the
@@ -895,6 +896,7 @@
 	return (len);
 }
 
+#if 0
 /*
  * Cgetustr retrieves the value of the string capability cap from the
  * capability record pointed to by buf.  The difference between cgetustr()
@@ -966,6 +968,7 @@
 	*str = mem;
 	return (len);
 }
+#endif
 
 /*
  * Cgetnum retrieves the value of the numeric capability cap from the
--- src.orig/tip/getcap.h
+++ src.freebsd/tip/getcap.h
@@ -0,0 +1,11 @@
+#ifndef GETCAP_H
+#define GETCAP_H
+
+char *cgetcap(char *, const char *, int);
+int cgetent(char **, char **, const char *);
+int cgetmatch(const char *, const char *);
+int cgetnum(char *, const char *, long *);
+int cgetset(const char *);
+int cgetstr(char *, const char *, char **);
+
+#endif
--- src.orig/tip/libacu/courier.c
+++ src.freebsd/tip/libacu/courier.c
@@ -124,9 +124,13 @@
 cour_disconnect(void)
 {
 	 /* first hang up the modem*/
-	ioctl(FD, TIOCCDTR, 0);
+	int flags = 0;
+	ioctl(FD, TIOCMGET, &flags);
+	flags &= ~TIOCM_DTR;
+	ioctl(FD, TIOCMSET, &flags);
 	sleep(1);
-	ioctl(FD, TIOCSDTR, 0);
+	flags |= TIOCM_DTR;
+	ioctl(FD, TIOCMSET, &flags);
 	coursync();				/* reset */
 	close(FD);
 }
@@ -270,7 +274,7 @@
 coursync(void)
 {
 	int already = 0;
-	int len;
+	int len, flags = 0;
 	char buf[40];
 
 	while (already++ < MAXRETRY) {
@@ -300,9 +304,12 @@
 		 * Toggle DTR to force anyone off that might have left
 		 * the modem connected.
 		 */
-		ioctl(FD, TIOCCDTR, 0);
+		ioctl(FD, TIOCMGET, &flags);
+		flags &= ~TIOCM_DTR;
+		ioctl(FD, TIOCMSET, &flags);
 		sleep(1);
-		ioctl(FD, TIOCSDTR, 0);
+		flags |= TIOCM_DTR;
+		ioctl(FD, TIOCMSET, &flags);
 	}
 	cour_write(FD, "\rAT Z\r", 6);
 	return (0);
--- src.orig/tip/libacu/dn11.c
+++ src.freebsd/tip/libacu/dn11.c
@@ -130,8 +130,12 @@
 dn_disconnect(void)
 {
 	sleep(2);
-	if (FD > 0)
-		ioctl(FD, TIOCCDTR, 0);
+	if (FD > 0) {
+		int flags = 0;
+		ioctl(FD, TIOCMGET, &flags);
+		flags &= ~TIOCM_DTR;
+		ioctl(FD, TIOCMSET, &flags);
+	}
 	close(FD);
 }
 
@@ -143,7 +147,11 @@
 		kill(child, SIGKILL);
 	if (dn > 0)
 		close(dn);
-	if (FD > 0)
-		ioctl(FD, TIOCCDTR, 0);
+	if (FD > 0) {
+		int flags = 0;
+		ioctl(FD, TIOCMGET, &flags);
+		flags &= ~TIOCM_DTR;
+		ioctl(FD, TIOCMSET, &flags);
+	}
 	close(FD);
 }
--- src.orig/tip/libacu/hayes.c
+++ src.freebsd/tip/libacu/hayes.c
@@ -147,12 +147,16 @@
 hay_disconnect(void)
 {
 	/* first hang up the modem*/
+	int flags = 0;
 #ifdef DEBUG
 	printf("\rdisconnecting modem....\n\r");
 #endif
-	ioctl(FD, TIOCCDTR, 0);
+	ioctl(FD, TIOCMGET, &flags);
+	flags &= ~TIOCM_DTR;
+	ioctl(FD, TIOCMSET, &flags);
 	sleep(1);
-	ioctl(FD, TIOCSDTR, 0);
+	flags |= TIOCM_DTR;
+	ioctl(FD, TIOCMSET, &flags);
 	goodbye();
 }
 
@@ -251,7 +255,7 @@
 static void
 goodbye(void)
 {
-	int len;
+	int len, flags = 0;
 	char c;
 
 	tcflush(FD, TCIOFLUSH);
@@ -287,7 +291,9 @@
 #endif
 	}
 	tcflush(FD, TCIOFLUSH);
-	ioctl(FD, TIOCCDTR, 0);		/* clear DTR (insurance) */
+	ioctl(FD, TIOCMGET, &flags);
+	flags &= ~TIOCM_DTR; /* clear DTR (insurance) */
+	ioctl(FD, TIOCMSET, &flags);
 	close(FD);
 }
 
@@ -296,7 +302,7 @@
 static int
 hay_sync(void)
 {
-	int len, retry = 0;
+	int len, retry = 0, flags = 0;
 
 	while (retry++ <= MAXRETRY) {
 		write(FD, "AT\r", 3);
@@ -312,8 +318,11 @@
 			printf("hay_sync: (\"%s\") %d\n\r", dumbuf, retry);
 #endif
 		}
-		ioctl(FD, TIOCCDTR, 0);
-		ioctl(FD, TIOCSDTR, 0);
+		ioctl(FD, TIOCMGET, &flags);
+		flags &= ~TIOCM_DTR;
+		ioctl(FD, TIOCMSET, &flags);
+		flags |= TIOCM_DTR;
+		ioctl(FD, TIOCMSET, &flags);
 	}
 	printf("Cannot synchronize with hayes...\n\r");
 	return(0);
--- src.orig/tip/libacu/t3000.c
+++ src.freebsd/tip/libacu/t3000.c
@@ -125,9 +125,13 @@
 t3000_disconnect(void)
 {
 	 /* first hang up the modem*/
-	ioctl(FD, TIOCCDTR, 0);
+	int flags = 0;
+	ioctl(FD, TIOCMGET, &flags);
+	flags &= ~TIOCM_DTR;
+	ioctl(FD, TIOCMSET, &flags);
 	sleep(1);
-	ioctl(FD, TIOCSDTR, 0);
+	flags |= TIOCM_DTR;
+	ioctl(FD, TIOCMSET, &flags);
 	t3000_sync();				/* reset */
 	close(FD);
 }
@@ -285,7 +289,7 @@
 t3000_sync(void)
 {
 	int already = 0;
-	int len;
+	int len, flags = 0;
 	char buf[40];
 
 	while (already++ < MAXRETRY) {
@@ -318,9 +322,12 @@
 		 * Toggle DTR to force anyone off that might have left
 		 * the modem connected.
 		 */
-		ioctl(FD, TIOCCDTR, 0);
+		ioctl(FD, TIOCMGET, &flags);
+		flags &= ~TIOCM_DTR;
+		ioctl(FD, TIOCMSET, &flags);
 		sleep(1);
-		ioctl(FD, TIOCSDTR, 0);
+		flags |= TIOCM_DTR;
+		ioctl(FD, TIOCMSET, &flags);
 	}
 	t3000_write(FD, "\rAT Z\r", 6);
 	return (0);
--- src.orig/tip/libacu/v831.c
+++ src.freebsd/tip/libacu/v831.c
@@ -139,7 +139,10 @@
         printf("[disconnect: FD=%d]\n", FD);
 #endif
         if (FD > 0) {
-                ioctl(FD, TIOCCDTR, 0);
+		int flags = 0;
+		ioctl(FD, TIOCMGET, &flags);
+		flags &= ~TIOCM_DTR;
+		ioctl(FD, TIOCMSET, &flags);
 		tcgetattr(FD, &cntrl);
 		cfsetospeed(&cntrl, 0);
 		cfsetispeed(&cntrl, 0);
@@ -161,8 +164,12 @@
         if (FD > 0)
                 ioctl(FD, TIOCNXCL, NULL);
         close(AC);
-        if (FD > 0)
-                ioctl(FD, TIOCCDTR, 0);
+        if (FD > 0) {
+                int flags = 0;
+                ioctl(FD, TIOCMGET, &flags);
+                flags &= ~TIOCM_DTR;
+                ioctl(FD, TIOCMSET, &flags);
+        }
         close(FD);
 }
 
--- src.orig/tip/libacu/ventel.c
+++ src.freebsd/tip/libacu/ventel.c
@@ -218,7 +218,7 @@
 static int
 vensync(int fd)
 {
-	int already = 0, nread;
+	int already = 0, nread, flags = 0;
 	char buf[60];
 
 	/*
@@ -229,9 +229,12 @@
 	 * If you don't have the ioctl calls to diddle directly
 	 * with DTR, you can always try setting the baud rate to 0.
 	 */
-	ioctl(FD, TIOCCDTR, 0);
+	ioctl(FD, TIOCMGET, &flags);
+	flags &= ~TIOCM_DTR;
+	ioctl(FD, TIOCMSET, &flags);
 	sleep(1);
-	ioctl(FD, TIOCSDTR, 0);
+	flags |= TIOCM_DTR;
+	ioctl(FD, TIOCMSET, &flags);
 	while (already < MAXRETRY) {
 		/*
 		 * After reseting the modem, send it two \r's to
--- src.orig/tip/remote.5
+++ src.freebsd/tip/remote.5
@@ -189,7 +189,7 @@
 is retrieved from the environment).
 .Bd -literal
 UNIX-57600:\e
-:dv=/dev/cuau0:el=^D^U^C^S^Q^O@:oe=^D:du:at=hayes:br#115200:pa=none:
+:dv=/dev/ttyS0:el=^D^U^C^S^Q^O@:oe=^D:du:at=hayes:br#115200:pa=none:
 arpavax|ax:\e
 :pn=\e@:tc=UNIX-57600
 .Ed
--- src.orig/tip/tip/acu.c
+++ src.freebsd/tip/tip/acu.c
@@ -117,7 +117,7 @@
 			tried++;
 		}
 	} else {
-		if ((fd = fopen(PH, "r")) == NOFILE) {
+		if ((fd = fopen(PH, "r")) == NULL) {
 			printf("%s: ", PH);
 			return ("can't open phone number file");
 		}
--- src.orig/tip/tip/cmds.c
+++ src.freebsd/tip/tip/cmds.c
@@ -620,7 +620,7 @@
 	/*
 	 * enable TIPOUT side for dialogue
 	 */
-	kill(tipout_pid, SIGEMT);
+	kill(tipout_pid, SIGBUS);
 	if (boolean(value(SCRIPT)))
 		write(fildes[1], value(RECORD), size(value(RECORD)));
 	write(fildes[1], "\n", 1);
@@ -958,8 +958,7 @@
 	close(pivec[1]);
 	l = read(pivec[0], xname, BUFSIZ);
 	close(pivec[0]);
-	while (wait(&s) != pid);
-		;
+	while (wait(&s) != pid) {}
 	s &= 0377;
 	if (s != 0 && s != SIGPIPE) {
 		fprintf(stderr, "\"Echo\" failed\n");
--- src.orig/tip/tip/cu.1
+++ src.freebsd/tip/tip/cu.1
@@ -68,9 +68,9 @@
 .It Fl l Ar line
 Specify the line to use.
 Either of the forms like
-.Pa cuau0
+.Pa ttyS0
 or
-.Pa /dev/cuau0
+.Pa /dev/ttyS0
 are permitted.
 .It Fl o
 Use odd parity.
@@ -486,17 +486,17 @@
 .Dq Li /bin/sh .
 .El
 .Sh FILES
-.Bl -tag -width ".Pa /var/spool/lock/LCK..*" -compact
+.Bl -tag -width ".Pa /var/lock/LCK..*" -compact
 .It Pa /var/log/aculog
 line access log
-.It Pa /var/spool/lock/LCK..*
+.It Pa /var/lock/LCK..*
 lock file to avoid conflicts with
 .Xr uucp 1 Pq Pa ports/net/freebsd-uucp
 .El
 .Sh EXAMPLES
 Connect to the first USB serial port at the speed of 115200 baud:
 .Bd -literal -offset indent
-cu -s 115200 -l /dev/cuaU0
+cu -s 115200 -l /dev/ttyUSB0
 .Ed
 .Sh SEE ALSO
 .Xr tip 1
--- src.orig/tip/tip/pathnames.h
+++ src.freebsd/tip/tip/pathnames.h
@@ -37,6 +37,6 @@
 #include <paths.h>
 
 #define	_PATH_ACULOG		"/var/log/aculog"
-#define	_PATH_LOCKDIRNAME	"/var/spool/lock/LCK..%s"
+#define	_PATH_LOCKDIRNAME	"/var/lock/LCK..%s"
 #define	_PATH_PHONES		"/etc/phones"
 #define	_PATH_REMOTE		"/etc/remote"
--- src.orig/tip/tip/phones
+++ src.freebsd/tip/tip/phones
@@ -1,5 +1,3 @@
-#	From: @(#)phones	5.2 (Berkeley) 6/30/90
-#
 # phones -- remote host phone number data base
 # see tip(1), phones(5)
 # examples:
--- src.orig/tip/tip/remote
+++ src.freebsd/tip/tip/remote
@@ -1,6 +1,3 @@
-#
-#	@(#)remote	5.2 (Berkeley) 6/30/90
-#
 # remote -- remote host description file
 # see tip(1), remote(5)
 #
@@ -51,25 +48,25 @@
 dial14400|14400 Baud Hayes attributes:\
 	br#57600:tc=dial:
 dial|Generic dialing parameters:\
-	:dv=/dev/cuau0:cu=/dev/cuau0:at=hayes:du:pa=none:
+	:dv=/dev/ttyS0:cu=/dev/ttyS0:at=hayes:du:pa=none:
 
 # Hardwired line
 cuau0c|cua0c:dv=/dev/cuau0:br#9600:pa=none:
 
 # Finger friendly shortcuts
-uart0|com1:dv=/dev/cuau0:br#9600:pa=none:
-uart1|com2:dv=/dev/cuau1:br#9600:pa=none:
-uart2|com3:dv=/dev/cuau2:br#9600:pa=none:
-uart3|com4:dv=/dev/cuau3:br#9600:pa=none:
-uart4|com5:dv=/dev/cuau4:br#9600:pa=none:
-uart5|com6:dv=/dev/cuau5:br#9600:pa=none:
-uart6|com7:dv=/dev/cuau6:br#9600:pa=none:
-uart7|com8:dv=/dev/cuau7:br#9600:pa=none:
-ucom1:dv=/dev/cuaU0:br#9600:pa=none:
-ucom2:dv=/dev/cuaU1:br#9600:pa=none:
-ucom3:dv=/dev/cuaU2:br#9600:pa=none:
-ucom4:dv=/dev/cuaU3:br#9600:pa=none:
-ucom5:dv=/dev/cuaU4:br#9600:pa=none:
-ucom6:dv=/dev/cuaU5:br#9600:pa=none:
-ucom7:dv=/dev/cuaU6:br#9600:pa=none:
-ucom8:dv=/dev/cuaU7:br#9600:pa=none:
+uart0|com1:dv=/dev/ttyS0:br#9600:pa=none:
+uart1|com2:dv=/dev/ttyS1:br#9600:pa=none:
+uart2|com3:dv=/dev/ttyS2:br#9600:pa=none:
+uart3|com4:dv=/dev/ttyS3:br#9600:pa=none:
+uart4|com5:dv=/dev/ttyS4:br#9600:pa=none:
+uart5|com6:dv=/dev/ttyS5:br#9600:pa=none:
+uart6|com7:dv=/dev/ttyS6:br#9600:pa=none:
+uart7|com8:dv=/dev/ttyS7:br#9600:pa=none:
+ucom1:dv=/dev/ttyUSB0:br#9600:pa=none:
+ucom2:dv=/dev/ttyUSB1:br#9600:pa=none:
+ucom3:dv=/dev/ttyUSB2:br#9600:pa=none:
+ucom4:dv=/dev/ttyUSB3:br#9600:pa=none:
+ucom5:dv=/dev/ttyUSB4:br#9600:pa=none:
+ucom6:dv=/dev/ttyUSB5:br#9600:pa=none:
+ucom7:dv=/dev/ttyUSB6:br#9600:pa=none:
+ucom8:dv=/dev/ttyUSB7:br#9600:pa=none:
--- src.orig/tip/tip/remote.c
+++ src.freebsd/tip/tip/remote.c
@@ -52,6 +52,7 @@
 
 #include "pathnames.h"
 #include "tip.h"
+#include "getcap.h"
 
 /*
  * Attributes to be gleened from remote host description
@@ -126,7 +127,7 @@
 	if (!BR && (cgetnum(bp, "br", &BR) == -1))
 		BR = DEFBR;
 	if (!LD && (cgetnum(bp, "ld", &LD) == -1))
-		LD = TTYDISC;
+		LD = N_TTY;
 	if (cgetnum(bp, "fs", &FS) == -1)
 		FS = DEFFS;
 	if (DU < 0)
--- src.orig/tip/tip/tip.1
+++ src.freebsd/tip/tip/tip.1
@@ -569,7 +569,7 @@
 .Dq Li /bin/sh .
 .El
 .Sh FILES
-.Bl -tag -width ".Pa /var/spool/lock/LCK..*" -compact
+.Bl -tag -width ".Pa /var/lock/LCK..*" -compact
 .It Pa ~/.tiprc
 initialization file
 .It Pa tip.record
@@ -584,7 +584,7 @@
 database
 .It Pa /var/log/aculog
 line access log
-.It Pa /var/spool/lock/LCK..*
+.It Pa /var/lock/LCK..*
 lock file to avoid conflicts with
 .Xr uucp 1 Pq Pa ports/net/freebsd-uucp
 .El
--- src.orig/tip/tip/tip.c
+++ src.freebsd/tip/tip/tip.c
@@ -56,7 +56,7 @@
 #include "tip.h"
 #include "pathnames.h"
 
-int	disc = TTYDISC;		/* tip normally runs this way */
+int	disc = N_TTY;		/* tip normally runs this way */
 char	PNbuf[256];			/* This limits the size of a number */
 
 static void	intprompt(int);
@@ -226,14 +226,13 @@
 	term.c_cc[VTIME] = 0;
 	defchars = term;
 	term.c_cc[VINTR] = term.c_cc[VQUIT] = term.c_cc[VSUSP] =
-	    term.c_cc[VDSUSP] = term.c_cc[VDISCARD] =
-	    term.c_cc[VLNEXT] = _POSIX_VDISABLE;
+	    term.c_cc[VDISCARD] = term.c_cc[VLNEXT] = _POSIX_VDISABLE;
 	raw();
 
 	pipe(fildes); pipe(repdes);
 	(void)signal(SIGALRM, timeout);
 
-	if (value(LINEDISC) != TTYDISC) {
+	if (value(LINEDISC) != N_TTY) {
 		int ld = (int)(intptr_t)value(LINEDISC);
 		ioctl(FD, TIOCSETD, &ld);
 	}		
@@ -391,7 +390,7 @@
 	 * Kinda klugey here...
 	 *   check for scripting being turned on from the .tiprc file,
 	 *   but be careful about just using setscript(), as we may
-	 *   send a SIGEMT before tipout has a chance to set up catching
+	 *   send a SIGBUS before tipout has a chance to set up catching
 	 *   it; so wait a second, then setscript()
 	 */
 	if (boolean(value(SCRIPT))) {
@@ -548,6 +547,20 @@
 	}
 }
 
+static const int baudlist[] = {
+	0, 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400,
+	4800, 9600, 19200, 38400, 57600, 115200, 230400, 460800, 500000,
+	576000, 921600,	1000000, 1152000, 1500000, 2000000, 2500000,
+	3000000, 3500000, 4000000,
+};
+
+static const speed_t baudvals[] = {
+	B0, B50, B75, B110, B134, B150, B200, B300, B600, B1200, B1800, B2400,
+	B4800, B9600, B19200, B38400, B57600, B115200, B230400, B460800, B500000,
+	B576000, B921600, B1000000, B1152000, B1500000, B2000000, B2500000,
+	B3000000, B3500000, B4000000,
+};
+
 /*
  * Set up the "remote" tty's state
  */
@@ -555,10 +568,16 @@
 ttysetup(int speed)
 {
 	struct termios	cntrl;
-
-	if (tcgetattr(FD, &cntrl))
+	speed_t aspeed = B0;
+	for (size_t i = 0; i < (sizeof(baudlist) / sizeof(int)); ++i) {
+		if (baudlist[i] == speed) {
+			aspeed = baudvals[i];
+			break;
+		}
+	}
+	if ((aspeed == B0) || tcgetattr(FD, &cntrl))
 		return (-1);
-	cfsetspeed(&cntrl, speed);
+	cfsetspeed(&cntrl, aspeed);
 	cntrl.c_cflag &= ~(CSIZE|PARENB);
 	cntrl.c_cflag |= CS8;
 	if (boolean(value(DC)))
--- src.orig/tip/tip/tip.h
+++ src.freebsd/tip/tip/tip.h
@@ -42,20 +42,24 @@
 #include <sys/types.h>
 #include <sys/file.h>
 #include <sys/time.h>
+#include <sys/stat.h>
 #include <sys/wait.h>
 #include <sys/ioctl.h>
+#include <sys/ttydefaults.h>
 
 #include <termios.h>
 #include <signal.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <fcntl.h>
 #include <pwd.h>
 #include <ctype.h>
 #include <setjmp.h>
 #include <unistd.h>
 #include <errno.h>
 #include <limits.h>
+#include <time.h>
 
 #ifndef EXTERN
 #define	EXTERN	extern
@@ -235,7 +239,6 @@
 #define NOVAL	((value_t *)NULL)
 #define NOACU	((acu_t *)NULL)
 #define NOSTR	((char *)NULL)
-#define NOFILE	((FILE *)NULL)
 #define NOPWD	((struct passwd *)0)
 
 EXTERN struct termios	term;		/* current mode of terminal */
--- src.orig/tip/tip/tipout.c
+++ src.freebsd/tip/tip/tipout.c
@@ -136,7 +136,7 @@
 
 	signal(SIGINT, SIG_IGN);
 	signal(SIGQUIT, SIG_IGN);
-	signal(SIGEMT, intEMT);		/* attention from TIPIN */
+	signal(SIGBUS, intEMT);		/* attention from TIPIN */
 	signal(SIGTERM, intTERM);	/* time to go signal */
 	signal(SIGIOT, intIOT);		/* scripting going on signal */
 	signal(SIGHUP, intTERM);	/* for dial-ups */
@@ -160,7 +160,7 @@
 		}
 		cnt = scnt;
 		sigemptyset(&mask);
-		sigaddset(&mask, SIGEMT);
+		sigaddset(&mask, SIGBUS);
 		sigaddset(&mask, SIGTERM);
 		sigaddset(&mask, SIGIOT);
 		sigaddset(&mask, SIGSYS);
--- src.orig/tip/tip/uucplock.c
+++ src.freebsd/tip/tip/uucplock.c
@@ -41,8 +41,9 @@
 #endif /* not lint */
 
 #include <sys/types.h>
+#include <sys/param.h>
 #include <sys/file.h>
-#include <sys/dirent.h>
+#include <dirent.h>
 #include <stdio.h>
 #include <string.h>
 #include <signal.h>
--- src.orig/unvis/unvis.c
+++ src.freebsd/unvis/unvis.c
@@ -56,7 +56,6 @@
 	FILE *fp;
 	int ch, eflags = 0;
 
-	setprogname(argv[0]);
 	while ((ch = getopt(argc, argv, "eHhm")) != -1)
 		switch((char)ch) {
 		case 'e':
